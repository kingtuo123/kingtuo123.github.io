[{"content":"stm32 启动模式    BOOT0 BOOT1 启动方式      0 X 内部flash，用户程序    1 0 系统存储器，BootLoader    0 1 内部SRAM，程序调试     厂家的bootloader已提供了串口下载的功能，所以我们只要进入BootLoader即可。\n即在单片机启动时将BOOT0置高电平，BOOT1置低电平。\n一键下载电路 本文以野火霸道V2.0开发板为例\n    要进入bootloader，有以下流程:\n BOOT1 跳线接 GND DTR 置高电平，RTS 置低电平 Q3 导通，NRST 被拉低，单片机复位 Q5 导通，BOOT0 被拉高 DTR 置低电平，释放复位 启动进入 BootLoader  这里注意CH340G 芯片，DTR 和 RTS 输出电平是反向的（芯片图DTR上方有一横线）。所以实际是， DTR 低电平复位，RTS 高电平进入BootLoader。\nWindows ISP 下载   如上图所示：DTR 低电平复位，RTS 高电平进入BootLoader。\nLinux ISP 下载 Linux 下使用 stm32flash 下载。下载解压后文件夹内有 stm32flash_linux 。\n该命令有以下参数\nUsage: stm32flash_linux [-bvngfhc] [-[rw] filename] [tty_device|i2c_device] -a bus_address # 总线地址 -b rate # 波特率 -m mode # 串口模式 -r filename # 读取flash到文件（或者使用 - 符号， 表示标准输出） -w filename # 写入文件到flash（或者使用 - 符号， 表示标准输出） -C # 计算flash crc校验码 -u # 禁用flash写保护 -j # 启用flash读保护 -k # 禁用flash读保护 -o # 仅擦除 -e n # 写入flash前仅擦除n页，默认全擦 -v # 写入后校验 -n count # 写入失败重试次数，默认10 -g address # 指定程序开始执行的地址 -S address[:length] # 指定读取/写入的起始地址和长度（可选） -F RX_length[:TX_length] # 指定接收/发送帧的最大长度 -s start_page # 在指定的页面写入 -f # 强制二进制解析 -h # 显示帮助信息 -c # 恢复连接 -R # 退出时复位设备 -i GPIO_string # 设置进入/退出BootLoader时信号输出的顺序 # GPIO_string=[entry_seq][:[exit_seq]] # sequence=[[-]signal]\u0026amp;|,[sequence] GPIO sequence: # 使用‘dtr’，‘rts’，‘brk’表示串口输出信号 # ‘,’表示在在两个信号之间加100ms延时 # ‘\u0026amp;’表示两个信号之间不加延时 # 在信号前加‘-’表示低电平，不加表示高电平  读取芯片信息，执行以下命令（root）：\nstm32flash_linux -b 115200 -i -dtr,rts,dtr:-dtr,-rts,dtr /dev/ttyUSB0 参数说明：\n -b 115200 ，指定115200波特率 -dtr,rts,-dtr  -dtr 拉低复位 rts 拉高 BOOT0 dtr 释放复位，进入 BootLoader   -dtr,-rts,dtr  -dtr 拉低复位 -rts 拉低 BOOT0 dtr 释放复位，flash启动进入用户程序   /dev/ttyUSB0，设备串口  上述命令执行成功输出以下信息：\nInterface serial_posix: 115200 8E1 GPIO sequence start setting port signal dtr to 0... ok delay 100000 us setting port signal rts to 1... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end Version : 0x22 Option 1 : 0x00 Option 2 : 0x00 Devive ID : 0x0414 (STM32F10XX High-density) - RAM : Up to 64KiB (512b reserved by bootloader) - Flash : Up to 512Kib (size first sector: 2x2048) - Option RAM : 16b - System RAm : 2KiB GPIO sequence start setting port signal dtr to 0... ok delay 100000 us setting port signal rts to 0... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end 下载程序，执行以下命令\nstm32flash_linux -b 115200 -i -dtr,rts,dtr:-dtr,-rts,dtr -v -w test.bin /dev/ttyUSB0 ","permalink":"https://kingtuo123.com/posts/stm32-isp-flash/","summary":"ISP一键下载原理，windows和linux平台ISP下载方法","title":"STM32 ISP 一键下载"},{"content":" 翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\n Makefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command   targets 是文件名，以空格分隔。通常一个规则只有一个目标。\n  command 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\n  prerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n  示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\n make 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的C程序。  blah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c # 第一个运行 下面这个 makefile 有一个目标 some_file 。默认目标是第一个目标，所以将执行 some_file 下的 echo 命令。\nsome_file: echo \u0026#34;This line will always print\u0026#34; 下面这个 makefile 第一次运行会生成 some_file 。第二次运行由于 some_file 已存在，会提示 make: 'some_file' is up to date 。\nsome_file: echo \u0026#34;This line will only print once\u0026#34; touch some_file 下面这个 makefile 中 some_file 依赖 other_file 。当第一次执行 make ，默认目标是 some_file ，它首先会查找依赖文件 other_file ，只要依赖文件比目标文件 some_file 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。\nsome_file: other_file echo \u0026#34;This will run second, because it depends on other_file\u0026#34; touch some_file other_file: echo \u0026#34;This will run first\u0026#34; touch other_file 下面这个 makefile 始终会执行默认目标的命令，因为它的依赖始终无法满足。\nsome_file: other_file touch some_file other_file: echo \u0026#34;nothing\u0026#34; clean 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file 变量 变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。\n使用 $( ) 调用或 ${ }。\nobj = a.o b.o c.o\rtest: $(obj)\rgcc -o test $(obj) 变量赋值一般有如下符号：\n   符号 作用     = 变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。   := 变量赋值，与普通的编程语言中的赋值一样。   += 变量追加赋值   ?= 变量为空则给它赋值    = 与 := 的区别：\n# 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: echo $(one) echo $(two) := 允许你追加变量，但会导致死循环，如下。\none = hello # one gets defined as a simply expanded variable (:=) and thus can handle appending one := ${one} there all: echo $(one) ?= 仅设置尚未设置的变量\none = hello one ?= will not be set two ?= will be set all: echo $(one) # 打印 hello echo $(two) # 打印 will be set 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\n以下 makefile 使用 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 通配符    通配符 作用     * 匹配零或多个字符   % 匹配一个或多个字符   ? 匹配单个字符    * 和 % 在 makefile 中都是通配符，但它们的含义完全不同。\n* 会搜索你的文件系统来匹配文件名。个人建议调用 wildcard 函数来使用 * 。\n# 打印出当前路径下所有以.c结尾的文件的信息 print: $(wildcard *.c) ls -la $?  危险：不要在变量定义中使用 * 。\n危险：当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\n thing_wrong := *.o # 不要这样做，\u0026#39;*\u0026#39; 不会被展开，会被视作 \u0026#34;*.o\u0026#34; 字符串 thing_right := $(wildcard *.o) # 正确做法 all: one two three four # 这里会出错，因为 $(thing_wrong) 是字符串 \u0026#34;*.o\u0026#34; one: $(thing_wrong) # 如果没有文件以 \u0026#34;.o\u0026#34; 结尾，匹配不到文件时也会被视作字符串 \u0026#34;*.o\u0026#34; two: *.o # 正确运行 three: $(thing_right) # 同规则 \u0026#34;three\u0026#34; four: $(wildcard *.o) 自动化变量    符号 描述     $@ 当前目标名   $^ 所有依赖名，去重   $\u0026lt; 第一个依赖名   $+ 所有依赖名，不去重   $? 比目标新的依赖名   $* 目标中%匹配的部分    hey: one two # 输出 \u0026#34;hey\u0026#34; echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two 规则 隐式规则 隐式规则会让东西变得混乱，不推荐使用，但是要了解。\n 编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的  隐式规则常用的几个变量：\n CC ：C 程序编译器，默认 cc 。 CXX ：C++ 程序编译器，默认 g++ 。 CFLAGS ：提供给 C 编译器的参数。 CXXFLAGS ：提供给 C++ 编译器的参数。 CPPFLAGS ：提供给 C 预处理器的参数。 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数。  下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c clean: rm -f blah* 静态模式规则 下面是语法：\ntargets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 函数搭配使用，如下\nobj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \u0026#34;target: $@prereq: $\u0026lt;\u0026#34; # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \u0026#34;target: $@prereq: $\u0026lt;\u0026#34; %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u0026lt; -o $@ 模式规则在目标中包含一个 % 。这个 % 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 % 代表与目标中的 % 匹配的相同词干。\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # $@ 表示目标文件 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。\nall: blah blah:: echo \u0026#34;hello\u0026#34; blah:: echo \u0026#34;hello again\u0026#34; 命令 不打印命令 在命令前加 @ ，在运行时这条命令不会被打印出来。在 make 时加上 -s 参数有同样的效果。\nall: @echo \u0026#34;This make line will not be printed\u0026#34;\recho \u0026#34;But this will\u0026#34; 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\  echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \u0026#34;Hello from bash\u0026#34; 错误处理 在运行 make 时添加 -k 参数（\u0026ndash;keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （\u0026ndash;ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n嵌套执行 make 要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。\n# 双引号中的内容等同于 # hello: # touch inside_file new_contents = \u0026#34;hello:\\n\\ttouch inside_file\u0026#34; all: mkdir -p subdir printf $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile #去掉第一行的空格并写入subdir/makefile cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 使用 export 嵌套 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：\nnew_contents = \u0026#34;hello:\\n\\\\techo \\$$(cooly)\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) # 注意输出的信息，可以看到 export 全局声明起到了作用 cooly = \u0026#34;The subdirectory can see me!\u0026#34; export cooly # 取消全局: unexport cooly  clean: rm -rf subdir 你也可以在 shell 中使用全局变量\none=this will only work locally export two=we can run subcommands with this all: @echo $(one) # $$ 的意思是使用真实的 $ 符号 # 即 echo $one，由于one未声明全局环境变量，所以这条打印为空 @echo $$one @echo $(two) @echo $$two 也可以使用 .EXPORT_ALL_VARIABLES 将所用的变量都声明为全局的。\n.EXPORT_ALL_VARIABLES: new_contents = \u0026#34;hello:\\n\\techo \\$$(cooly)\u0026#34; cooly = \u0026#34;The subdirectory can see me!\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量。在这里，我们使用 make option_one=hi 运行 make\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: echo $(option_one) echo $(option_two) define函数定义 one = export blah=\u0026#34;I was set!\u0026#34;; echo $$blah define two export blah=set echo $$blah endef # One 和 two 是不一样的  all: @echo \u0026#34;这条会打印 \u0026#39;I was set\u0026#39;\u0026#34; @$(one) @echo \u0026#34;这条不会打印 \u0026#39;I was set\u0026#39; 因为每条命令运行在不同的shell中\u0026#34; @$(two) 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 if/else foo = ok all: ifeq ($(foo), ok) echo \u0026#34;foo equals ok\u0026#34; else echo \u0026#34;nope\u0026#34; endif 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格 all: ifeq ($(strip $(foo)),) echo \u0026#34;foo is empty after being stripped\u0026#34; endif ifeq ($(nullstring),) echo \u0026#34;nullstring doesn\u0026#39;t even have spaces\u0026#34; endif 检查变量是否定义 bar = foo = $(bar) all: ifdef foo echo \u0026#34;foo is defined\u0026#34; endif ifdef bar echo \u0026#34;but bar is not\u0026#34; endif 命令行参数 $(MAKEFLAGS) bar = foo = $(bar) all: # 查找 \u0026#34;-i\u0026#34; 参数。 ifneq (,$(findstring i, $(MAKEFLAGS))) echo \u0026#34;i was passed to MAKEFLAGS\u0026#34; endif 函数 函数主要只是用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\n# 字符串替换，这里 totally 替换 not bar := ${substnot, totally, \u0026#34;I am not superman\u0026#34;} all: @echo $(bar) 如果要替换空格或逗号，请使用变量\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \u0026#34;a,b,c\u0026#34; @echo $(bar) 不要在第一个参数之后包含空格。这将被视为字符串的一部分。\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 后面有一个空格 all: # 输出是 \u0026#34;, a , b , c\u0026#34;，注意空格 @echo $(bar) 字符串替换 $(patsubst pattern,replacement,text) 执行以下操作：\n使用 pattern 匹配 text 中的文件名，使用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 $(foreach var,list,text) ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\n这会在每个单词后附加一个感叹号：\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \u0026#34;who! are! you!\u0026#34; @echo $(bar) if 函数 if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 Make 支持创建基本函数。语法是 $(call variable,param,param)\n$(0) 是变量名，$(1) 、$(2) 等是参数。\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \u0026#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\u0026#34; @echo $(call sweet_new_fn, go, tigers) shell 函数 这会调用 shell，但它用空格替换了换行符。\nall: # 非常难看，因为换行符不见了 @echo $(shell ls -la) 其他特性 应用外部makefile include 的语法是\ninclude filenames vpath 指令 语法 vpath \u0026lt;pattern\u0026gt; \u0026lt;directories\u0026gt; ，\u0026lt;pattern\u0026gt; 会匹配 \u0026lt;directories\u0026gt; 中的文件名，多个目录使用 空格 或 冒号 分隔。\nvpath %.h ../headers ../other-directory\rsome_binary: ../headers blah.h\rtouch some_binary\r../headers:\rmkdir ../headers\rblah.h:\rtouch ../headers/blah.h\rclean:\rrm -rf ../headers\rrm -f some_binary .phony make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 标签 ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 make clean 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n.PHONY clean clean: rm -f *.o .delete_on_error 当规则执行失败，.delete_on_error 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise. SRCS := $(shell find $(SRC_DIRS) -name \u0026#39;*.cpp\u0026#39; -or -name \u0026#39;*.c\u0026#39; -or -name \u0026#39;*.s\u0026#39;) # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u0026lt; -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u0026lt; -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # Include the .d makefiles. The - at the front suppresses the errors of missing # Makefiles. Initially, all the .d files will be missing, and we don\u0026#39;t want those # errors to show up. -include $(DEPS) ","permalink":"https://kingtuo123.com/posts/makefile-basic/","summary":"翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\n Makefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command   targets 是文件名，以空格分隔。通常一个规则只有一个目标。\n  command 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\n  prerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n  示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\n make 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.","title":"Makefile基础"},{"content":"docker镜像 拉取镜像 docker image pull \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 查看镜像 docker image ls -a docker images 删除镜像 docker image rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; docker image rm \u0026lt;image id\u0026gt; id不用补全，比如 ba6acccedd29 ，只需输入 ba ，只要id前几位没和其他镜像重复。\n当镜像已有创建的容器时，无法删除。可以使用-f参数强制删除。\n提交镜像 首先你在基础镜像生成的容器中做了修改后，使用 commit 命令可以生成一个新的镜像，这个镜像相较于基础镜像多了一层Layer（你在容器内做的所有修改都打包成了Layer）\ndocker commit -m \u0026#34;some info\u0026#34; 生成的镜像可以用 image 命令查看到，commit 之后你可以使用 push 命令推送到远端仓库\ndocker容器 创建容器 以下命令会自动创建一个容器并运行bash，也可以用 create 命令创建容器。\ndocker container run --name \u0026lt;name\u0026gt; -it --rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; bash run 常用参数：\n --name：指定容器名称 -i：开启标准输入 -t：分配伪终端 --rm：退出容器后自动删除容器，多用于一次性测试 -v：挂载路径，格式 -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; -p：指定端口映射，格式 -p \u0026lt;host port\u0026gt;:\u0026lt;container port\u0026gt; -P：随机端口映射，docker会随机映射一个端口到内部容器的网络端口 -d：后台运行容器，并返回容器ID，类似命令后加\u0026amp; -e：设置环境变量，格式 -e \u0026lt;variables1\u0026gt;=\u0026lt;variables2\u0026gt; --network：连接指定网络，系统预定义的有bridge、host、null三种，默认bridge（桥接） --privileged：扩大容器权限，在容器内可以看到host的更多设备、可mount挂载设备  启动容器 docker container start \u0026lt;name|container id\u0026gt; start 后面可跟多个 id\n进入容器 docker container attach \u0026lt;name|container id\u0026gt; docker container exec -it \u0026lt;name|container id\u0026gt; bash attach 在退出容器后会停止容器，exec 不会\nattach 相当于进入当前终端，exec 相当于新开了一个终端\n停止容器 docker container stop \u0026lt;name|container id\u0026gt; docker container kill \u0026lt;name|container id\u0026gt; stop 先发送SIGTERM信号，容器内程序可以做退出前的准备工作，一段时间之后再发送SIGKILL信号。\nkill 发送SIGKILL信号，应用程序直接退出。\n查看容器 列出所有容器\ndocker container ls -a 删除容器 docker container rm \u0026lt;name|container id\u0026gt; 使用 prune 可以删除所有已停止的容器\ndocker container prune 文件拷贝 拷贝无需容器运行，只要该容器存在即可，以下命令从容器拷贝至主机\ndocker container cp \u0026lt;container id|name\u0026gt;:\u0026lt;container path\u0026gt; \u0026lt;host path\u0026gt; ","permalink":"https://kingtuo123.com/posts/docker-base-cmd/","summary":"docker镜像 拉取镜像 docker image pull \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 查看镜像 docker image ls -a docker images 删除镜像 docker image rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; docker image rm \u0026lt;image id\u0026gt; id不用补全，比如 ba6acccedd29 ，只需输入 ba ，只要id前几位没和其他镜像重复。\n当镜像已有创建的容器时，无法删除。可以使用-f参数强制删除。\n提交镜像 首先你在基础镜像生成的容器中做了修改后，使用 commit 命令可以生成一个新的镜像，这个镜像相较于基础镜像多了一层Layer（你在容器内做的所有修改都打包成了Layer）\ndocker commit -m \u0026#34;some info\u0026#34; 生成的镜像可以用 image 命令查看到，commit 之后你可以使用 push 命令推送到远端仓库\ndocker容器 创建容器 以下命令会自动创建一个容器并运行bash，也可以用 create 命令创建容器。\ndocker container run --name \u0026lt;name\u0026gt; -it --rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; bash run 常用参数：\n --name：指定容器名称 -i：开启标准输入 -t：分配伪终端 --rm：退出容器后自动删除容器，多用于一次性测试 -v：挂载路径，格式 -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; -p：指定端口映射，格式 -p \u0026lt;host port\u0026gt;:\u0026lt;container port\u0026gt; -P：随机端口映射，docker会随机映射一个端口到内部容器的网络端口 -d：后台运行容器，并返回容器ID，类似命令后加\u0026amp; -e：设置环境变量，格式 -e \u0026lt;variables1\u0026gt;=\u0026lt;variables2\u0026gt; --network：连接指定网络，系统预定义的有bridge、host、null三种，默认bridge（桥接） --privileged：扩大容器权限，在容器内可以看到host的更多设备、可mount挂载设备  启动容器 docker container start \u0026lt;name|container id\u0026gt; start 后面可跟多个 id","title":"Docker基本命令"},{"content":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt;这是引用的内容 \u0026gt;\u0026gt;这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片地址 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n 列表内容   列表内容   列表内容  有序列表 数字加点\n1.列表内容 2.列表内容 3.列表内容 列表嵌套 二级列表前加三个空格\n- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 表格 表头|表头2222222|表头33333333 ---|:--:|--: 内容|内容|内容 内容|内容|内容 :--: 表示居中\n--: 靠右\n:--  靠左\n显示如下\n   表头 表头2222222 表头33333333     内容 内容 内容   内容 内容 内容    代码 ​```markdown 代码... 代码... 代码... ​``` ```后可加语言类型，方便解析器解析后实现代码高亮\n","permalink":"https://kingtuo123.com/posts/markdown-syntax/","summary":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt;这是引用的内容 \u0026gt;\u0026gt;这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片地址 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n 列表内容   列表内容   列表内容  有序列表 数字加点","title":"Markdown语法"},{"content":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","permalink":"https://kingtuo123.com/posts/curlftpfs-mount-local/","summary":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","title":"Curlftpfs挂载ftp到本地"},{"content":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。\n验证 ssh -T git@github.com 返回如下信息则配置成功\nYou\u0026#39;ve successfully authenticated, but GitHub does not provide shell access 使用SSH Key推送   使用以上的链接。\n","permalink":"https://kingtuo123.com/posts/github-set-sshkey/","summary":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。","title":"Github设置SSH Key"},{"content":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件  cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考peaceiris/actions-gh-pages \nname:github pageson:push:branches:- masterpaths-ignore:- \u0026#39;README.md\u0026#39;- \u0026#39;.gitignore\u0026#39;- \u0026#39;.gitmodules\u0026#39;pull_request:jobs:deploy:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;extended:true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public推送至仓库  git push -u origin master  查看Action中的信息，如上则配置正确。\n设置GitHub Pages Source 在Pages设置中，修改Source分支为gh-pages\n  等待gh-pages自动部署完成后，即可打开站点。\n网站加速 国内访问 github.io 较慢，部署至阿里云 OSS 并使用 DCDN 加速。\n 也可以直接使用DCDN加速github.io，但使用中发现缓存刷新较慢，导致页面显示异常等。\n Bucket设置 设置Bucket读写权限权限为 公共读\n设置静态页面如下\n  创建Accesskey 打开阿里云控制台右上角 头像 -\u0026gt; Accesskey管理\n  选择 子用户Accesskey\n  Accesskey创建成功后会生成 ID 和 SECRET，记得复制否则要重新创建。\n最后给当前子用户添加 AliyunOSSFullAccess 权限。\n添加Repository secrets 打开仓库主页，Setting -\u0026gt; Secrets -\u0026gt; Actions，添加Accesskey的内容。\n  配置GitHub action 在 gh-pages.yml 里追加以下内容\n- name:Setup AliyunOSSuses:manyuanrong/setup-ossutil@v2.0with:# 地域节点在Bucket概览里查看endpoint:\u0026#34;oss-cn-hangzhou.aliyuncs.com\u0026#34;access-key-id:${{ secrets.ID }}access-key-secret:${{ secrets.SECRET }}- name:Deploy To OSS# 将public下的页面拷贝至Bucketrun:ossutil cp -rf ./public oss://kingtuo123/最后 git push 一下即可。\n全站加速配置 需要已备案的域名。\n再配置全站加速，域名管理 -\u0026gt; 添加域名 ，等待生成 CNAME 记录。\n最后在 DNS解析 中添加域名 CNAME 记录。\n","permalink":"https://kingtuo123.com/posts/hugo-deploy/","summary":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件  cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考peaceiris/actions-gh-pages \nname:github pageson:push:branches:- masterpaths-ignore:- \u0026#39;README.md\u0026#39;- \u0026#39;.gitignore\u0026#39;- \u0026#39;.gitmodules\u0026#39;pull_request:jobs:deploy:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .","title":"Hugo deploy"}]