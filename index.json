[{"content":"Dockerfile 创建 Dockerfile ：\nFROM ubuntu:latest LABEL author=\u0026#34;king\u0026#34; #COPY sources.list /etc/apt EXPOSE 1313 RUN set -ex \u0026amp;\u0026amp; \\ sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt clean \u0026amp;\u0026amp; \\ apt update \u0026amp;\u0026amp; \\ apt -y install hugo WORKDIR /src/hugo CMD bash 构建 $ docker build -t myhugo:latest . 运行容器 $ docker run -it --rm \\ -p 1313:1313 \\ -v $PWD:/src/hugo \\ --user `id -u`:`id -u` \\ myhugo \\ hugo server -D --bind 0.0.0.0 默认root用户运行生成的文件权限为root，这里用 --user 参数指定用户 uid:gid 。\n容器内应用必须绑定 0.0.0.0，如果是 127.0.0.1 （localhost），将无法访问端口。\n查看 host 绑定的ip\n$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 45c23e0f5112 myhugo \u0026#34;hugo server -D --bi…\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:1313-\u0026gt;1313/tcp jolly_morse ","permalink":"https://kingtuo123.com/posts/docker-build-hugo/","summary":"Dockerfile 创建 Dockerfile ：\nFROM ubuntu:latest LABEL author=\u0026#34;king\u0026#34; #COPY sources.list /etc/apt EXPOSE 1313 RUN set -ex \u0026amp;\u0026amp; \\ sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt clean \u0026amp;\u0026amp; \\ apt update \u0026amp;\u0026amp; \\ apt -y install hugo WORKDIR /src/hugo CMD bash 构建 $ docker build -t myhugo:latest . 运行容器 $ docker run -it --rm \\ -p 1313:1313 \\ -v $PWD:/src/hugo \\ --user `id -u`:`id -u` \\ myhugo \\ hugo server -D --bind 0.","title":"Docker构建hugo镜像"},{"content":"参考文档\nDockerfile reference Docker 从入门到实践 常用指令 FROM 设置基础镜像：\nFROM \u0026lt;image name\u0026gt; MAINTAINER 设置镜像作者：\nMAINTAINER \u0026lt;author name\u0026gt; LABLE 设置元数据（键值对）：\nLABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 可替代 MATINTAINER 设置作者：\nLABEL author=king 其他常用的设置还有：version、description、other 等任意参数。\nRUN 编译镜像时运行的脚本：\nRUN \u0026lt;command\u0026gt; RUN [ \u0026#34;\u0026lt;command\u0026gt;\u0026#34; , \u0026#34;[param1]\u0026#34; , \u0026#34;[param2]\u0026#34; ] 如：\nRUN set -ex; apt update \u0026amp;\u0026amp; \\ apt install -y vim 注意：尽量减少 RUN 命令的个数，一个 RUN 就会创建一层 layer 使用 set -x 或 set -ex 开头，查看 man set。\nCOPY 复制文件：\nCOPY \u0026lt;src\u0026gt; \u0026lt;image dest\u0026gt; 如：\nCOPY package.json /usr/src/app/ COPY hom* /mydir/ COPY hom?.txt /mydir/ ADD 复制文件（比 COPY 更高级）：\nCOPY \u0026lt;src\u0026gt; \u0026lt;image dest\u0026gt; \u0026lt;src\u0026gt; 可以是一般文件、目录，压缩文件（自动解压）、URL（自动下载，不解压），如：\nADD test.txt /mydir ADD bin /mydir ADD nginx.tar.gz /usr ADD http://example.com/nginx.tar.gz /mydir WORKDIR 指定工作目录：\nWORKDIR \u0026lt;image path\u0026gt; 如下 a.txt 会被拷贝到 /mydir ：\nWORKDIR /mydir COPY a.txt . USER 指定当前用户，USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN、CMD 以及 ENTRYPOINT 这类命令的身份。\nRUN groupadd -r redis \u0026amp;\u0026amp; useradd -r -g redis redis USER redis RUN [ \u0026#34;redis-server\u0026#34; ] VOLUME 设置容器匿名挂载卷：\nVOLUME [ \u0026#34;\u0026lt;dir\u0026gt;\u0026#34; , \u0026#34;\u0026lt;dir\u0026gt;\u0026#34; , \u0026#34;...\u0026#34; ] VOLUME \u0026lt;dir\u0026gt; EXPOSE 声明运行时容器提供服务的端口：\nEXPOSE \u0026lt;port\u0026gt;[/protocol] 如：\nEXPOSE 80/tcp EXPOSE 80/udp EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。\n在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n如果指定了 \u0026ndash;net=host 宿主机网络模式，容器中 EXPOSE 指令暴露的端口会直接使用宿主机对应的端口，不存在映射关系\nCMD 设置容器启动命令：\nRUN \u0026lt;command\u0026gt; RUN [ \u0026#34;\u0026lt;command\u0026gt;\u0026#34; , [\u0026#34;param1\u0026#34;] , [\u0026#34;param2\u0026#34;] ... ] 如：\nCMD [\u0026#34;zsh\u0026#34;] docker run -it ubuntu 后面不跟命令，启动后会默认打开 zsh 。\ndocker run -it ubuntu /bin/bash 中的 /bin/bash 会替换 dockerfile 中定义的 CMD，启动后会打开 bash 。\nENTRTPOINT 设置容器入口程序：\n# exec 格式 ENTRYPOINT [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] # shell 格式 ENTRYPOINT command param1 param2 ENTRYPOINT 和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：\n\u0026lt;ENTRYPOINT\u0026gt; \u0026#34;\u0026lt;CMD\u0026gt;\u0026#34; 如：\nENTRYPOINT [ \u0026#34;ls\u0026#34; ] docker run -it ubuntu -al 中的 -al 为 \u0026lt;CMD\u0026gt;，作为参数传递给 ENTRYPOINT ，相当于启动时执行了 ls-al 。\nENV 设置环境变量：\nENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt; ... 如：\nENV VERSION=1.0 DEBUG=on \\ NAME=\u0026#34;Happy Feet” ARG 构建参数和 ENV 的效果一样，都是设置环境变量。\nARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 所不同的是，ARG 所设置的是 构建环境 的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。\nDockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg \u0026lt;参数名\u0026gt;=\u0026lt;值\u0026gt; 来覆盖。\nARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于 FROM 指令中。\nARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine RUN set -x ; echo ${DOCKER_USERNAME} ONBUILD ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN、COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\nONBUILD RUN echo \u0026#34;--- i am onbuild ---\u0026#34; ","permalink":"https://kingtuo123.com/posts/dockerfile/","summary":"编写dockerfile，自己构建镜像","title":"Dockerfile"},{"content":"Git 设置 配置文件 /etc/gitconfig\n当前用户配置文件 ~/.gitconfig 或 ~/.config/git/config\n当前仓库配置文件 .git/config\n后面配置会覆盖上层的配置\n账号设置：\ngit config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; git config --global core.editor vim git diff 查看改动\ngit status 查看状态\ngit log 查看commit历史\ngit reset --hard commit_id git reflog 查看命令历史\n","permalink":"https://kingtuo123.com/posts/git-basic/git-basic/","summary":"Git 设置 配置文件 /etc/gitconfig\n当前用户配置文件 ~/.gitconfig 或 ~/.config/git/config\n当前仓库配置文件 .git/config\n后面配置会覆盖上层的配置\n账号设置：\ngit config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; git config --global core.editor vim git diff 查看改动\ngit status 查看状态\ngit log 查看commit历史\ngit reset --hard commit_id git reflog 查看命令历史","title":"git 基础 - 常用命令"},{"content":"参考资料：\nV2rayA 文档 有完整的安装教程 V2rayA 仓库 v2ray-core 仓库 安装 v2ray-core V2rayA 是 Linux 的 V2Ray 客户端，依赖 v2ray-core 运行。\n从这里下载 v2ray-core release 。\n解压后文件夹内有 v2ctl 和 v2ray， ln 链接一下即可。\n安装 V2rayA 从这里下载 v2raya release。\n解压后文件夹内有 v2raya，链接一下。\n客户端设置 root 运行 sudo v2raya 。\n非 root 运行 v2raya --lite ，但没有透明代理等功能。\n浏览器打开 127.0.0.1:2017，首次需要设置用户名密码。\n忘记密码执行 sudo v2raya --reset-password 重置。\n","permalink":"https://kingtuo123.com/posts/v2raya-deploy/","summary":"Linux下V2rayA安装配置","title":"V2rayA 安装配置"},{"content":"安装 vim-plug curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 在 .vimrc 中添加插件，格式如下：\ncall plug#begin() Plug \u0026#39;\u0026lt;插件\u0026gt;\u0026#39; call plug#end() 使用 :PlugInstall 安装插件。\nCommand Description PlugInstall [name \u0026hellip;] [#threads] 安装插件 PlugUpdate [name \u0026hellip;] [#threads] 安装或更新插件 PlugClean[!] 删除未列出的插件 (bang 版本会在没有提示的情况下清理) PlugUpgrade 升级 vim-plug PlugStatus 检查插件的状态 PlugDiff 检查上一次更新的更改和待处理的更改 PlugSnapshot[!] [output path] 生成用于恢复当前插件快照的脚本 常用插件 未完待续\n","permalink":"https://kingtuo123.com/posts/vim-configuration/","summary":"Linux下Vim插件管理/安装配置","title":"Vim 配置"},{"content":" 本文翻译自 Autodependencies with GNU make 水平有限仅供参考。\n问题描述 编译器将 C 源文件（.c 文件）和一些头文件（.h 文件）编译成目标文件（.o 文件）。 make 是一种编排构建过程的工具，因此每当源文件更改时，依赖它的文件都会重新构建。\n虽然 make 能很好地处理 .o 文件对 .c 文件的依赖关系，但它没有内置工具来确定对 .h 文件的依赖关系，也没有方便的表达方式。更重要的是，任何解决方案都必须处理好自动生成的源文件。\n本文概述了我对这个问题的解决方案，实际上非常简单。我最初写这个是因为我认为它是原创的，但事实证明 Paul Smith 已经记录了这个 解决方案。\n情景描述 假设我有一个像这样的（GNU）Makefile：\nOBJS := foo.o bar.o # 链接 proggie: $(OBJS) gcc $(OBJS) -o proggie # 编译 %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o # 清除编译生成的文件 clean: rm -f proggie *.o 这个 Makefile 中描述了两个源文件 foo.c 和 bar.c，它们被编译和链接以生成可执行的 proggie。它还描述了在一般情况下如何在给定 .c 文件的情况下构建 .o 文件。\n但是，假设 foo.c 和 bar.c 都包含 foo.h。这意味着各自的 .o 文件都依赖于 foo.h 的内容，但这一事实并未在 Makefile 中表达。因此，如果程序员更改了 foo.h，那么程序在重建时很可能会出现不一致。\n当然可以添加更多行，例如：\nfoo.o: foo.h bar.o: bar.h 但很明显，除了最小的程序之外，这后续维护起来是个麻烦。\n解决方法 解决方案相当简单：每次我们构建一个 .o 文件时，我们还创建一个扩展名为 .d（用于依赖关系）的文件，该文件记录了哪些文件用于创建相应的 .o 文件。 （请注意，与某些方法相比，我们不会提前创建 .d 文件。） .d 文件将用 make 语言本身编写，并包含在主 Makefile 中。我们可以使用 gcc 的 -MM 选项生成该文件：\nOBJS := foo.o bar.o # link proggie: $(OBJS) gcc $(OBJS) -o proggie # 获取所有 .o 文件的依赖关系 -include $(OBJS:.o=.d) # 编译并生成依赖信息 %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d # remove compilation products clean: rm -f proggie *.o *.d 鉴于上述情况，我们会在编译后得到两个 .d 文件。其中之一 bar.d 看起来像：\nbar.o: bar.c foo.h 当 make 读取这一行时，由于没有指定 shell 命令，它会将依赖项列表附加到 bar.o 已经拥有的任何依赖项，而不会影响用于构建它的命令。\n请注意，当且仅当对应的 .o 文件存在时，.d 文件才存在。这是有道理的，因为如果 .o 文件还不存在，我们不需要 .d 文件来告诉我们必须重建它。\n最巧妙的是，在我们拥有构建相应 .o 文件的必要成分之前，我们从不尝试构建 .d 文件。当项目有一些自动构建的源文件（例如 Bison 输出）时，这一点很重要，因为任何过早构建 .d 文件的尝试都会失败。\n-include $(OBJS:.o=.d) 语法可能需要一些解释。首先，$(OBJS:.o=.d) 取 $(OBJS) 的值，并将名称末尾的所有 .o 替换为 .d。接下来，字符（“-”）表示如果某些 .d 文件不存在，make 应该继续进行而不报错（同样，如果 .d 文件不存在，那么 .o 文件也不存在，所以 .o 文件将被正确重建）。\n关于头文件依赖，参考 这篇文章\n改进一下 上面的 Makefile 有一个问题。假设我将 foo.h 重命名为 foo2.h，并相应地更改 foo.c 和 bar.c。当我尝试重新编译时，make 会提示（例如）bar.o 依赖于不存在的 foo.h。我必须执行 make clean 或类似的事情才能让它再次正常工作。\n参阅 make 手册的第 4 章，“没有命令或先决条件的规则”。 GNU make 有一个晦涩难懂的功能：如果一个文件作为目标出现在没有先决条件和命令的规则中，并且该文件不存在且无法重新创建，那么 make 将重建所有依赖于该文件的目标并且不报告错误。\n要利用此功能，必须为每个 .d 文件添加无命令、无先决条件的规则。有很多方法可以实现，我选择使用 sed 和 fmt 的组合。我还选择在新命令前添加 @ 符号，因此在 make 运行时它们不会得到回显：\nOBJS := foo.o bar.o # link proggie: $(OBJS) gcc $(OBJS) -o proggie # pull in dependency info for *existing* .o files -include $(OBJS:.o=.d) # compile and generate dependency info; # more complicated dependency computation, so all prereqs listed # will also become command-less, prereq-less targets # sed: strip the target (everything before colon) # sed: remove any continuation backslashes # fmt -1: list words one per line # sed: strip leading spaces # sed: add trailing colons %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d @cp -f $*.d $*.d.tmp @sed -e \u0026#39;s/.*://\u0026#39; -e \u0026#39;s/\\\\$$//\u0026#39; \u0026lt; $*.d.tmp | fmt -1 | \\ sed -e \u0026#39;s/^ *//\u0026#39; -e \u0026#39;s/$$/:/\u0026#39; \u0026gt;\u0026gt; $*.d @rm -f $*.d.tmp # remove compilation products clean: rm -f proggie *.o *.d 现在依赖文件看起来像这样：\nbar.o: bar.c foo.h bar.c: foo.h: 再来看之前的假设：假设我将 foo.h 重命名为 foo2.h。由于规则 foo.h: 没有依赖条件且 bar.o 依赖于 foo.h ，bar.o 将被重新编译并生成新的 .d 依赖关系。\n最后调整 如果源文件（和目标 .o 文件）位于与运行 make 的目录不同的目录中，则上述命令将无法正常工作。事实证明，gcc -MM 将创建一个目标名为 bar.o 的 .d 依赖文件，而正确的目标名应为 dir/bar.o。\n例如，上面的 makefile 可能会创建 .d 文件：\nbar.o: dir/bar.c dir/foo.h dir/bar.c: dir/foo.h: 这将起不到作用，因为 Makefile 中没有其他内容引用 bar.o。\n为了解决这个问题，在构建依赖项的块中还需要一个 sed 命令：\n%.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d @mv -f $*.d $*.d.tmp @sed -e \u0026#39;s|.*:|$*.o:|\u0026#39; \u0026lt; $*.d.tmp \u0026gt; $*.d @sed -e \u0026#39;s/.*://\u0026#39; -e \u0026#39;s/\\\\$$//\u0026#39; \u0026lt; $*.d.tmp | fmt -1 | \\ sed -e \u0026#39;s/^ *//\u0026#39; -e \u0026#39;s/$$/:/\u0026#39; \u0026gt;\u0026gt; $*.d @rm -f $*.d.tmp 这将生成一个依赖文件，如下：\ndir/bar.o: dir/bar.c dir/foo.h dir/bar.c: dir/foo.h: ","permalink":"https://kingtuo123.com/posts/autodependencies-with-gnu-make/","summary":"make 自动生成依赖关系","title":"Autodependencies with GNU make"},{"content":"Note 之前学习 makefile 时发现不需要使用 gcc 的 -MMD 参数生成的依赖关系，程序也能编译通过。因为只要你的 makefile 中包含了头文件的路径，编译器在编译时会自动找到这个头文件。\n本以为可以省去生成依赖关系这一步，后来发现。\n如果你引用了隐式规则外的头文件，且头文件发生了改变，你再 make 是不会重新编译的，因为该头文件不在依赖中。\n很简单的问题，有时候还是脑子短路了。\n","permalink":"https://kingtuo123.com/posts/makefile-include-file/","summary":"Makefile 的规则中为何要包含头文件依赖","title":"Makefile 头文件依赖"},{"content":"挂载数据卷 指定路径挂载\n$ docker run -it -v \u0026lt;宿主机路径\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 具名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;卷名\u0026gt;/_data\n$ docker run -it -v \u0026lt;卷名\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 匿名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;一串随机字符\u0026gt;/_data\n$ docker run -it -v \u0026lt;容器内路径\u0026gt; nginx 查看数据卷 列出数据卷\n$ docker volume ls DRIVER VOLUME NAME local 0b60738f27c8adc38559981ad727d36a722b70b1736b20d8f3020ffc88d202b2 local 21f61aa404a0fe9c15a6a6ad4a6a056a0ee009a98af593c2092a14062fa7c02e local test # 上面两个是匿名挂载 # test是具名挂载 查看卷详情\n$ docker volume inspect \u0026lt;卷名\u0026gt; [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-01-24T17:08:58+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/test/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 读写权限 ro 只读，容器对该数据卷只读\n$ docker run -d -v /home/nginx:/etc/nginx:ro nginx rw 读写，容器对该数据卷可读写\n$ docker run -d -v /home/nginx:/etc/nginx:rw nginx 数据卷共享 $ docker run -it --name docker01 -v volume01 ubuntu bash $ docker run -it --name docker02 --volume-from docker01 ubuntu bash 上面的命令中 docker02 与 docker01 共享 volume01 ，用到参数 --volume-from 。\n我们来查看下两个容器数据卷的关系\n$ docker inspect docker01 docker02 | grep volume \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/505a478d050df91857b156119a9d83626614ffb3962d1ac3459d14756c5544dc/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume01\u0026#34;, \u0026#34;volume01\u0026#34;: {} \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/505a478d050df91857b156119a9d83626614ffb3962d1ac3459d14756c5544dc/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume01\u0026#34;, \u0026#34;volume01\u0026#34;: {} 可以看到两个容器匿名挂载的宿主机路径是一样的\n","permalink":"https://kingtuo123.com/posts/docker-volume/","summary":"挂载数据卷 指定路径挂载\n$ docker run -it -v \u0026lt;宿主机路径\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 具名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;卷名\u0026gt;/_data\n$ docker run -it -v \u0026lt;卷名\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 匿名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;一串随机字符\u0026gt;/_data\n$ docker run -it -v \u0026lt;容器内路径\u0026gt; nginx 查看数据卷 列出数据卷\n$ docker volume ls DRIVER VOLUME NAME local 0b60738f27c8adc38559981ad727d36a722b70b1736b20d8f3020ffc88d202b2 local 21f61aa404a0fe9c15a6a6ad4a6a056a0ee009a98af593c2092a14062fa7c02e local test # 上面两个是匿名挂载 # test是具名挂载 查看卷详情\n$ docker volume inspect \u0026lt;卷名\u0026gt; [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-01-24T17:08:58+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/test/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 读写权限 ro 只读，容器对该数据卷只读","title":"Docker volume"},{"content":"连接无线网 wpa_passphrase \u0026lt;wifi\u0026gt; \u0026lt;passwd\u0026gt; \u0026gt; /etc/wpa_supplicant/wpa_supplicant.conf wpa_supplicant -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -B dhcpd 可选：使用 SSH 连接 rc-service sshd start passwd root 这里注意记得修改 root 密码，因为不知道 livecd 的 root 密码。\n准备磁盘 分区 parted /dev/nvme0n1 # 创建 gpt 分区 (parted) mklabel gpt # 创建引导分区，注意这里从2048个扇区开始，对齐分区 (parted) mkpart EFI fat32 2048s 512MB # 创建根分区 (parted) mkpart root ext4 512MB 100% # 设置分区1 flag boot, esp (parted) set 1 # 打印分区信息 (parted) p Model: PM981 NVMe Samsung 512GB (nvme) Disk /dev/nvme0n1: 512GB Sector size (logical/physical): 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 512MB 511MB fat32 EFI boot, esp 2 512MB 512GB 512GB ext4 root 格式化分区 mkfs.fat -F 32 /dev/nvme0n1p1 mkfs.ext4 /dev/nvme0n1p2 挂载 root 分区 mount /dev/nvme0n1p2 /mnt/gentoo 安装 stage3 设置日期和时间 格式：月日时分年，如 060504032022 ，表示 2022 年 06 月 05 日 04 时 03 分。\ndate 060504032022 下载 stage3 这里使用 links 访问清华开源镜像站下载：\ncd /mnt/gentoo/ links https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64-desktop-openrc/ 解压 stage3 tar xpvf stage3-*.tar.xz --xattrs-include=\u0026#39;*.*\u0026#39; --numeric-owner 配置 make.conf vi /mnt/gentoo/etc/portage/make.conf 修改如下：\n# These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\u0026#34;-march=native -O3 -pipe\u0026#34; CFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; CXXFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; FCFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; FFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; # NOTE: This stage was built with the bindist Use flag enabled PORTDIR=\u0026#34;/var/db/repos/gentoo\u0026#34; DISTDIR=\u0026#34;/var/cache/distfiles\u0026#34; PKGDIR=\u0026#34;/var/cache/binpkgs\u0026#34; # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C # 核心数*2 MAKEOPTS=\u0026#34;-j8\u0026#34; # 清华源 GENTOO_MIRRORS=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/gentoo\u0026#34; # 阿里源 #GENTOO_MIRRORS=\u0026#34;https://mirrors.aliyun.com/gentoo/\u0026#34; USE=\u0026#34;-kde -systemd -gnome -wayland -bluetooth efi-64 pulseaudio dbus caps\u0026#34; VIDEO_CARDS=\u0026#34;i965 intel\u0026#34; INPUT_DEVICES=\u0026#34;libinput synaptics\u0026#34; GRUB_PLATFORMS=\u0026#34;efi-64\u0026#34; ACCEPT_LICENSE=\u0026#34;*\u0026#34; 安装基本系统 拷贝 DNS 信息 cp --dereference /etc/resolv.conf /mnt/gentoo/etc/ 挂载文件系统 mount --types proc /proc /mnt/gentoo/proc mount --rbind /sys /mnt/gentoo/sys mount --make-rslave /mnt/gentoo/sys mount --rbind /dev /mnt/gentoo/dev mount --make-rslave /mnt/gentoo/dev mount --bind /run /mnt/gentoo/run mount --make-slave /mnt/gentoo/run 进入新环境 chroot /mnt/gentoo /bin/bash source /etc/profile export PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 挂载 EFI 分区 mkdir -p /boot/EFI mount /dev/nvme0n1p1 /boot/EFI/ 配置 Portage 更新 ebuild 仓库 emerge-webrsync 选择配置文件 eselect profile list 输出如下：\nAvailable profile symlink targets: [1] default/linux/amd64/17.1 (stable) [2] default/linux/amd64/17.1/selinux (stable) [3] default/linux/amd64/17.1/hardened (stable) [4] default/linux/amd64/17.1/hardened/selinux (stable) [5] default/linux/amd64/17.1/desktop (stable) * [6] default/linux/amd64/17.1/desktop/gnome (stable) [7] default/linux/amd64/17.1/desktop/gnome/systemd (stable) ... eselect profile set 5 更新 world emerge --ask --verbose --update --deep --newuse @world 预安装一些软件 emerge -av vim \\ wpa_supplicant \\ net-misc/dhcp \\ app-text/tree \\ mlocate \\ linux-firmware \\ gentoolkit \\ net-wireless/iw \\ pciutils 时区设置 echo \u0026#34;Asia/Shanghai\u0026#34; \u0026gt; /etc/timezone emerge --config sys-libs/timezone-data 配置语言环境 编辑 /etc/locale.gen 添加如下：\nen_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_CN.GBK GBK 然后执行\nlocale-gen 语言选择：\neselect locale list Available targets for the LANG variable: [1] C [2] C.utf8 [3] POSIX [4] en_US.utf8 [5] zh_CN.gbk [6] zh_CN.utf8 [7] C.UTF8 * [ ] (free form) 设置 en_US.utf8 ：\neselect locale set 4 env-update \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026amp; export PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 配置内核 下载固件和CPU微代码 emerge --ask sys-kernel/linux-firmware sys-firmware/intel-microcode 下载内核源码 emerge --ask sys-kernel/gentoo-sources 选择内核版本 eselect kernel list Available kernel symlink targets: [1] linux-5.15.41-gentoo eselect kernel set 1 配置内核 cd /usr/src/linux make menuconfig 内核参数配置因人、机器而异，这里不详述。\n编译安装 make -j8 make install make modules_install 可选：构建 initramfs emerge --ask sys-kernel/dracut dracut --kver=5.15.41-gentoo 系统配置 配置 /etc/fstab /dev/nvme0n1p1\t/boot\tvfat\tdefaults,noatime\t0 2 /dev/nvme0n1p2\t/\text4\tnoatime\t0 1 主机和域信息 编辑 /etc/conf.d/hostname：\n# Hostname fallback if /etc/hostname does not exist hostname=\u0026#34;gentoo\u0026#34; (chroot) livecd # vim /etc/conf.d/net dns_domain_lo=\u0026#34;localhost\u0026#34; (chroot) livecd # vim /etc/host 127.0.0.1 gentoo.localhost gentoo localhost (chroot) livecd ~ # vim /etc/rc.conf rc_parallel=\u0026#34;YES\u0026#34; (chroot) livecd ~ # vim /etc/conf.d/hwclock clock=\u0026#34;local\u0026#34; 安装系统工具 日志系统 (chroot) livecd ~ # emerge --ask app-admin/sysklogd (chroot) livecd ~ # rc-update add sysklogd default 时钟同步 (chroot) livecd ~ # emerge --ask net-misc/chrony (chroot) livecd ~ # rc-update add chronyd default 配置引导加载程序 (chroot) livecd ~ # emerge --ask sys-boot/grub (chroot) livecd ~ # grub-install --target=x86_64-efi --efi-directory=/boot/EFI --removable grub 内核启动参数 编辑 vim /etc/default/grub ，添加下面一行\n# Append parameters to the linux kernel command line GRUB_CMDLINE_LINUX=\u0026#34;root=/dev/nvme0n1p2\u0026#34; 生成 grub 配置文件：\ngrub-mkconfig -o /boot/grub/grub.cfg 收尾工作 添加用户 useradd -m -G users,wheel,audio,usb -s /bin/bash king 修改用户和 root 密码\npasswd king passwd root 默认密码强度需要数字大小写字母，你可以修改 /etc/security/passwdqc.conf 配置。\nwpa (chroot) livecd ~ # vim /etc/wpa_supplicant/wpa_supplicant.conf update_config=1 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel\n(chroot) livecd ~ # vim /etc/local.d/boot.start wpa_supplicant -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -B \u0026amp;\u0026amp; dhclient wlp2s0 \u0026amp;\n(chroot) livecd ~ # chmod +x /etc/local.d/boot.start\n(chroot) livecd ~ # rc-update add local default (chroot) livecd ~ # rc-update del netmount default\nnetwork service \u0026rsquo;netmount\u0026rsquo; needs non existent \u0026rsquo;net'\nln -s /etc/init.d/net.lo /etc/init.d/net.wlp2s0\nhidpi tty\u0026amp;grub font gentoo ~ # emerge -av terminus-font\ngentoo ~ # vim /etc/conf.d/consolefont consolefont=\u0026ldquo;ter-d32n\u0026rdquo;\ngentoo ~ # rc-update add consolefont default\ngrub-mkfont -s 32 -o /boot/grub/fonts/terminus32b.pf2 /usr/share/fonts/terminus/ter-u32b.otb\ngentoo ~ # vim /etc/default/grub GRUB_FONT=\u0026quot;/boot/grub/fonts/terminus32b.pf2\u0026quot;\nsome app app-admin/sudo\napp-portage/pfl\nxorg emerge \u0026ndash;ask x11-base/xorg-server emerge \u0026ndash;ask x11-base/xorg-x11 pulseaudio\n未完待续\n","permalink":"https://kingtuo123.com/posts/gentoo-installation/","summary":"连接无线网 wpa_passphrase \u0026lt;wifi\u0026gt; \u0026lt;passwd\u0026gt; \u0026gt; /etc/wpa_supplicant/wpa_supplicant.conf wpa_supplicant -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -B dhcpd 可选：使用 SSH 连接 rc-service sshd start passwd root 这里注意记得修改 root 密码，因为不知道 livecd 的 root 密码。\n准备磁盘 分区 parted /dev/nvme0n1 # 创建 gpt 分区 (parted) mklabel gpt # 创建引导分区，注意这里从2048个扇区开始，对齐分区 (parted) mkpart EFI fat32 2048s 512MB # 创建根分区 (parted) mkpart root ext4 512MB 100% # 设置分区1 flag boot, esp (parted) set 1 # 打印分区信息 (parted) p Model: PM981 NVMe Samsung 512GB (nvme) Disk /dev/nvme0n1: 512GB Sector size (logical/physical): 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 512MB 511MB fat32 EFI boot, esp 2 512MB 512GB 512GB ext4 root 格式化分区 mkfs.","title":"Gentoo 安装配置"},{"content":"安装 $ emerge -av xf86-input-mtrack 配置 添加文件 /etc/X11/xorg.conf.d/40-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;libinput touchpad catchall\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;True\u0026#34; Option \u0026#34;TappingDrag\u0026#34; \u0026#34;True\u0026#34; Option \u0026#34;NaturalScrolling\u0026#34; \u0026#34;False\u0026#34; Option \u0026#34;ScrollUpButton\u0026#34; \u0026#34;5\u0026#34; Option \u0026#34;ScrollDownButton\u0026#34; \u0026#34;4\u0026#34; Driver \u0026#34;mtrack\u0026#34; Option \u0026#34;TransformationMatrix\u0026#34; \u0026#34;0.4 0 0 0 0.4 0 0 0 1\u0026#34; EndSection 各项参数参考这里\n启用/禁用触摸板 获取设备 id\n# 这里id是14 $ xinput list | grep -i touchpad ⎜ ↳ SynPS/2 Synaptics TouchPad id=14 [slave pointer (2)] 查看设备属性\n$ xinput list-props 14 Device \u0026#39;SynPS/2 Synaptics TouchPad\u0026#39;: # 这里可以用 Device Enabled (186) 来启用或禁用触摸板 Device Enabled (186): 0 Device Accel Profile (318): 0 Device Accel Constant Deceleration (319): 1.000000 Device Accel Adaptive Deceleration (320): 1.000000 Device Accel Velocity Scaling (321): 10.000000 Trackpad Disable Input (356): 0 Trackpad Sensitivity (357): 1.000000 Trackpad Touch Pressure (358): 5, 5 Trackpad Button Settings (359): 1, 1 Trackpad Button Emulation Settings (360): 0, 1, 100 ...... 启用触摸板\n$ input set-prop 14 \u0026#34;Device Enabled\u0026#34; 1 # 或者使用属性id $ xinput set-prop 14 186 1 禁用触摸板\n$ input set-prop 14 \u0026#34;Device Enabled\u0026#34; 0 $ xinput set-prop 14 186 0 其他参数参照上面方法修改\n","permalink":"https://kingtuo123.com/posts/linux-touchpad-driver/","summary":"Gentoo touchpad driver installation and configure","title":"Gentoo touchpad 驱动"},{"content":" 参考文档1 参考文档2 问题描述:\n使用xf86-video-intel驱动和启用硬件加速会导致画面概率性冻结 使用modesetting驱动会导致画面撕裂 解决方法 不使用xf86-video-intel驱动。\n使用picom渲染器解决modesetting驱动下画面撕裂的问题\n修改 /etc/X11/xorg.conf.d/20-intel.conf\nSection \u0026#34;Device\u0026#34; Identifier \u0026#34;modesetting\u0026#34; Driver \u0026#34;modesetting\u0026#34; EndSection 在配置文件 $HOME/.config/picom/picom.conf 中添加\nvsync = true; 在 $HOME/.xinitrc 中添加\npicom --experimental-backend\u0026amp; 目前使用一切正常。\n","permalink":"https://kingtuo123.com/posts/linux-intel-graphics-tearing-issue/","summary":"intel驱动导致的画面撕裂和冻结","title":"Linux下intel核显驱动问题"},{"content":" 本文翻译自 Writing linker script for STM32 from scratch 水平有限仅供参考\n本文将解释三件事：\n如何从零编写一个简单的链接器脚本 在stm32上实现应用（本文是STM32F103RBT6） 如何避免使用厂商提供的头文件，代码等 这个话题对我来说也是刚接触到的。因为我之前一直都在使用厂商提供的脚本，直到昨天我决定自己实现这个脚本。有部分原因是我想锻炼我的脑子，但主要还是为了学习新的知识。本文将一步步引导你从创建最简单、甚至简陋的链接器脚本开始，直至一个成熟且完善的脚本。\n我决心要研究单片机的链接器脚本是因为这能让你对底层有更深入的理解，使你有能力在单片机上完成更多的操作。你需要了解内存地址、在内存的哪个地方又要放入什么数据。不过别担心，下面我会一一解释。\n准备工具 你只需要两件事即可开始：ARM 工具链和你最喜欢的文本编辑器。最新的 ARM 工具链可以直接从 ARM 官网下载。\n如果你很幸运并且在 Mac 或 Linux 上工作，你可以简单地将工具链提解压到任何地方并将其添加到 shell 的路径中：\n$ export PATH=/your/toolchain/bin:$PATH 现在你应该能够执行工具链的所有工具，前缀为：arm-none-eabi-\n预备知识 在开始之前，我们还需要了解一些知识：目标设备的内存布局。如果你不知道将代码、变量放到哪里，就无发编写链接脚本。不同的架构、设备之间的内存布局是不同的，因此你必须查看数据手册找到相应的信息。以STM32F103RBT6为例，可以在参考手册的第 53 页（SRAM）和第 54 页（Flash）中找到：\nSRAM 起始地址是 0x2000 0000 Flash 起始地址是 0x0800 0000 这意味着你需要将代码放到地址 0x0800 0000 处，所有的变量要放到 0x2000 0000 处。别担心，后面我会解释。\n差点忘了，你还需要了解 MCU 是如何启动的。大多数情况下，在芯片启动时需要设置堆栈指针，不同架构的平台方法也不同。步骤很简单：找到存储堆栈地址的位置，将该地址设置为栈顶地址。逻辑上来说，栈空间是从上往下增长的，所以它需要足够的空间（指定大小）。\n如果你看下手册第61页，上面有STM32 如何启动以及它如何设置堆栈指针的详细描述：\n上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从 0x0000 0004 开始的引导存储器开始执行代码。\n记下重点：\nStack initializer：0x0000 0000 Entry point：0x0000 0004 关于 STM32 你还需了解重要的一点是：这在文档61页也有说明，当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的引导模式。这称为“内存映射”。默认情况下，STM32 从 flash 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址或 0x00000000 访问 flash。这允许 CPU 直接从 flash 开始读取指令。\n记住以上信息，并且知道我们想从 flash 启动，我们已经可以为堆栈初始化程序和入口点计算适当的地址：\nStack initializer：0x0800 0000 Entry point：0x0800 0004 其实上面的文档有一点误导。Entry point 并不是程序真正开始执行的地方。实际上，这里存储着起始代码的所在地址，从这个地址跳到代码所在位置开始执行。换句话说，0x00000000 中的值会被加载到 SP 寄存器，0x00000004 中的值会被加载到 PC 寄存器。\n开始编写 最简单的链接脚本 链接描述文件可以由一个称为 SECTIONS 的块组成。在此块中，你定义的段将被分配到二进制文件中。最重要的段是：\n.test - 包含你的代码 .data - 包含已初始化的全局/静态变量 .bss - 包含未初始化的全局/静态变量 我们的第一个脚本，将只使用 .text 。没有数据，没有变量，只有纯代码。我们创建一个 script.ld 文件，写入下面的内容：\nSECTIONS { .text : { *(.text) } } 上面的脚本告诉链接器：\n创建一个 .text 段（表达式最左边的部分） 获取目标文件中所有的 .text 段（花括号中的表达式） 把第2步或取的段放到第1步创建的段中 这很简单，不是吗？但是我们缺少一些东西，甚至是一些东西。我们定义了代码部分，但我们没有指定它应该放在哪里。在当前的脚本中，代码将被放置在地址 0x0，但根据我们之前讲述的内容，它应该被加载到地址 0x08000000，对吧？没错，让我们来解决这个问题：\nSECTIONS { . = 0x08000000; .text : { *(.text) } } 链接脚本中的 . 是位置计数器。它从 0x0 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 text 段之后读取位置计数器的值，它的值将是 0x08000000 加上你添加的段的大小。如果你不以其他方法指定段的地址（其他方法在后面会讲到），那么该段的地址将会从当前位置计数器的地址开始。\n好了，我们代码有了一个正确的位置。接下来只要知道入口程序地址以及堆栈地址：\nENTRY(main); SECTIONS { . = 0x08000000; LONG(0x20005000); LONG(main | 1); .text : { *(.text) } } 我想我欠你一个解释。\n如果你还记得，当 STM32 启动时，它会从 flash 读取两个双字。第一个是栈顶地址，第二个是入口程序地址。LONG(0x20005000) 告诉链接器将这四个字节放入输出的二进制文件中。为什么是这四个字节？因为STM32 SRAM 地址从 0x20000000 开始，大小有 20kb（0x5000）。 0x20000000 + 0x5000 = 0x20005000 就是栈顶的地址。\n第二条表达式 LONG(main | 1); 将 main 函数的地址输出到二进制文件中。如你所见，main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 切换到 thumb 模式，而不是表示 ARM 模式的偶数地址。\nNot all branch instructions causes mode switch. B or BL only branches; BX branches with mode switch accordingly to the last bit of an address; BLX branches and always switches the mode. You can read more on the dedicated page.\nSTM32F103RBT6 基于仅支持 Thumb 指令的 Cortex-M3，这就是我们在开始时告诉它切换到 Thumb 模式的原因。这通常对开发人员是透明的，编译器要么使用 BL 指令保持当前模式，要么自动修复调用地址。我们在这里手动执行此操作的原因是因为我们创建了链接脚本。\n我还添加了另一个新东西：ENTRY(main)。这告诉链接器应该使用哪个符号作为程序的入口点。这也可以防止包含 main 函数的 .text 部分被链接器作为垃圾收集。\n好了，我们有一个链接器脚本，这很好，但我们还需要有一些东西可以链接。让我们创建一个简单的代码来点亮 Nucleo 板上的绿色 LED：\n#include \u0026#34;registers.h\u0026#34; void main(void) { RCC-\u0026gt;APB2ENR |= (1 \u0026lt;\u0026lt; RCC_APB2ENR_IOPAEN); GPIOA-\u0026gt;CRL |= (0b10 \u0026lt;\u0026lt; GPIOA_CRL_MODE5); GPIOA-\u0026gt;CRL \u0026amp;= ~(0b11 \u0026lt;\u0026lt; GPIOA_CRL_CNF5); GPIOA-\u0026gt;BSRR = (1 \u0026lt;\u0026lt; 5); while (1); } registers.h 文件是一个包含寄存器地址的头文件。我是根据参考手册中的信息创建的。我只是为每组寄存器定义了一个结构体，然后使用基地址定义了一个指向该结构的指针。多亏了结构体，我不需要手动执行指针运算，因为它是在访问结构体的字段时自动完成的：\n#ifndef LINKER_TUTORIAL_REGISTERS_H #define LINKER_TUTORIAL_REGISTERS_H #include \u0026lt;stdint.h\u0026gt; typedef struct { uint32_t CR; uint32_t CFGR; uint32_t CIR; uint32_t APB2RSTR; uint32_t APB1RSTR; uint32_t AHBENR; uint32_t APB2ENR; uint32_t APB1ENR; uint32_t BDCR; uint32_t CSR; } RCC_Reg; #define RCC ((RCC_Reg*) 0x40021000) #define RCC_APB2ENR_IOPAEN 2 typedef struct { uint32_t CRL; uint32_t CRH; uint32_t IDR; uint32_t ODR; uint32_t BSRR; uint32_t BRR; uint32_t LCKR; } GPIOA_Reg; #define GPIOA ((GPIOA_Reg*) 0x40010800) #define GPIOA_CRL_MODE5 20 #define GPIOA_CRL_CNF5 22 #endif //LINKER_TUTORIAL_REGISTERS_H 就这样！由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余。让我们编译并链接它：\n$ arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -Tscript.ld -Wl,--gc-sections -Os main.c 为了编译和链接，我将 CPU 类型设置为 Cortex-M3，指令设置为 Thumb，我选择了链接器脚本，告诉链接器删除未使用的部分并设置代码大小优化。如果一切顺利，固件文件将创建为 a.out。此文件为 ELF 格式，不能直接用于 MCU，你需要将其转换为 Intel HEX。这可以使用以下命令轻松完成：\n$ arm-none-eabi-objcopy -O ihex a.out fw.hex 查看 fw.hex 文件的前两行：\n: 02 0000 04 0800 F2 : 08 0000 00 0050002011000008 71 第一个是 04 记录（扩展线性地址），这意味着它为接下来的 00 记录设置起始地址。如你所见，地址是 0800，看起来很眼熟吧？如果将其扩展到 32 位（这就是扩展线性地址的工作方式），你将得到：0x08000000。这是我们的 flash 地址！\n下一条记录的类型是 00，表示数据。这正是将加载到 flash 的内容。该行指示程序员在先前设置的地址 + 0x0000 偏移处闪存 8 个字节。让我们将数据从小端转换为大端：20005000 08000011。第一个是初始堆栈指针，第二个可能是 main 函数的地址！让我们再执行一个命令：\n$ arm-none-eabi-objdump -D a.out 如果将输出滚动到顶部，你应该会看到如下内容：\n08000010 \u0026lt;main\u0026gt;: 8000010: 4a07 ldr r2, [pc, #28] ; (8000030 \u0026lt;main+0x20\u0026gt;) main 函数的实际地址在 0x08000010 处，记得我们之前对它进行或运算吗，main 函数的实际地址并未改变，只是调用方式不同。\n代码成功编译，堆栈指针和入口点地址位于有效位置，一切看起来都很有希望。烧录到开发板上！它在我的板上工作得很好，绿色 LED 按预期亮起。\n注意事项：\n我们编写的脚本虽然能正常工作，但我们无法修改全局或静态变量。因为我们没有在脚本中定义 .data 段，链接器会把这些全局/静态变量都放到 .text 段后面。因此它们是可读不可写的。\nDisassembly of section .data: 08000058 \u0026lt;a\u0026gt;: 8000058:\tdeadbeef cdple\t14, 10, cr11, cr13, cr15, {7} 我另外添加了一个全局变量：int a = 0xDEADBEEF，然后使用我们的脚本编译/链接。如你所见，该变量确实存在于 flash 中。局部变量不会受到影响，它们被放置在堆栈上，因此只要你不使用全局或静态变量，此链接器脚本就可以为你工作。如果你需要更复杂的东西，请继续阅读。\nMEMORY 在前面的示例中，我们使用的位置计数器来设置 .text 段的起始地址。对于简单的脚本来说，这就足够了，但是随着我们添加更多的内存区域，它会变得一团糟。仅使用位置计数器我们将自己限制在非常基本的配置上，我们很快就会碰壁。\n在链接脚本中，我们可以定义一个且只有一个名为 MEMORY 的块。在这个块中，我们列出了我们常用的内存区域。我们在那里定义的区域不需要准确地反映 MCU 的内存布局，但是它们之间存在很强的相关性。 MEMORY 块仅用于链接器，它不会以任何方式影响目标设备。\n那么，我们应该在这个块中定义哪些区域？这很明显：flash 和 SRAM：\nMEMORY { flash (RX) : ORIGIN = 0x08000000, LENGTH = 128K sram (RW) : ORIGIN = 0x20000000, LENGTH = 20K } ENTRY(main); SECTIONS { . = 0x08000000; LONG(0x20005000); LONG(main | 1); .text : { *(.text) } } MEMORY 语法：\nflash 表示该区域的名称 (RX) 表示读/写/执行属性 ORIGIN 表示该区域起始地址 LENGTH 表示该区域大小 现在是时候稍微重新组织一下脚本了：\nMEMORY { flash (RX) : ORIGIN = 0x08000000, LENGTH = 128K sram (RW) : ORIGIN = 0x20000000, LENGTH = 20K } ENTRY(main); SECTIONS { .text : { LONG(0x20005000); LONG(main | 1); *(.text) } \u0026gt; flash } 上面做了一些改动：\n删除了位置计数器 把堆栈指针和入口点移动到 .text 段 告诉链接器把这段放到 flash 中去： \u0026gt; flash 我们还需要对 SRAM 存储器做一些事情。当我们创建脚本时，变量被放置在 flash 中，因为链接器不知道其他内存区域的存在。现在，我们终于可以放置变量了：\nMEMORY { flash (RX) : ORIGIN = 0x08000000, LENGTH = 128K sram (RW) : ORIGIN = 0x20000000, LENGTH = 20K } ENTRY(main); SECTIONS { .text : { LONG(0x20005000); LONG(main | 1); *(.text) } \u0026gt; flash .data : { *(.data) } \u0026gt; sram } 如上，我们简单地定义了一个新的段：.data，它将包括所有目标文件中的所有 .data 节，并将被放置在 SRAM 内存中。为了查看链接器现在将把全局变量放在哪里，我添加了一个：int a = 0xDEADBEEF。让我们 dump 看看:\nDisassembly of section .data: 20000000 \u0026lt;a\u0026gt;: 20000000:\tdeadbeef cdple\t14, 10, cr11, cr13, cr15, {7} 这看起来不错！这一次，全局变量被放置在 SRAM 内存中，它既可以被读取也可以被写入。我们也来看看 Intel HEX 文件的最后几行（在做 objcopy 之后）：\n:02 0000 04 2000 DA :04 0000 00 EFBEADDE C4 第一条记录告诉编程器将编程地址设置为 0x20000000，下一行告诉它在那里写入 0xDEADBEEF。看起来不错？嗯……不。你在这里尝试做的是将数据写入到 SRAM，这是不可能的。即使它可行，所有数据都会在第一次断电后消失。\n结束，未完\n","permalink":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/","summary":"从零开始编写stm32链接脚本","title":"Writing linker script for STM32 from scratch"},{"content":" 翻译自 Demystifying Firmware Linker Scripts，水平有限仅供参考。\n上一篇文章 ，我们谈到了在调用我们的主函数之前，在 MCU 上引导 C 环境。我们认为理所当然的一件事是函数和数据都被存储在二进制文件中的正确位置。今天，我们将通过学习内存区域和链接器脚本来深入了解这是如何发生的。\n你可能还记得以下自动发生的事情：\n我们使用了 \u0026amp;_ebss 、\u0026amp;_sdata 等变量，知道了每个部分在 flash 中的位置，并定义一些变量在 RAM 中的位置。 MCU 在地址 0x00000004 找到了指向我们的 ResetHandler 的指针地址。 你会发现一些 MCU 有不同的内存映射，一些启动脚本以不同的方式命名这些变量，而一些程序有或多或少的段。 由于它们不是标准化的，因此需要在我们工程的某个地方指定这些内容。在工程使用类似 Unix-ld 工具链接的情况下，我们就需要链接器脚本。\n链接简介 链接是编译程序的最后一个阶段。它需要许多已编译的目标文件并将它们合并到一个程序中，并填写地址，以便一切都在正确的位置。\n下面的例子中，让我们来看看 main 函数发生了什么，先用编译器生成目标文件：\n$ arm-none-eabi-gcc -c -o build/objs/a/b/c/minimal.o minimal.c \u0026lt;CFLAGS\u0026gt; 把符号 dump 出来：\n$ arm-none-eabi-nm build/objs/a/b/c/minimal.o ... 00000000 T main ... 正如预期的那样，它还没有地址。然后，我们将链接所有内容：\n$ arm-none-eabi-gcc \u0026lt;LDFLAGS\u0026gt; build/objs/a/b/c/minimal.o \u0026lt;other object files\u0026gt; -o build/minimal.elf 我们再把 elf 文件的符号 dump 出来：\n$ arm-none-eabi-nm build/minimal.elf ... 00000294 T main ... 链接器已经完成了它的工作，我们的主函数已经被分配了一个地址。\n链接器的作用通常不止于此。例如，它可以生成调试信息、垃圾收集未使用的代码部分或运行整个程序优化（也称为链接时间优化或 LTO）。 有关链接器的更多信息，请参阅 Stack Overflow 上的一个很棒的帖子。\n链接器脚本解析 链接描述文件包含四个内容：\nMemory layout：什么内存在哪里可用 Section definitions：程序的哪个部分应该放在哪里 Options：用于指定架构、入口点等的命令。如果需要的话 Symbols：在链接时注入程序的变量 Memory Layout 为了分配程序空间，链接器需要知道有多少内存可用，以及该内存所在的地址。这就是链接描述文件中的 MEMORY 定义的用途。\nMEMORY 的语法在 binutils 文档中定义，如下所示：\nMEMORY { name [(attr)] : ORIGIN = origin, LENGTH = len ... } name 是用于这个区域的名称，名称没有意义，可任意命名。 attr 是可选属性，例如这个区域是可读（r），可写（w），可执行（x）。flash 一般是（rx），ram 是（rwx）。将区域标记为不可写并不会使其写保护，这些属性旨在描述内存的属性，而不是设置它。 origin 是内存区域的起始地址。 len 是内存区域的大小，以字节为单位。 SAMD21G18 芯片的内存映射表如下：\n内存 起始地址 大小 内部 Flash 0x00000000 256 Kbytes 内部 SRAM 0x20000000 32 Kbytes 写成 MEMORY 定义，如下：\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } Section Definitions code 和 data 都被打包进 sections，它在内存中是一块连续的地址。没有硬性规定应该有多少 sections 或存放哪些 symbols。以下两种情况通常会把 symbols 放到同一 section 中：\n它们应该在同一个内存区域 它们需要一起初始化 在上一篇文章中，我们了解了两种批量初始化的符号：\n必须从 flash 复制的初始化静态变量 必须归零的未初始化静态变量 我们的链接器脚本涉及到的另外两样东西：\n代码和常量数据，可以存在于只读存储器（例如flash） RAM 的保留部分，如栈或堆 按照惯例，我们将这些部分命名如下：\n.text 代码和常量 .bss 未初始化的数据 .stack 栈 .data 已初始化的数据 elf spec 有完整的变量列表。你可以给它们起别的名字，即使固件能正常运行但不能保证某些工具在使用到这个固件时不会出现奇怪的错误。唯一不能用作命名的是 /DISCARD/ ，这是一个保留的关键字。\n首先，让我们看看如果我们不在链接描述文件中定义任何这些部分，我们的符号会发生什么。\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } SECTIONS { /* empty! */ } 使用 objdump 查看生成的 elf 文件，我们看到以下内容：\n$ arm-none-eabi-objdump -h build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: no symbols 没有符号！虽然链接器能在几乎没有信息的情况下链接，但它至少需要知道入口点应该是什么，或者在 text section 中放置什么符号。\n.text Section 让我们从添加 .text section 开始。我们想让这个 section 在 ROM 中。下面是语法：\nSECTIONS { .text : { } \u0026gt; rom } 上面定义了一个名为 .text 的 section，并将其添加到 ROM。然后我们需要告诉连链接器需要在 section 中添加什么。\n为了找出我们目标文件中有哪些 section。我们再 objdump 一次：\n$ arm-none-eabi-objdump -h build/objs/a/b/c/minimal.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000000 00000000 00000000 00000034 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000000 00000000 00000000 00000034 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000034 2**0 ALLOC 3 .bss.cpu_irq_critical_section_counter 00000004 00000000 00000000 00000034 2**2 ALLOC 4 .bss.cpu_irq_prev_interrupt_state 00000001 00000000 00000000 00000034 2**0 ALLOC 5 .text.system_pinmux_get_group_from_gpio_pin 0000005c 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 6 .text.port_get_group_from_gpio_pin 00000020 00000000 00000000 00000090 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 7 .text.port_get_config_defaults 00000022 00000000 00000000 000000b0 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 8 .text.port_pin_set_output_level 0000004e 00000000 00000000 000000d2 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 9 .text.port_pin_toggle_output_level 00000038 00000000 00000000 00000120 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.set_output 00000040 00000000 00000000 00000158 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.main 0000002c 00000000 00000000 00000198 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 我们看到每一个符号都有一个 section。这是因为我们在编译时指定了 -ffucntion-sections 和 -fdata-sections 标志。如果我们没有包含这些标志，编译器可以将多个函数包含进一个 section 中去。\n在我们的链接器脚本中要将所有函数都放到 .text 中，我们可以按以下语法：\n\u0026lt;filename\u0026gt;(\u0026lt;section\u0026gt;) filename 是包含我们所需符号的输入文件的名称，section 就是该文件中包含的 section 的名称。如果我们想要取一个文件中所有的 .text section，我们可以使用 * 通配符：\n.text : { KEEP(*(.vector*)) *(.text*) } \u0026gt; rom 这里注意 .vector section，它是入口函数 Reset_Handler 所在的 section，我们需要把它放在最前面。\nKEEP( ) 函数告诉链接器不要把 .vector section 当作垃圾回收。因为 Reset_Handler 是入口函数，我们没有在程序的任何地方调用它，链接器会把没有被调用的函数当作垃圾处理以减少最后生成文件的体积。\n编译后，我们 dump 下 elf 文件，可以看到如下：\n$ arm-none-eabi-objdump -t build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: 00000000 l d .text 00000000 .text ... 00000000 l df *ABS* 00000000 minimal.c 00000000 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 0000005c l F .text 00000020 port_get_group_from_gpio_pin 0000007c l F .text 00000022 port_get_config_defaults 0000009e l F .text 0000004e port_pin_set_output_level 000000ec l F .text 00000038 port_pin_toggle_output_level 00000124 l F .text 00000040 set_output 00000000 l df *ABS* 00000000 port.c 00000190 l F .text 00000028 system_pinmux_get_config_defaults 00000000 l df *ABS* 00000000 pinmux.c 00000208 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 00000264 l F .text 00000110 _system_pinmux_config 00000164 g F .text 0000002c main 000001b8 g F .text 0000004e port_pin_set_config 00000374 g F .text 00000040 system_pinmux_pin_set_config ... .bss Section .bss 段存放的是未初始化的变量，如下：\nSECTION { ... .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u0026gt; ram } 注意 *(COMMON) ，这是一个特殊的段名，用来表示未初始化的全局变量。例如 int foo 就会在这个段中，static int foo 则不会。如果它们具有相同的名称，这允许链接器将多个定义合并到一个符号中。\n这里还使用了 NOLOAD 属性标记该段不可加载，这样当程序运行时它就不会被加载到内存中。\n在符号表中，未初始化的局部静态变量，初始化为0的全局变量及局部静态变量都wei会被表示在bss段。但是未初始化的全局变量会表示为COMMON，也相当于在bss段，但COMMON有特殊含义。未初始化的局部静态变量由于是仅编译单元内可见，不需要导出符号。所以不用置为COMMON，直接标识为bss段。\n.stack Section .stack 同样不用加载到内存中，由于堆栈不包含符号，我们需要显示的指示其大小为其保留空间。我们还必须按照 ARM 过程调用标准 AAPCS 在8字节边界上对齐堆栈。\n为了实现这些目标，我们使用一个特殊的变量 .，也称为“位置计数器”。位置计数器表示当前所在位置的地址。随着段的添加，位置计数器也会相应增加。你可以通过向前设置位置计数器来强制对齐或间隙。\nSTACK_SIZE = 0x2000; /* 8 kB */ SECTION { ... .stack (NOLOAD) : { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u0026gt; ram ... } .data Section .data 部分包含在启动时具有初始值的静态变量。您会记得我们之前的文章中，由于断电时 RAM 不会保持不变，因此需要从 flash 加载这些部分。在启动时，Reset_Handler 在调用 main 函数之前将数据从 flash 复制到 RAM。\n为了实现这一点，我们的链接脚本中的每个部分都有两个地址，加载地址 (LMA) 和虚拟地址 (VMA)。LMA 是在ROM 中的地址，VMA 是在 RAM 中的地址。我们生成的 bin 烧录文件，它的数据顺序就是我们在链接脚本中定义的这些 sections 的顺序，bin 文件烧录到 flash 中后的顺序也是一样的，当程序运行时，我们需要把数据从 flash 拷贝到栈中，栈所在的地址就是 VMA，flash 中的地址就是 LMA。\n使用 AT 指定加载地址：\n.data : { *(.data*); } \u0026gt; ram AT \u0026gt; rom /* \u0026#34;\u0026gt; ram\u0026#34; is the VMA, \u0026#34;\u0026gt; rom\u0026#34; is the LMA */ 还可以显式指定一个地址，如下：\n.data 0x2000 : AT(0x4000) { . = ALIGN(4); _sdata = .; *(.data*); . = ALIGN(4); _edata = .; } 通常情况下从 Flash 执行的程序，text 段 VMA 和 LMA 是一样的。data 段的VMA会放在 RAM 中，LMA 会放在 flash 中，所以 data 段的 VMA 和 LMA 通常不一样。\n完整的链接器脚本 MEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } STACK_SIZE = 0x2000; /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) } \u0026gt; rom /* .bss section which is used for uninitialized data */ .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u0026gt; ram .data : { *(.data*); } \u0026gt; ram AT \u0026gt;rom /* stack section */ .stack (NOLOAD): { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u0026gt; ram _end = . ; } 你可以在这里找到链接器脚本的详细语法 ld manual。\n变量 在上一篇文章中，我们依靠变量获取每个 section 的地址。\n为了能在程序中调用这些变量，链接器会生成符号并将他们添加进程序中。你可以在 linker documentation 找到相关的语法。类似C语言的变量定义：symbol = expression\n本例中，我们需要：\n_etext ： .text 段结束地址 _sdata ： .data 段起始地址 _edata ： .data 段结束地址 _sbss ： .bss 段起始地址 _ebss ： .bss 段结束地址 我们可以在每个 section 的开头和结尾使用位置计数器 . 定义变量：\n.text : { KEEP(*(.vectors .vectors.*)) *(.text.*) *(.rodata.*) _etext = .; } \u0026gt; rom .bss (NOLOAD) : { _sbss = . ; *(.bss .bss.*) *(COMMON) _ebss = . ; } \u0026gt; ram .data : { _sdata = .; *(.data*); _edata = .; } \u0026gt; ram AT \u0026gt;rom 在程序中必须使用对这些变量的引用，而不是变量本身。例如，以下代码为我们提供了一个指向 .data 段起始位置的指针：\nuint8_t *data_byte = \u0026amp;_sdata; 你可以在这里了解更多细节 binutils docs 。\n","permalink":"https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/","summary":"简述链接器做了哪些工作、链接器脚本的语法及如何编写","title":"Demystifying Firmware Linker Scripts"},{"content":" 翻译自 From Zero to main(): Bare metal C，水平有限仅供参考。\n嵌入式开发遵循下列原则：\n程序的入口点应命名为 “main”。 你应该初始化静态变量，否则机器会将它们设置为零。 你应该实现中断。其中主要有 HardFault_Handler，还有 SysTick_Handler。 准备平台 本文介绍的大多数概念和代码都适用于所有 Cortex-M 系列 MCU，但我们的示例针对的是 Atmel 的 SAMD21G18 处理器，这是一款 Cortex-M0+ 芯片。\n本文使用到以下工具：\nAdafruit’s Metro M0 Express 开发板 一个 CMSIS-DAP 仿真器 用于编程的 OpenOCD ( Arduino fork) 我们将实现一个简单的 LED 闪烁程序，下面是代码：\n#include \u0026lt;samd21g18a.h\u0026gt; #include \u0026lt;port.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define LED_0_PIN PIN_PA17 static void set_output(const uint8_t pin) { struct port_config config_port_pin; port_get_config_defaults(\u0026amp;config_port_pin); config_port_pin.direction = PORT_PIN_DIR_OUTPUT; port_pin_set_config(pin, \u0026amp;config_port_pin); port_pin_set_output_level(pin, false); } int main() { set_output(LED_0_PIN); while (true) { port_pin_toggle_output_level(LED_0_PIN); for (volatile int i = 0; i \u0026lt; 100000; ++i) {} } } 上电 我们是如何进入 main 的？从观察中我们可以看出我们给板子上电后程序开始执行。所以芯片肯定有一套固定的流程来定义代码的执行方式。\n确实有！深入研究 ARMv6-M 技术参考手册，这是 Cortex-M0+ 的底层架构手册，我们可以找到一些描述复位行为的伪代码：\n// B1.5.5 TakeReset() // ============ TakeReset() VTOR = Zeros(32); for i = 0 to 12 R[i] = bits(32) UNKNOWN; bits(32) vectortable = VTOR; CurrentMode = Mode_Thread; LR = bits(32) UNKNOWN; // Value must be initialised by software APSR = bits(32) UNKNOWN; // Flags UNPREDICTABLE from reset IPSR\u0026lt;5:0\u0026gt; = Zeros(6); // Exception number cleared at reset PRIMASK.PM = \u0026#39;0\u0026#39;; // Priority mask cleared at reset CONTROL.SPSEL = \u0026#39;0\u0026#39;; // Current stack is Main CONTROL.nPRIV = \u0026#39;0\u0026#39;; // Thread is privileged ResetSCSRegs(); // Catch-all function for System Control Space reset for i = 0 to 511 // All exceptions Inactive ExceptionActive[i] = \u0026#39;0\u0026#39;; ClearEventRegister(); // See WFE instruction for more information SP_main = MemA[vectortable,4] AND 0xFFFFFFFC\u0026lt;31:0\u0026gt;; SP_process = ((bits(30) UNKNOWN):\u0026#39;00\u0026#39;); start = MemA[vectortable+4,4]; // Load address of reset routine BLXWritePC(start); // Start execution of reset routine 简而言之，芯片做了以下工作：\n将向量表地址重置为 0x00000000 禁用所有中断 从 0x00000000 读取堆栈指针（SP）的地址 从 0x00000004 读取程序计数器（PC）的地址 谜团解开了，看来我们的 main 函数必须在地址 0x00000004 处。\nSP 指向栈顶，0x00000000 存的是栈顶的地址。\nPC 指向下一条指令的地址，0x00000004 存的是程序初始入口地址。\n我们把 bin 文件 dump 出来，看看在地址 0x0000000 和 0x00000004 有什么内容：\nfrancois-mba:zero-to-main francois$ xxd build/minimal/minimal.bin | head 00000000: 0020 0020 c100 0000 b500 0000 bb00 0000 . . ............ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 从上面来看，我们的初始堆栈地址是 0x20002000 ，程序初始入口地址是 0x000000c1\n我们再把符号表 dump 出来，看在地址 0x000000c1 上是什么：\nfrancois-mba:minimal francois$ arm-none-eabi-objdump -t build/minimal.elf | sort ... 000000b4 g F .text 00000006 NMI_Handler 000000ba g F .text 00000006 HardFault_Handler 000000c0 g F .text 00000088 Reset_Handler 00000148 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 000001a4 l F .text 00000020 port_get_group_from_gpio_pin 000001c4 l F .text 00000022 port_get_config_defaults 000001e6 l F .text 0000004e port_pin_set_output_level 00000234 l F .text 00000038 port_pin_toggle_output_level 0000026c l F .text 00000040 set_output 000002ac g F .text 0000002c main ... 这很奇怪，我们的 main 函数在地址 0x000002ac 处。并没有符号对应地址 0x000000c1 ，但是 0x000000c0 处有一个 Reset_Handler。\n其实，PC 的最低位用来表示 thumb2 指令，它是 ARM 处理器支持的两个指令集之一，所以 Reset_Handler 就是我们要找的入口函数。\n有些ARM处理器即能使用ARM指令，又能兼容Thumb指令，同一个应用程序中可能同时存在ARM指令和Thumb指令，这两者的处理方式肯定是大不相同的，所以为了切换ARM状态和Thumb状态，在跳转到Thumb指令编写的代码块的时候，将程序地址的最低位置1（因为不管是ARM指令还是Thumb指令，都至少是2字节对齐的，所以最低位一定是0，所以最低位可以拿来用于区分ARM状态和Thumb状态），这样处理器识别到最低位为1的话就会切换到Thumb状态，否则则是ARM状态。Thumb2指令集也是为了兼容以前的ARM状态和Thumb状态这样做的。\n编写一个 Reset_Handler 不幸的是，Reset_Handler 通常是一堆混乱的汇编代码，看这个例子 nRF52 SDK startup 。与其逐行浏览这个文件，不如看看我们是否可以根据第一原则编写一个最小的 Reset_Handler。\n在这里，ARM 的技术参考手册也很有用。 Cortex-M3 TRM 第 5.9.2 包含下面的表格:\n动作 描述 初始化变量 任何全局/静态变量都需要被设置。包括初始化 BSS 变量为0，以及将非常量变量的初始化值从 ROM 拷贝到 RAM。 设置堆栈 如果用了多个堆栈，那么这些堆栈的 SP 也要初始化。The current SP can also be changed to Process from Main。 初始化运行时 可以选择调用 C/C++ 运行时初始化代码以启用堆、浮点或其他功能。这通常由 C/C++ 库中的 __main 完成。 因此，我们的 ResetHandler 负责初始化静态和全局变量，并启动我们的程序。这反映了 C 标准告诉我们的内容：\n所有具有静态存储持续时间的对象都应在程序启动之前进行初始化（设置为其初始值）。这种初始化的方式和时间是未指定的。\n在实践中，这意味着给定以下代码段：\nstatic uint32_t foo; static uint32_t bar = 2; 我们的 Reset_Handler 需要确保 \u0026amp;foo 处的内存为 0x00000000，\u0026amp;bar 处的内存为 0x00000002。\n我们不能一个一个地初始化每个变量。相反，我们依靠编译器（技术上来讲，是链接器）将所有这些变量放在同一个地方，这样我们就可以一次初始化它们。\n对于必须归零的静态变量，链接器为我们提供 _sbss 和 _ebss 作为开始和结束地址。因此我们可以这样做：\n/* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } 对于具有初始值的静态变量，链接器为我们提供：\n_etext 作为存储初始值的地址（ROM） _sdata 作为静态变量所在的起始地址（RAM） _edata 作为静态变量所在的结束地址（RAM） 然后我们可以这样做：\nuint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } 把它们放在一起，可以编写我们的 Reset_Handler：\nvoid Reset_Handler(void) { /* Copy init values from text to data */ uint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } /* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } } 我们还需要启动我们的主程序！可以通过简单的调用 main() 来实现。\nvoid Reset_Handler(void) { /* Copy init values from text to data */ uint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } /* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } /* 译者注：这应该是这个芯片的Bug */ /* 覆盖 NVMCTRL.CTRLB.MANW 位的默认值（勘误参考 13134）*/ NVMCTRL-\u0026gt;CTRLB.bit.MANW = 1; /* 切换到主函数 */ main(); /* 死循环 */ while (1); } 你会注意到我们加了两样东西：\nmain() 后面有一个死循环，这样一来 main 函数返回的话就不会导致程序跑飞出现意料之外的情况。 处理芯片 bug 的最好方法是在我们的主程序启动之前解决它。有时这些方法被包含在一个 SystemInit 函数中，该函数在 main 之前由 Reset_Handler 调用。这是 Nordic 采用的方法。 结束 本文的所有代码都可以在这里找到 Github。\n更复杂的程序通常需要更复杂的 Reset_Handler。例如：\n可重定位代码必须要复制过来 如果我们的程序依赖于 libc，我们必须初始化它 更复杂的内存布局可以添加一些 拷贝/归零 的循环 我们将在以后的文章中介绍所有这些。但在此之前，我们将在下一篇文章中讨论神奇的内存区域变量是如何产生的，我们的 Reset_Handler 的地址为什么是 0x00000004 ，以及如何编写链接器脚本文件！\n","permalink":"https://kingtuo123.com/posts/bare-metal-c/","summary":"简述了裸机程序从上电开始，是如何进入主程序的","title":"Bare metal C"},{"content":"stm32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 厂家的 BootLoader 已提供了串口下载的功能，所以我们只要进入 BootLoader 即可。\n即在单片机启动时将BOOT0置高电平，BOOT1置低电平。\n一键下载电路 本文以野火霸道V2.0开发板为例\n要进入bootloader，有以下流程:\nBOOT1 跳线接 GND DTR 置高电平，RTS 置低电平 Q3 被导通，NRST 被拉低，单片机复位 Q5 被导通，BOOT0 被拉高 DTR 置低电平，释放复位 启动进入 BootLoader 这里注意CH340G 芯片，DTR 和 RTS 输出电平是反向的（芯片图DTR上方有一横线）。所以实际是， DTR 低电平复位，RTS 高电平进入BootLoader。\nWindows ISP 下载 如上图所示：DTR 低电平复位，RTS 高电平进入BootLoader。\nLinux ISP 下载 Linux 下使用 stm32flash 下载。下载解压后文件夹内有 stm32flash_linux 。\n该命令有以下参数\nUsage: stm32flash_linux [-bvngfhc] [-[rw] filename] [tty_device|i2c_device] -a bus_address # 总线地址 -b rate # 波特率 -m mode # 串口模式 -r filename # 读取flash到文件（或者使用 - 符号， 表示标准输出） -w filename # 写入文件到flash（或者使用 - 符号， 表示标准输出） -C # 计算flash crc校验码 -u # 禁用flash写保护 -j # 启用flash读保护 -k # 禁用flash读保护 -o # 仅擦除 -e n # 写入flash前仅擦除n页，默认全擦 -v # 写入后校验 -n count # 写入失败重试次数，默认10 -g address # 指定程序开始执行的地址 -S address[:length] # 指定读取/写入的起始地址和长度（可选） -F RX_length[:TX_length] # 指定接收/发送帧的最大长度 -s start_page # 在指定的页面写入 -f # 强制二进制解析 -h # 显示帮助信息 -c # 恢复连接 -R # 退出时复位设备 -i GPIO_string # 设置进入/退出BootLoader时信号输出的顺序 # GPIO_string=[entry_seq][:[exit_seq]] # sequence=[[-]signal]\u0026amp;|,[sequence] GPIO sequence: # 使用‘dtr’，‘rts’，‘brk’表示串口输出信号 # ‘,’表示在在两个信号之间加100ms延时 # ‘\u0026amp;’表示两个信号之间不加延时 # 在信号前加‘-’表示低电平，不加表示高电平 读取芯片信息，执行以下命令（root）：\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; /dev/ttyUSB0 参数说明：\n-b 115200 ，指定115200波特率 -dtr\u0026amp;rts,dtr -dtr\u0026amp; 拉低复位 rts, 拉高 BOOT0，延时100ms dtr 释放复位，进入 BootLoader -dtr\u0026amp;-rts,dtr -dtr\u0026amp; 拉低复位 -rts, 拉低 BOOT0，延时100ms dtr 释放复位，flash启动进入用户程序 /dev/ttyUSB0，设备串口 上述命令执行成功输出以下信息：\nInterface serial_posix: 115200 8E1 GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 1... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end Version : 0x22 Option 1 : 0x00 Option 2 : 0x00 Devive ID : 0x0414 (STM32F10XX High-density) - RAM : Up to 64KiB (512b reserved by bootloader) - Flash : Up to 512Kib (size first sector: 2x2048) - Option RAM : 16b - System RAm : 2KiB GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 0... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end 下载程序，执行以下命令\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; -v -w test.bin /dev/ttyUSB0 ","permalink":"https://kingtuo123.com/posts/stm32-isp-flash/","summary":"ISP 一键下载原理，windows 和 linux 平台 ISP 下载方法","title":"STM32 ISP 一键下载"},{"content":" 翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\nMakefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command targets 是文件名，以空格分隔。通常一个规则只有一个目标。\ncommand 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\nprerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\nmake 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的C程序。 blah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c # 第一个运行 下面这个 makefile 有一个目标 some_file 。默认目标是第一个目标，所以将执行 some_file 下的 echo 命令。\nsome_file: echo \u0026#34;This line will always print\u0026#34; 下面这个 makefile 第一次运行会生成 some_file 。第二次运行由于 some_file 已存在，会提示 make: 'some_file' is up to date 。\nsome_file: echo \u0026#34;This line will only print once\u0026#34; touch some_file 下面这个 makefile 中 some_file 依赖 other_file 。当第一次执行 make ，默认目标是 some_file ，它首先会查找依赖文件 other_file ，只要依赖文件比目标文件 some_file 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。\nsome_file: other_file echo \u0026#34;This will run second, because it depends on other_file\u0026#34; touch some_file other_file: echo \u0026#34;This will run first\u0026#34; touch other_file 下面这个 makefile 始终会执行默认目标的命令，因为它的依赖始终无法满足。\nsome_file: other_file touch some_file other_file: echo \u0026#34;nothing\u0026#34; clean 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file 变量 变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。\n使用 $( ) 调用或 ${ }。\nobj = a.o b.o c.o\rtest: $(obj)\rgcc -o test $(obj) 变量赋值一般有如下符号：\n符号 作用 = 变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。 := 变量赋值，与普通的编程语言中的赋值一样。 += 变量追加赋值 ?= 变量为空则给它赋值 = 与 := 的区别：\n# 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: echo $(one) echo $(two) := 允许你追加变量，但会导致死循环，如下。\none = hello # one gets defined as a simply expanded variable (:=) and thus can handle appending one := ${one} there all: echo $(one) ?= 仅设置尚未设置的变量\none = hello one ?= will not be set two ?= will be set all: echo $(one) # 打印 hello echo $(two) # 打印 will be set 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\n以下 makefile 使用 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 通配符 通配符 作用 * 匹配零或多个字符 % 匹配一个或多个字符 ? 匹配单个字符 * 和 % 在 makefile 中都是通配符，但它们的含义完全不同。\n* 会搜索你的文件系统来匹配文件名。个人建议调用 wildcard 函数来使用 * 。\n# 打印出当前路径下所有以.c结尾的文件的信息 print: $(wildcard *.c) ls -la $? 危险：不要在变量定义中使用 * 。\n危险：当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\nthing_wrong := *.o # 不要这样做，\u0026#39;*\u0026#39; 不会被展开，会被视作 \u0026#34;*.o\u0026#34; 字符串 thing_right := $(wildcard *.o) # 正确做法 all: one two three four # 这里会出错，因为 $(thing_wrong) 是字符串 \u0026#34;*.o\u0026#34; one: $(thing_wrong) # 如果没有文件以 \u0026#34;.o\u0026#34; 结尾，匹配不到文件时也会被视作字符串 \u0026#34;*.o\u0026#34; two: *.o # 正确运行 three: $(thing_right) # 同规则 \u0026#34;three\u0026#34; four: $(wildcard *.o) 自动化变量 符号 描述 $@ 当前目标名 $^ 所有依赖名，去重 $\u0026lt; 第一个依赖名 $+ 所有依赖名，不去重 $? 比目标新的依赖名 $* 目标中%匹配的部分 hey: one two # 输出 \u0026#34;hey\u0026#34; echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two 规则 隐式规则 隐式规则会让东西变得混乱，不推荐使用，但是要了解。\n编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的 隐式规则常用的几个变量：\nCC ：C 程序编译器，默认 cc 。 CXX ：C++ 程序编译器，默认 g++ 。 CFLAGS ：提供给 C 编译器的参数。 CXXFLAGS ：提供给 C++ 编译器的参数。 CPPFLAGS ：提供给 C 预处理器的参数。 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数。 下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c clean: rm -f blah* 静态模式规则 下面是语法：\ntargets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 函数搭配使用，如下\nobj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u0026lt; -o $@ 模式规则在目标中包含一个 % 。这个 % 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 % 代表与目标中的 % 匹配的相同词干。\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # $@ 表示目标文件 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。\nall: blah blah:: echo \u0026#34;hello\u0026#34; blah:: echo \u0026#34;hello again\u0026#34; 命令 不打印命令 在命令前加 @ ，在运行时这条命令不会被打印出来。在 make 时加上 -s 参数有同样的效果。\nall: @echo \u0026#34;This make line will not be printed\u0026#34;\recho \u0026#34;But this will\u0026#34; 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\ echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \u0026#34;Hello from bash\u0026#34; 错误处理 在运行 make 时添加 -k 参数（\u0026ndash;keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （\u0026ndash;ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n嵌套执行 make 要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。\n# 双引号中的内容等同于 # hello: # touch inside_file new_contents = \u0026#34;hello:\\n\\ttouch inside_file\u0026#34; all: mkdir -p subdir printf $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile #去掉第一行的空格并写入subdir/makefile cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 使用 export 嵌套 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：\nnew_contents = \u0026#34;hello:\\n\\\\techo \\$$(cooly)\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) # 注意输出的信息，可以看到 export 全局声明起到了作用 cooly = \u0026#34;The subdirectory can see me!\u0026#34; export cooly # 取消全局: unexport cooly clean: rm -rf subdir 你也可以在 shell 中使用全局变量\none=this will only work locally export two=we can run subcommands with this all: @echo $(one) # $$ 的意思是使用真实的 $ 符号 # 即 echo $one，由于one未声明全局环境变量，所以这条打印为空 @echo $$one @echo $(two) @echo $$two 也可以使用 .EXPORT_ALL_VARIABLES 将所用的变量都声明为全局的。\n.EXPORT_ALL_VARIABLES: new_contents = \u0026#34;hello:\\n\\techo \\$$(cooly)\u0026#34; cooly = \u0026#34;The subdirectory can see me!\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量。在这里，我们使用 make option_one=hi 运行 make\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: echo $(option_one) echo $(option_two) define函数定义 one = export blah=\u0026#34;I was set!\u0026#34;; echo $$blah define two export blah=set echo $$blah endef # One 和 two 是不一样的 all: @echo \u0026#34;这条会打印 \u0026#39;I was set\u0026#39;\u0026#34; @$(one) @echo \u0026#34;这条不会打印 \u0026#39;I was set\u0026#39; 因为每条命令运行在不同的shell中\u0026#34; @$(two) 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 if/else foo = ok all: ifeq ($(foo), ok) echo \u0026#34;foo equals ok\u0026#34; else echo \u0026#34;nope\u0026#34; endif 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格 all: ifeq ($(strip $(foo)),) echo \u0026#34;foo is empty after being stripped\u0026#34; endif ifeq ($(nullstring),) echo \u0026#34;nullstring doesn\u0026#39;t even have spaces\u0026#34; endif 检查变量是否定义 bar = foo = $(bar) all: ifdef foo echo \u0026#34;foo is defined\u0026#34; endif ifdef bar echo \u0026#34;but bar is not\u0026#34; endif 命令行参数 $(MAKEFLAGS) bar = foo = $(bar) all: # 查找 \u0026#34;-i\u0026#34; 参数。 ifneq (,$(findstring i, $(MAKEFLAGS))) echo \u0026#34;i was passed to MAKEFLAGS\u0026#34; endif 函数 函数主要只是用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\n# 字符串替换，这里 totally 替换 not bar := ${subst not, totally, \u0026#34;I am not superman\u0026#34;} all: @echo $(bar) 如果要替换空格或逗号，请使用变量\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \u0026#34;a,b,c\u0026#34; @echo $(bar) 不要在第一个参数之后包含空格。这将被视为字符串的一部分。\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 后面有一个空格 all: # 输出是 \u0026#34;, a , b , c\u0026#34;，注意空格 @echo $(bar) 字符串替换 $(patsubst pattern,replacement,text) 执行以下操作：\n使用 pattern 匹配 text 中的文件名，使用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 $(foreach var,list,text) ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\n这会在每个单词后附加一个感叹号：\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \u0026#34;who! are! you!\u0026#34; @echo $(bar) if 函数 if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 Make 支持创建基本函数。语法是 $(call variable,param,param)\n$(0) 是变量名，$(1) 、$(2) 等是参数。\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \u0026#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\u0026#34; @echo $(call sweet_new_fn, go, tigers) shell 函数 这会调用 shell，但它用空格替换了换行符。\nall: # 非常难看，因为换行符不见了 @echo $(shell ls -la) 其他特性 应用外部makefile include 的语法是\ninclude filenames vpath 指令 语法 vpath \u0026lt;pattern\u0026gt; \u0026lt;directories\u0026gt; ，\u0026lt;pattern\u0026gt; 会匹配 \u0026lt;directories\u0026gt; 中的文件名，多个目录使用 空格 或 冒号 分隔。\nvpath %.h ../headers ../other-directory\rsome_binary: ../headers blah.h\rtouch some_binary\r../headers:\rmkdir ../headers\rblah.h:\rtouch ../headers/blah.h\rclean:\rrm -rf ../headers\rrm -f some_binary .phony make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 标签 ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 make clean 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n.PHONY clean clean: rm -f *.o .delete_on_error 当规则执行失败，.delete_on_error 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise. SRCS := $(shell find $(SRC_DIRS) -name \u0026#39;*.cpp\u0026#39; -or -name \u0026#39;*.c\u0026#39; -or -name \u0026#39;*.s\u0026#39;) # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u0026lt; -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u0026lt; -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # Include the .d makefiles. The - at the front suppresses the errors of missing # Makefiles. Initially, all the .d files will be missing, and we don\u0026#39;t want those # errors to show up. -include $(DEPS) ","permalink":"https://kingtuo123.com/posts/makefile-basic/","summary":"Makefile 的基本语法，规则及命令。","title":"Makefile基础"},{"content":"docker镜像 拉取镜像 docker image pull \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 查看镜像 docker image ls -a docker images 删除镜像 docker image rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; docker image rm \u0026lt;image id\u0026gt; id不用补全，比如 ba6acccedd29 ，只需输入 ba ，只要id前几位没和其他镜像重复。\n当镜像已有创建的容器时，无法删除。可以使用-f参数强制删除。\n提交镜像 首先你在基础镜像生成的容器中做了修改后，使用 commit 命令可以生成一个新的镜像，这个镜像相较于基础镜像多了一层Layer（你在容器内做的所有修改都打包成了Layer）\ndocker commit -m \u0026#34;some info\u0026#34; 生成的镜像可以用 image 命令查看到，commit 之后你可以使用 push 命令推送到远端仓库\ndocker容器 创建容器 以下命令会自动创建一个容器并运行bash，也可以用 create 命令创建容器。\ndocker container run --name \u0026lt;name\u0026gt; -it --rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; bash run 常用参数：\n--name：指定容器名称 -i：开启标准输入 -t：分配伪终端 --rm：退出容器后自动删除容器，多用于一次性测试 -v：挂载路径，格式 -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; -p：指定端口映射，格式 -p \u0026lt;host port\u0026gt;:\u0026lt;container port\u0026gt; -P：随机端口映射，docker会随机映射一个端口到内部容器的网络端口 -d：后台运行容器，并返回容器ID，类似命令后加\u0026amp; -e：设置环境变量，格式 -e \u0026lt;variables1\u0026gt;=\u0026lt;variables2\u0026gt; --network：连接指定网络，系统预定义的有bridge、host、null三种，默认bridge（桥接） --privileged：扩大容器权限，在容器内可以看到host的更多设备、可mount挂载设备 启动容器 docker container start \u0026lt;name|container id\u0026gt; start 后面可跟多个 id\n进入容器 docker container attach \u0026lt;name|container id\u0026gt; docker container exec -it \u0026lt;name|container id\u0026gt; bash attach 在退出容器后会停止容器，exec 不会\nattach 相当于进入当前终端，exec 相当于新开了一个终端\n停止容器 docker container stop \u0026lt;name|container id\u0026gt; docker container kill \u0026lt;name|container id\u0026gt; stop 先发送SIGTERM信号，容器内程序可以做退出前的准备工作，一段时间之后再发送SIGKILL信号。\nkill 发送SIGKILL信号，应用程序直接退出。\n查看容器 列出所有容器\ndocker container ls -a 删除容器 docker container rm \u0026lt;name|container id\u0026gt; 使用 prune 可以删除所有已停止的容器\ndocker container prune 文件拷贝 拷贝无需容器运行，只要该容器存在即可，以下命令从容器拷贝至主机\ndocker container cp \u0026lt;container id|name\u0026gt;:\u0026lt;container path\u0026gt; \u0026lt;host path\u0026gt; ","permalink":"https://kingtuo123.com/posts/docker-base-cmd/","summary":"Docker 镜像/容器常用的一些命令及说明","title":"Docker基本命令"},{"content":"安装配置Mysql emerge -av dev-db/mysql 首次安装需配置root密码\nemerge --config dev-db/mysql 修改配置文件,编辑/etc/mysql/my.cnf\n[client] socket=/var/run/mysqld/mysqld.sock [mysqld] #禁用远程访问，只使用本地socket连接 skip-networking #默认套接字路径 socket=/var/run/mysqld/mysqld.sock #数据库默认存放路径 datadir=/var/lib/mysql/ 启动mysql\nrc-service mysql start 登陆mysql\nmysql -u root -p 查看端口\nmysql\u0026gt; show variables like \u0026#39;port\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | port | 0 | +---------------+-------+ 1 row in set (0.01 sec) port为0,远程连接关闭\n查看其他设置\nmysql\u0026gt; show variables like \u0026#39;socket\u0026#39;; +---------------+-----------------------------+ | Variable_name | Value | +---------------+-----------------------------+ | socket | /var/run/mysqld/mysqld.sock | +---------------+-----------------------------+ 1 row in set (0.01 sec) mysql\u0026gt; show variables like \u0026#39;datadir\u0026#39;; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.00 sec) 安装配置php 修改USE，编辑文件/etc/portage/package.use/package.use，添加如下\ndev-lang/php fpm mysql mysqli gd 按需添加，查看各项USE标记含义，执行equery u dev-lang/php\nfpm : Enable the FastCGI Process Manager SAPI mysql : Add mySQL Database support mysqli : Add support for the improved mySQL libraries gd : Adds support for gd (bundled with PHP) 安装dev-lang/php，默认会安装最新的php7\nemerge -av dev-lang/php 查看版本，执行eselect php list cli或者执行php -v\n[1] php7.3 * php默认配置文件路径/etc/php/\n修改/etc/php/fpm-php7.3/fpm.d/www.conf文件\nuser = nginx group = nginx ;默认是开9000端口用TCP连接，没有必要，注释掉改为本地socket连接 ;listen = 127.0.0.1:9000 listen = /var/run/php-fpm/php-fpm.sock listen.owner = nginx listen.group = nginx listen.mode = 0660 修改/etc/php/fpm-php7.3/php.ini,修改下面内容\n;去掉下面这行注释并在末尾添加.html，支持解析html security.limit_extensions = .php .php4 .php5 .php7 .html cgi.fix_pathinfo=0 百度了下cgi.fix_pathinfo，如果PHP的配置里 cgi.fix_pathinfo=1，会导致安全问题，这个问题只存在于 Nginx 服务器中，Apache和IIS都不会有这个问题\n安装配置nginx 执行equery u nginx检查USE标记nginx_modules_http_fastcgi是否默认添加\nemerge -av www-servers/nginx 默认配置文件路径/etc/nginx/,修改nginx.conf\nserver { listen 80 default_server; listen [::]:80 default_server; server_name localhost; include /etc/nginx/default.d/*.conf; root /home/test/www; #网站主目录 location / { root /home/test/www; index index.php index.html index.htm; } location ~ .*\\.(php|html)$ { #添加php，html解析 try_files $uri =404; fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/test/www$fastcgi_script_name; include fastcgi_params; } } 添加nginx到test用户组\nusermod -a -G test nginx 查看用户组\nroot# groups nginx test nginx 最后，确保网站主目录的group有r和x权限。\n测试 启动nginx，执行rc-service nginx start，同样再启动php-fpm和mysql。\n可以添加开机运行，执行rc-update add \u0026lt;服务名称\u0026gt; default\n在网站主目录下新建index.html,写入以下内容\n\u0026lt;?php $con=mysqli_connect(null,\u0026#34;root\u0026#34;,\u0026#34;密码\u0026#34;,null,null,\u0026#34;/var/run/mysqld/mysqld.sock\u0026#34;); if ($con){ echo \u0026#34;连接成功\u0026#34;; } ?\u0026gt; 打开浏览器输入127.0.0.1，看到连接成功，配置成功。\n","permalink":"https://kingtuo123.com/posts/gentoo-lnmp-deploy/","summary":"安装配置Mysql emerge -av dev-db/mysql 首次安装需配置root密码\nemerge --config dev-db/mysql 修改配置文件,编辑/etc/mysql/my.cnf\n[client] socket=/var/run/mysqld/mysqld.sock [mysqld] #禁用远程访问，只使用本地socket连接 skip-networking #默认套接字路径 socket=/var/run/mysqld/mysqld.sock #数据库默认存放路径 datadir=/var/lib/mysql/ 启动mysql\nrc-service mysql start 登陆mysql\nmysql -u root -p 查看端口\nmysql\u0026gt; show variables like \u0026#39;port\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | port | 0 | +---------------+-------+ 1 row in set (0.01 sec) port为0,远程连接关闭\n查看其他设置\nmysql\u0026gt; show variables like \u0026#39;socket\u0026#39;; +---------------+-----------------------------+ | Variable_name | Value | +---------------+-----------------------------+ | socket | /var/run/mysqld/mysqld.sock | +---------------+-----------------------------+ 1 row in set (0.","title":"Gentoo 搭建 lnmp 环境"},{"content":" 参考 Gentoo Wiki/Arduino\n启用内核选项 Device Drivers ---\u0026gt; [*] USB support ---\u0026gt; \u0026lt;*\u0026gt; USB Serial Converter support ---\u0026gt; \u0026lt;*\u0026gt; USB Winchiphead CH341 Single Port Serial Driver 重新编译内核。\n重启后连接设备，设备名为 /dev/ttyUSB0\n非ROOT用户访问权限 添加用户到 dialout 组\ngpasswd -a larry dialout ","permalink":"https://kingtuo123.com/posts/gentoo-ch340-driver/","summary":" 参考 Gentoo Wiki/Arduino\n启用内核选项 Device Drivers ---\u0026gt; [*] USB support ---\u0026gt; \u0026lt;*\u0026gt; USB Serial Converter support ---\u0026gt; \u0026lt;*\u0026gt; USB Winchiphead CH341 Single Port Serial Driver 重新编译内核。\n重启后连接设备，设备名为 /dev/ttyUSB0\n非ROOT用户访问权限 添加用户到 dialout 组\ngpasswd -a larry dialout ","title":"Gentoo ch340 驱动"},{"content":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n列表内容 列表内容 列表内容 有序列表 数字加点\n1. 列表内容 2. 列表内容 3. 列表内容 列表嵌套 二级列表前加三个空格\n- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 表格 表头|表头2222222|表头33333333 ---|:--:|--: 内容|内容|内容 内容|内容|内容 :--: 表示居中\n--: 靠右\n:-- 靠左\n显示如下\n表头 表头2222222 表头33333333 内容 内容 内容 内容 内容 内容 代码 ​```java 代码... 代码... 代码... ​``` ","permalink":"https://kingtuo123.com/posts/markdown-syntax/","summary":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n列表内容 列表内容 列表内容 有序列表 数字加点\n1. 列表内容 2.","title":"Markdown语法"},{"content":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","permalink":"https://kingtuo123.com/posts/curlftpfs-mount-local/","summary":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","title":"Curlftpfs挂载ftp到本地"},{"content":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。\n验证 ssh -T git@github.com 返回如下信息则配置成功\nYou\u0026#39;ve successfully authenticated, but GitHub does not provide shell access 使用SSH Key推送 使用以上的链接。\n","permalink":"https://kingtuo123.com/posts/github-set-sshkey/","summary":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。","title":"Github设置SSH Key"},{"content":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.gitignore\u0026#39; - \u0026#39;.gitmodules\u0026#39; pull_request: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 推送至仓库 git push -u origin master 查看Action中的信息，如上则配置正确。\n设置GitHub Pages Source 在Pages设置中，修改Source分支为gh-pages\n等待gh-pages自动部署完成后，即可打开站点。\n网站加速 国内访问 github.io 较慢，部署至阿里云 OSS 并使用 DCDN 加速。\n也可以直接使用DCDN加速github.io，但使用中发现缓存刷新较慢，导致页面显示异常等。\nBucket设置 设置Bucket读写权限权限为 公共读\n设置静态页面如下\n创建Accesskey 打开阿里云控制台右上角 头像 -\u0026gt; Accesskey管理\n选择 子用户Accesskey\nAccesskey创建成功后会生成 ID 和 SECRET，记得复制否则要重新创建。\n最后给当前子用户添加 AliyunOSSFullAccess 权限。\n添加Repository secrets 打开仓库主页，Setting -\u0026gt; Secrets -\u0026gt; Actions，添加Accesskey的内容。\n配置GitHub action 在 gh-pages.yml 里追加以下内容\n- name: Setup AliyunOSS uses: manyuanrong/setup-ossutil@v2.0 with: # 地域节点在Bucket概览里查看 endpoint: \u0026#34;oss-cn-hangzhou.aliyuncs.com\u0026#34; access-key-id: ${{ secrets.ID }} access-key-secret: ${{ secrets.SECRET }} - name: Deploy To OSS # 将public下的页面拷贝至Bucket run: ossutil cp -rf ./public oss://kingtuo123/ 最后 git push 一下即可。\n全站加速配置 需要已备案的域名。\n再配置全站加速，域名管理 -\u0026gt; 添加域名 ，等待生成 CNAME 记录。\n最后在 DNS解析 中添加域名 CNAME 记录。\n","permalink":"https://kingtuo123.com/posts/hugo-deploy/","summary":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.","title":"Hugo deploy"}]