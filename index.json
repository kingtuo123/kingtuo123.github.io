[{"content":"启动 OpenOCD OpenOCD 需要读取配置文件启动，通常安装目录下自带了配置文件\n调试器配置文件路径：/usr/share/openocd/scripts/interface/\n$ ls /usr/share/openocd/scripts/interface/ | grep stlink stlink.cfg stlink-dap.cfg stlink-v1.cfg stlink-v2-1.cfg stlink-v2.cfg 芯片配置文件的路径：/usr/share/openocd/scripts/target/\n$ ls /usr/share/openocd/scripts/target/ | grep stm32f stm32f0x.cfg stm32f1x.cfg stm32f2x.cfg stm32f3x.cfg stm32f4x.cfg stm32f7x.cfg 方法一 将需要的配置文件拷贝到当前目录下，使用 -f 参数指定配置文件启动：\n$ openocd -f stlink.cfg -f stm32f1x.cfg Open On-Chip Debugger 0.12.0 Licensed under GNU GPL v2 Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections Info : clock speed 1000 kHz Info : STLINK V2J38S7 (API v2) VID:PID 0483:3748 Info : Target voltage: 3.178506 Info : [stm32f1x.cpu] Cortex-M3 r1p1 processor detected Info : [stm32f1x.cpu] target has 6 breakpoints, 4 watchpoints Info : starting gdb server for stm32f1x.cpu on 3333 Info : Listening on port 3333 for gdb connections OpenOCD 启动后默认会打开 3 个端口：3333，4444，6666\n可以使用 netstat -ltpn | grep openocd 命令查看端口\n方法二 OpenOCD 默认读取当前目录下的配置文件 openocd.cfg，写入下面内容：\nsource [find interface/stlink.cfg] source [find target/stm32f1x.cfg] 然后在当前目录下运行 openocd 即可\n使用 telnet 连接 $ telnet localhost 4444 Open On-Chip Debugger \u0026gt; reset # 复位 \u0026gt; init # 初始化设备 \u0026gt; halt # 停止运行 \u0026gt; step # 单步执行 \u0026gt; resume # 恢复运行 \u0026gt; step 0x08000648 # 运行到地址0x08000648处后单步执行 \u0026gt; reset run # 复位并立即运行 \u0026gt; reset halt # 复位并立即停止 \u0026gt; reset init # 复位并立即初始化 \u0026gt; halt # 写入程序前要先停止设备 \u0026gt; program ./target.hex # 写入 hex \u0026gt; program ./target.bin 0x08000000 # 写入 bin \u0026gt; flash write_image erase ./target.hex # 擦除后写入 hex 文件 \u0026gt; flash write_image erase ./target.bin 0x08000000 # 擦除后写入 bin 文件 \u0026gt; reg # 列出所有寄存器 \u0026gt; halt # 停止设备 \u0026gt; set_reg {pc 0 sp 0x1000} # 写PC,SP寄存器 \u0026gt; get_reg {pc sp} # 读PC,SP寄存器 pc 0x00000000 sp 0x00001000 \u0026gt; write_memory 0x20000000 32 {0xdeadbeef 0x00230500} # 向内存写入两个32位数据 \u0026gt; read_memory 0x20000000 32 2 # 读取两个32位数据 0xdeadbeef 0x230500 \u0026gt; mdd 0x08000000 1 # 读1个64位的数据 \u0026gt; mdw 0x08000000 1 # 读1个32位的数据 \u0026gt; mdh 0x08000000 1 # 读1个16位的数据 \u0026gt; mdb 0x08000000 1 # 读1个 8位的数据 \u0026gt; mwd 0x20000000 0xaaaabbbbccccdddd # 写1个64位的数据 \u0026gt; mww 0x20000000 0xaaaabbbb # 写1个32位的数据 \u0026gt; mwh 0x20000000 0xaaaa # 写1个16位的数据 \u0026gt; mwb 0x20000000 0xaa # 写1个 8位的数据 \u0026gt; bp # 查看所有断点 \u0026gt; bp 0x08000648 2 hw # 在地址0x08000648处设置硬件断点 \u0026gt; rbp 0x08000648 # 删除该地址的断点 \u0026gt; rbp all # 删除所有断点 \u0026gt; exit # 退出 更多指令参考：General Commands\n使用 gdb 连接 方法一 $ gdb ./target.elf GNU gdb (Gentoo 13.2 vanilla) 13.2 Copyright (C) 2023 Free Software Foundation, Inc. ... \u0026gt; target extended-remote localhost:3333 \u0026gt; target extended-remote :3333 本地连接可省略 localhost 方法二 修改 gdb 配置文件 /home/user/.config/gdb/gdbinit：\n# 允许 gdb 加载任意路径下的 .gdbinit 文件 set auto-load safe-path / 切换到你的工程目录下，创建 .gdbinit 文件：\nfile \u0026#34;./target.elf\u0026#34; target extended-remote :3333 # 下载程序 load # main 函数设置断点 break main # 运行程序 continue 然后当前目录下运行 gdb 即可\ngdb 常用指令 $ gdb \u0026gt; load # 下载程序 \u0026gt; run # 从头运行程序 \u0026gt; break main # main 函数设置断点 \u0026gt; break 14 # 第14行设置断点 \u0026gt; break 14 if a = 2 # 当变量a=2在14行打断 \u0026gt; delete breakpoints # 删除所有断点 \u0026gt; step # 执行一条C语句，进入函数 \u0026gt; next # 执行一条C语句，不进入函数 \u0026gt; stepi # 执行一条汇编语句，进入函数 \u0026gt; nexti # 执行一条汇编语句，不进入函数 \u0026gt; continue # 继续执行 \u0026gt; print a # 打印变量a \u0026gt; until # 跳出循环 \u0026gt; finish # 跳出当前函数 \u0026gt; call func(1,2) # 直接调用func函数 \u0026gt; tui enable # 打开字符图形窗口 \u0026gt; tui disable # 关闭字符图形窗口 \u0026gt; tui reg all # 在窗口中显示所有寄存器 \u0026gt; info win # 查看有哪些窗口 \u0026gt; focus cmd # 聚焦到cmd窗口 \u0026gt; winheight src -2 # 调整源码窗口高度-2 \u0026gt; layout next # 显示下一个窗口 ","permalink":"https://kingtuo123.com/posts/openocd/","summary":"Open On-Chip Debugger 开源片上调试器","title":"OpenOCD"},{"content":" Github 项目地址 安装 ctags taglist # emerge -av dev-util/ctags app-vim/taglist 使用 ctags 生成索引 在你的项目根目录中执行，会生成 tags 文件\n$ ctags -R * $ ls -l tags -rw-r--r-- 1 user user 1273357 Aug 12 12:11 tags 在 vim 中使用 ctag 跳转 运行 vim 时，必须在 tags 文件所在的目录下运行 。\n在文件内跳转 将光标移动到函数或变量上，再按快捷键 Ctrl + ]，可直接跳转到定义处，按 Ctrl + T 可返回原处\n命令行跳转 使用 vim -t 函数名 即可打开文件直接跳转到函数定义处\n$ vim -t main 在 vim 中使用 taglist vim 命令模式下输入 :Tlist 即可打开，再次输入关闭\ntaglist 配置 let Tlist_Show_One_File=1 \u0026#34; 不同时显示多个文件的 tag，只显示当前文件的 let Tlist_Exit_OnlyWindow=1 \u0026#34; 如果 taglist 窗口是最后一个窗口，则退出vim let Tlist_Ctags_Cmd=\u0026#34;/usr/bin/ctags\u0026#34; \u0026#34; 将 taglist 与 ctags 关联 taglist 快捷键 快捷键 说明 回车 跳转到 tag 定义处 空格 在 vim 底部显示 tag 的函数原型 o 新窗口打开关标下的 tag p 跳转到 tag 的定义处，但光标仍留在 taglist 窗口内 u 更新窗口中的 tag s 更改排序方式，按名字排序，按出现顺序排序，之间切换 x 窗口放大和缩小 + 打开一个折叠，同 zo - 将 tag 折叠，同 zc * 打开所有折叠，同 zR = 折叠所有 tag，同 zM [[ 跳到前一个文件 ]] 跳到后一个文件 q 关闭窗口 F1 显示帮助 ","permalink":"https://kingtuo123.com/posts/vim-ctags/","summary":"使用 ctags 轻松索引","title":"Vim ctags taglist"},{"content":" 参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 链接脚本中 AT\u0026gt; 的作用 LD 链接器 How to get the load address of .data section C代码中如何使用链接脚本中定义的变量 From Zero to main(): Bare metal C From Zero to main(): Demystifying Firmware Linker Scripts STM32的启动 硬件平台 STM32F103ZET6 野火霸道开发板 V2\n准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境\n预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x08000000，SRAM 起始地址是 0x20000000\n参考手册 Boot configuration 一节有这样一段话：\n上电后，CPU 从地址 0x00000000 获取栈顶地址，然后从地址 0x00000004 处开始执行代码\n从 FLASH 启动时，CPU 将地址 0x00000000 映射到 0x08000000，然后 CPU 就可以从 0x00000000 读取 FLASH 上的数据，当然 0x08000000 依然是可以被 CPU 访问的。\n0x00000000 中的值会被加载到 SP 寄存器，0x00000004 中的值会被加载到 PC 寄存器\n开始编写 最简单的链接脚本 链接文件由一个称为 SECTIONS 的块组成。在此块中，你定义的段将被按顺序分配到二进制文件中。\n比较重要的段有：\n.text 包含你的代码 .rodata 包含 const 定义的常量数据 .data 包含已初始化的全局/静态变量 .bss 包含未初始化的全局/静态变量 第一个脚本，将只使用 .text 。没有数据，没有变量，只有纯代码。\n创建一个 script.ld 文件，写入下面的内容：\nSECTIONS { .text : { /* 星号是通配符 */ *(.text) *(.text*) } } 上面的脚本告诉链接器：\n创建一个 .text 段（冒号左边的部分） 获取目标文件中所有的 .text 段（花括号中的部分） 把第 2 步获取的段放到第 1 步创建的段中 虽然定义了代码部分，但没有指定它放在哪里。根据之前讲述的内容，它应该被放到地址 0x08000000：\nSECTIONS { . = 0x08000000; .text : { *(.text) *(.text*) } } 点 . 是位置计数器。它从 0x0 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 .text 段之后读取位置计数器的值，它的值将是 0x08000000 加上你添加的段的大小。\n接下来添加栈顶地址及入口程序地址：\nENTRY(main); SECTIONS { . = 0x08000000; .text : { /* BYTE，SHORT，LONG，QUAD 命令分别存储 1，2，4，8 字节 */ LONG(0x20010000); LONG(main | 1); *(.text) *(.text*) } } 当 STM32 启动时，它会从 FLASH 读取两个地址（共 8 字节）。第一个是栈顶地址，第二个是入口程序地址。\nENTRY(main) 告诉链接器使用 mian 作为程序的入口点。这也可以防止包含 main 函数的 .text 部分被链接器作为垃圾“优化”（因为 main 函数没有被其它函数调用）。\nLONG(0x20010000) 告诉链接器将 0x20010000 这四个字节放入输出的二进制文件中。为什么是这四个字节？因为 SRAM 地址从 0x20000000 开始，大小有 64KB（0x10000）。 0x20000000 + 0x10000 = 0x20010000 就是栈顶的地址。\nLONG(main | 1) 将 main 函数的地址输出到二进制文件中。main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 使用 thumb 指令集。\n疑问：SRAM 的范围是 0x20000000 - 0x2000FFFF，初始栈顶地址却是 0x20010000\n因为 CM3 使用的是向下生长的满栈，栈顶初始值必须是内存的末地址加 1\n满栈进栈是先移动指针再存数据\n接下来创建 main.c 来点亮开发板上的红色 LED ：\n#include \u0026#34;registers.h\u0026#34; // 由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余 int main(void) { // 开启 GPIOB 时钟 RCC-\u0026gt;APB2ENR |= (1 \u0026lt;\u0026lt; LED_CLK); // 配置 PB5 引脚推挽输出 LED_GPIO-\u0026gt;CRL |= (3 \u0026lt;\u0026lt; (LED_PIN * 4)); // 引脚输出低电平 LED_GPIO-\u0026gt;BRR = (1 \u0026lt;\u0026lt; LED_PIN); while (1); } 创建头文件 registers.h ：\n#ifndef __REGISTERS_H #define __REGISTERS_H #include \u0026lt;stdint.h\u0026gt; typedef struct { uint32_t CR; uint32_t CFGR; uint32_t CIR; uint32_t APB2RSTR; uint32_t APB1RSTR; uint32_t AHBENR; uint32_t APB2ENR; uint32_t APB1ENR; uint32_t BDCR; uint32_t CSR; } RCC_Reg; #define RCC ((RCC_Reg*) 0x40021000) typedef struct { uint32_t CRL; uint32_t CRH; uint32_t IDR; uint32_t ODR; uint32_t BSRR; uint32_t BRR; uint32_t LCKR; } GPIOB_Reg; #define GPIOB ((GPIOB_Reg*) 0x40010C00) #define LED_CLK 3 #define LED_GPIO GPIOB #define LED_PIN 5 #endif 创建 makefile ：\nTARGET := led BUILD_DIR := ./Build C_SRC := main.c C_OBJ := main.o CP_FLAGS := -mcpu=cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP LD_FLAGS := -mcpu=cortex-m3 -specs=nano.specs -T script.ld -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--gc-sections .PHONY: all all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin @echo \u0026#34;Done\u0026#34; %.elf: $(BUILD_DIR)/$(C_OBJ) arm-none-eabi-gcc $(LD_FLAGS) $\u0026lt; -o $@ $(BUILD_DIR)/%.o: %.c arm-none-eabi-gcc -c $(CP_FLAGS) $\u0026lt; -o $@ %.hex: %.elf arm-none-eabi-objcopy -O ihex $\u0026lt; $@ %.bin: %.elf arm-none-eabi-objcopy -O binary -S $\u0026lt; $@ $(BUILD_DIR): mkdir -p $@ clean: rm $(BUILD_DIR) -rf install: st-flash write $(BUILD_DIR)/$(TARGET).bin 0x08000000 -include $(BUILD_DIR)/*.d 现在目录下有这几个文件：\n$ ls main.c makefile registers.h script.ld 编译代码：\n$ make $ ls Build/ led.bin led.elf led.hex main.d main.o 查看 led.bin 文件：\n$ hexdump Build/led.bin 0000000 0000 2001 0009 0800 4a06 6993 f043 0308 0000010 6193 4b05 681a f442 1240 601a 2220 615a 0000020 e7fe bf00 1000 4002 0c00 4001 b5f8 bf00 0000030 b5f8 bf00 前面 8 个字节 0000 2001 0009 0800 数据从小端转换为大端就是：2001 0000 ，0800 0009\n第一个就是在链接脚本中设置的栈顶地址 0x20010000\n第二个很可能是 main 函数的地址 0x08000009，最后一位表示 thumb 指令集，所以实际应该是 0x08000008\n查看一下：\n$ arm-none-eabi-objdump -D Build/led.elf 08000008 \u0026lt;main\u0026gt;: 8000008: 4a06 ldr r2, [pc, #24] @ (8000024 \u0026lt;main+0x1c\u0026gt;) 8000012: 4b05 ldr r3, [pc, #20] @ (8000028 \u0026lt;main+0x20\u0026gt;) 最后下载程序，成功点亮 led，使用 stlink 烧录器和 st-flash 命令烧录（见 makefile）：\n$ make install 添加 .data MEMORY { /* 名称 (读/写/执行权限) 起始地址 大小 */ SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K } ENTRY(main); SECTIONS { .text : { LONG(0x20010000); LONG(main | 1); *(.text) *(.text*) } \u0026gt;FLASH .data : { *(.data) *(.data*) /* AT\u0026gt; 指令用于指定这个段的加载内存地址 */ } \u0026gt;SRAM AT\u0026gt; FLASH } 相较之前做了这些改动：\n增加了 MEMORY 块，定义了两个区域 FLASH 和 SRAM 增加了 .data 段，可以存放已初始化的全局/静态变量 删除了位置计数器 \u0026gt;FLASH 表示将 .text 段放到 FLASH 中 \u0026gt;SRAM AT\u0026gt; FLASH 表示 .data 段的 VMA 在 SRAM 中，LMA 在 FLASH 中 VMA（虚拟内存地址）：程序运行时的地址，即堆栈上的地址。\nLMA（加载内存地址）：程序数据存储的地址，比如已初始化的全局变量的值在 FLASH 中存储的地址就是 LMA ，当这个值被加载到 SRAM 中栈上的地址就是 VMA 。\n简单来说：LMA 是在 ROM 中的地址，VMA 是在 RAM 中的地址。\n.text 没有使用 AT\u0026gt; 指定 LMA，所以它的 LMA = VMA\n修改一下 main.c 并添加一个全局变量：int a = 0xAAAABBBB，\n#include \u0026#34;registers.h\u0026#34; int a = 0xAAAABBBB; int main(void) { RCC-\u0026gt;APB2ENR |= (1 \u0026lt;\u0026lt; LED_CLK); LED_GPIO-\u0026gt;CRL |= (3 \u0026lt;\u0026lt; (LED_PIN * 4)); LED_GPIO-\u0026gt;BSRR = (1 \u0026lt;\u0026lt; LED_PIN); if(a == 0xAAAABBBB){ // 点亮 LED LED_GPIO-\u0026gt;BRR = (1 \u0026lt;\u0026lt; LED_PIN); } while (1); } 看看 a 会被放在哪里：\n$ arm-none-eabi-objdump -D Build/led.elf Disassembly of section .data.a: 20000000 \u0026lt;a\u0026gt;: 20000000: aaaabbbb bge 1eaaeef4 \u0026lt;main+0x16aaeee4\u0026gt; $ arm-none-eabi-objdump -h Build/led.elf Build/led.elf: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000008 08000000 08000000 00001000 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE ... 4 .data.a 00000004 20000000 08000048 00002000 2**2 CONTENTS, ALLOC, LOAD, DATA ... 可以看到 a 的 VMA = 20000000，LMA = 08000048\n也就是说 a 存储在 FLASH 的 0x08000048 地址处\n此时写入程序，发现 led 不点亮，因为 a 的值不会自己从 0x08000048 跑到 0x20000000 地址处， 所以还需要编写代码完成这个操作。\n初始化 .data 初始化 .data 段，就是把 .data 中的数据搬运到栈中，我们需要知道 .data 的地址和栈的地址\n先修改一下链接脚本：\nMEMORY { SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K } ENTRY(Reset_Handler); SECTIONS { .text : { LONG(0x20010000); /* 修改了入口函数 */ LONG(Reset_Handler | 1); *(.text) *(.text*) } \u0026gt;FLASH /* 获取 .data 在 FLASH 上起始位置的加载内存地址 LMA */ _sidata = LOADADDR(.data); .data : { /* 获取 .data 在栈上的起始位置的虚拟内存地址 VMA*/ _sdata = .; *(.data) *(.data*) /* 获取 .data 在栈上的结束位置的虚拟内存地址 VMA */ _edata = .; } \u0026gt;SRAM AT\u0026gt; FLASH } 现在通过变量 _sidata，_sdata，_edata 就能获取 .data 的 LMA 和 VMA，接下来需要在 main 函数运行之前把数据搬运过去，我们把数据搬运的工作交给 Reset_Handler 这个函数。\n修改 main.c 如下：\n#include \u0026#34;registers.h\u0026#34; extern int _sidata, _sdata, _edata; int a = 0xAAAABBBB; int main(void) { RCC-\u0026gt;APB2ENR |= (1 \u0026lt;\u0026lt; LED_CLK); LED_GPIO-\u0026gt;CRL |= (3 \u0026lt;\u0026lt; (LED_PIN * 4)); LED_GPIO-\u0026gt;BSRR = (1 \u0026lt;\u0026lt; LED_PIN); if(a == 0xAAAABBBB){ // 点亮 LED LED_GPIO-\u0026gt;BRR = (1 \u0026lt;\u0026lt; LED_PIN); } while (1); } void Reset_Handler(void){ // LMA int* init_data = \u0026amp;_sidata; // VMA int* stack_ptr = \u0026amp;_sdata; while(stack_ptr \u0026lt; \u0026amp;_edata){ // 搬运数据 *stack_ptr++ = *init_data++; } main(); } 通过 Reset_Handler 函数初始化 .data 后，再调用 main 主函数。\nOK，成功点亮 LED ！\n类似的，初始化 .bss 更简单，只需要将 .bss 在栈上的区域赋值为 0 即可。\nST 标准库启动文件 gcc_ride7/startup_stm32f10x_hd.s arm/startup_stm32f10x_hd.s 对于 gcc 编译器，堆栈初始化在 Reset_Handler 中进行，最后会调用 mian 函数：\nReset_Handler: /* Copy the data segment initializers from flash to SRAM */ movs r1, #0 b LoopCopyDataInit ... LoopFillZerobss: ldr r3, = _ebss cmp r2, r3 bcc FillZerobss /* Call the clock system intitialization function.*/ bl SystemInit /* Call the application\u0026#39;s entry point.*/ bl main bx lr 对于 ARM Compiler（Keil 自带的编译器）Reset_Handler 是调用 C 库提供的 __mian 函数初始化堆栈，__main 再调用用户的 main 函数：\n; Reset handler Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT __main IMPORT SystemInit ; 调用 SystemInit 配置系统时钟 LDR R0, =SystemInit BLX R0 ; 调用 __main LDR R0, =__main BX R0 ENDP ","permalink":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/","summary":"linker scripts sucks","title":"从零编写 STM32 链接脚本"},{"content":" 参考文章： Linux xargs 命令 概述 xargs（eXtended ARGuments）\nxargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。\n之所以能用到这个命令，关键是由于很多命令不支持管道来传递参数。\nxargs 与管道的区别 xargs 将上一条命令的标准输出，作为后一条命令的参数\n$ echo \u0026#34;--help\u0026#34; | xargs cat Usage: cat [OPTION]... [FILE]... ... 管道 将上一条命令的标准输出，作为后一条命令的标准输入\n$ echo \u0026#34;--help\u0026#34; | cat --help ","permalink":"https://kingtuo123.com/posts/xargs/","summary":"eXtended ARGuments 参数扩展","title":"xargs"},{"content":" 参考文章： GIT Branch and its Operations Git 分支操作 How To Add and Update Git Submodules How to Remove a Git Submodule how to delete all commit history in github Git 配置 配置文件路径 全局配置文件 /etc/gitconfig 当前用户配置文件 ~/.gitconfig 或 ~/.config/git/config 当前仓库配置文件 .git/config 后面配置会覆盖上层的配置\n设置帐号 # 设置用户名 git config --global user.name \u0026#34;Your Name\u0026#34; # 设置邮箱 git config --global user.email \u0026#34;email@example.com\u0026#34; 查看帐号 # 查看用户名 git config user.name # 查看邮箱 git config user.email # 直接看配置文件 cat ~/.gitconfig Git 创建/提交基本流程 # 初始化仓库 git init # 添加文件到仓库 echo \u0026#34;Hello World\u0026#34; \u0026gt;\u0026gt; README.md # 添加文件到暂存区 git add README.md # 提交到本地仓库 git commit -m \u0026#34;first commit\u0026#34; # 创建 master 分支 git branch -M master # 添加远程仓库 git remote add origin git@github.com:kingtuo123/test-only.git # 推送到远程仓库 git push -u origin master Git 分支操作 基础操作 # 查看分支 git branch -v # 查看当前分支 git branch --show-current # 创建分支，其本质只是创建了一个可以移动的新的指针 git branch 分支名 # 删除分支 git branch -d 分支名 # 切换分支 git checkout 分支名 # 合并分支，例如想合并其它分支到 master，则需要先切换至 master，再执行下列命令 git merge 分支名 合并分支示意图\n合并冲突 执行 git merge --abort 可取消合并\n解决冲突\n使用 git status 查看合并失败的文件：\nUnmerged paths: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to mark resolution) both modified: README.md 打开 README.md，其中 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 和 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 之间的就是冲突的地方：\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD this is master branch ======= this is test branch \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; test 解决冲突就是把这部分按自己的需求修改（如下），然后删除这些个符号\u0026lt;，\u0026gt;，=：\nthis is master + test branch 最后再执行 add 和 commit\nGit 子模块 拉取子模块 如果使用 git clone 拉取的项目中含有子模块，用下面命令拉取子模块：\ngit submodule update --init --recursive 可以使用 git clone --recurse-submodules URL 一并拉取子模块的文件，就不用上面的操作了\n更新子模块 git submodule update --remote --merge 添加子模块 git submodule add \u0026lt;远程仓库地址\u0026gt; \u0026lt;本地路径\u0026gt; 例如添加 hugo-PaperMod 这个项目到 themes/hugo-PaperMod 路径：\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/hugo-PaperMod 删除子模块 # 查看子模块路径 git submodule # 移除子模块 git submodule deinit \u0026lt;path_to_submodule\u0026gt; # 移除目录 git rm \u0026lt;path_to_submodule\u0026gt; # 提交 git commit -m \u0026#34;Removed submodule \u0026lt;path_to_submodule\u0026gt;\u0026#34; Git 清空历史 commits # 创建孤立分支，并切换到该分支 git checkout --orphan latest_branch # 暂存所有文件 git add -A # 提交所有更改 git commit -am \u0026#34;First Commit\u0026#34; # 删除主分支 master git branch -D master # 重命名当前分支为 master git branch -m master # 强制推送本地分支 git push -f origin master ","permalink":"https://kingtuo123.com/posts/git-basic/","summary":"分布式版本控制系统","title":"git"},{"content":" 参考文章 FatFs 串行FLASH文件系统FatFs 硬件 STM32F103ZET6 Flash芯片：W25Q64JV FatFs 源码 下载地址 解压后，源码都在 source 文件夹中\n添加到 Keil 工程，记得添加头文件路径\n配置 ffconf.h // 使能 f_mkfs 函数 #define FF_USE_MKFS 1 // 支持 U.S. 编码。中文是936，但是会大大增加烧录程序的大小 #define FF_CODE_PAGE 437 // 支持长文件名 #define FF_USE_LFN 1 // 文件名使用 utf8 编码，如果设置了这一项，则 FF_CODE_PAGE 没有意义 #define FF_LFN_UNICODE 2 // 物理设备数量 #define FF_VOLUMES 1 // 扇区大小的最小值 #define FF_MIN_SS 512 // 扇区大小的最大值 #define FF_MAX_SS 4096 // 不使用时间戳，如果设置0启用，则需要添加 get_fattime 函数 #define FF_FS_NORTC 1 编辑 diskio.c 需修改设备编号 DEV_FLASH 宏定义，及所有函数。\n/* This is an example of glue functions to attach various exsisting */ /* storage control modules to the FatFs module with a defined API. */ /*-----------------------------------------------------------------------*/ #include \u0026#34;ff.h\u0026#34; /* Obtains integer types */ #include \u0026#34;diskio.h\u0026#34; /* Declarations of disk functions */ #include \u0026#34;bsp_flash.h\u0026#34; /* Definitions of physical drive number for each drive */ #define DEV_FLASH 0 /*-----------------------------------------------------------------------*/ /* Get Drive Status */ /*-----------------------------------------------------------------------*/ DSTATUS disk_status ( BYTE pdrv /* Physical drive nmuber to identify the drive */ ) { switch (pdrv) { case DEV_FLASH : // 通过读 Flash id 判断 if(FLASH_JADEC_ID == FLASH_ReadJedecID()) return RES_OK; else return STA_NOINIT; default: return STA_NOINIT; } } /*-----------------------------------------------------------------------*/ /* Inidialize a Drive */ /*-----------------------------------------------------------------------*/ DSTATUS disk_initialize ( BYTE pdrv /* Physical drive nmuber to identify the drive */ ) { switch (pdrv) { case DEV_FLASH : // Flash 初始化 FLASH_Init(); return RES_OK; default: return STA_NOINIT; } } /*-----------------------------------------------------------------------*/ /* Read Sector(s) */ /*-----------------------------------------------------------------------*/ DRESULT disk_read ( BYTE pdrv, /* Physical drive nmuber to identify the drive */ BYTE *buff, /* Data buffer to store read data */ LBA_t sector, /* Start sector in LBA */ UINT count /* Number of sectors to read */ ) { switch (pdrv) { case DEV_FLASH : FLASH_Read(sector*FLASH_SECTOR_SIZE, buff, count*FLASH_SECTOR_SIZE); return RES_OK; default: return RES_PARERR; } } /*-----------------------------------------------------------------------*/ /* Write Sector(s) */ /*-----------------------------------------------------------------------*/ #if FF_FS_READONLY == 0 DRESULT disk_write ( BYTE pdrv, /* Physical drive nmuber to identify the drive */ const BYTE *buff, /* Data to be written */ LBA_t sector, /* Start sector in LBA */ UINT count /* Number of sectors to write */ ) { switch (pdrv) { case DEV_FLASH : // Flash 写入前需擦除扇区 FLASH_SectorErase(sector*FLASH_SECTOR_SIZE); FLASH_Write(sector*FLASH_SECTOR_SIZE, (uint8_t*)buff, count*FLASH_SECTOR_SIZE); return RES_OK; default: return RES_PARERR; } } #endif /*-----------------------------------------------------------------------*/ /* Miscellaneous Functions */ /*-----------------------------------------------------------------------*/ DRESULT disk_ioctl ( BYTE pdrv, /* Physical drive nmuber (0..) */ BYTE cmd, /* Control code */ void *buff /* Buffer to send/receive control data */ ) { switch (pdrv) { case DEV_FLASH: switch (cmd) { case GET_SECTOR_COUNT: // 扇区数量 2048 *(DWORD*)buff = FLASH_SECTOR_COUNT; return RES_OK; // 扇区大小 4096 case GET_SECTOR_SIZE: *(WORD*)buff = FLASH_SECTOR_SIZE; return RES_OK; // 同时擦除扇区个数 case GET_BLOCK_SIZE: *(DWORD*)buff = 1; return RES_OK; default: return RES_OK; } default: return RES_PARERR; } } 测试程序 Flash 驱动见这篇文章 Flash SPI 因为缓冲区数组较大，所以要适当修改 启动文件 中 栈 的大小，以免溢出。 uint16_t fatfs_test(void){ FATFS fs; // 文件系统对象 FIL fp; // 文件对象 FRESULT ret; // 返回值 UINT fnum; // 存储写入/读取的字节数 BYTE workbuf[FF_MAX_SS]; // 格式化缓冲区 BYTE readbuf[100]; // 读缓冲区 BYTE writebuf[] = \u0026#34;你好,世界!\u0026#34;; // 写缓冲区 TCHAR* dev = \u0026#34;0:\u0026#34;; // DEV_FLASH设备号 TCHAR* fname = \u0026#34;0:hello.txt\u0026#34;; // 文件名 MKFS_PARM opt; // 格式化参数 opt.fmt = FM_FAT; // 文件系统类型 opt.n_fat = 0; // 0表示默认值 opt.align = 0; // opt.n_root = 0; // opt.au_size = FF_MAX_SS; // 簇大小 // 挂载设备 ret = f_mount(\u0026amp;fs, dev, 1); switch(ret){ case FR_OK: printf(\u0026#34;挂载成功\\r\\n\u0026#34;); break; case FR_NO_FILESYSTEM: ret = f_mkfs(\u0026#34;0:\u0026#34;, \u0026amp;opt, workbuf, FF_MAX_SS); if(!ret){ printf(\u0026#34;格式化成功\\r\\n\u0026#34;); }else{ printf(\u0026#34;格式化失败（%d）\\r\\n\u0026#34;, ret); return ret; } break; default: printf(\u0026#34;挂载失败（%d）\\r\\n\u0026#34;, ret); return ret; } // 测试打开文件写入 ret = f_open(\u0026amp;fp, fname, FA_CREATE_ALWAYS | FA_WRITE ); if(ret){ printf(\u0026#34;打开/创建文件失败（%d）\\r\\n\u0026#34;, ret); return ret; } ret = f_write(\u0026amp;fp, writebuf, sizeof(writebuf), \u0026amp;fnum); if(ret){ printf(\u0026#34;文件写入失败（%d）\\r\\n\u0026#34;, ret); return ret; } printf(\u0026#34;文件写入字节数：%d \\r\\n\u0026#34;, fnum); f_close(\u0026amp;fp); // 测试打开文件读取 ret = f_open(\u0026amp;fp, fname, FA_OPEN_EXISTING | FA_READ); if(ret){ printf(\u0026#34;打开文件失败（%d）\\r\\n\u0026#34;, ret); return ret; } ret = f_read(\u0026amp;fp, readbuf, sizeof(readbuf), \u0026amp;fnum); if(ret){ printf(\u0026#34;文件读取失败（%d）\\r\\n\u0026#34;, ret); return ret; } printf(\u0026#34;文件读取字节数：%d \\r\\n\u0026#34;, fnum); printf(\u0026#34;文件内容：\\r\\n%s\\r\\n\u0026#34;, readbuf); f_close(\u0026amp;fp); // 卸载设备 f_mount(NULL, dev, 1); return 0; } ","permalink":"https://kingtuo123.com/posts/stm32-fatfs/","summary":"stm32 移植 FatFs 并实现基本的读写功能","title":"STM32 移植 FatFs R0.15"},{"content":"硬件 lcd12864 接口： 单片机：stm32f103c8t6\n接线：\n相关参数 参考：ST7565R 数据手册\n数据是高位（MSB）先发送的方式 SCL 空闲时高电平 SCL 上升沿对 SI 输入采样 D0-D7 就是一个字节，发送时 D7 在前 每 8 行就是一页 命令 /RD 和 /WR 是 8080 和 6800 时序用的，不管它。 A0：0 表示低电平发送的是命令，1 高电平是数据 字模软件 PCtoLCD2002 选项配置，本文程序使用行列式 逐列式 逐行式 行列式 列行式 LCD 扫描方式通过命令配置：\n行扫描（Common output mode select） 0xC0：从下到上 0xC8：从上到下 列扫描（ADC select） 0xA0：从左到右 0xA1：从右到左 程序 由于程序中使用的是GB2312编码，所以Keil工程要如下设置 汉字使用区位码索引：GB2312编码对照表\n最终效果如下，能实现任意座标/中英文混合显示：\nmain.c #include \u0026#34;stm32f10x.h\u0026#34; #include \u0026#34;bsp_lcd.h\u0026#34; int main(void){ // RCC_Config(); LCD_SPI_Init(); LCD_ST7565R_Config(); LCD_ClearBuffer(); while(1){ LCD_DrawString(30,30,12,\u0026#34; 你好,世界!\\nHello World!\u0026#34;); LCD_FlushBuffer(); } } bsp_lcd.h #ifndef __BSP_LCD_H #define __BSP_LCD_H #include \u0026#34;stm32f10x.h\u0026#34; // 硬件SPI和软件SPI //#define SPI_HARD #define SPI_SOFT #define LCD_SPIx SPI1 #define LCD_SPI_APBxClock_FUN RCC_APB2PeriphClockCmd #define LCD_SPI_CLK RCC_APB2Periph_SPI1 #define LCD_PIN_APBxClock_FUN RCC_APB2PeriphClockCmd // CS引脚 #define LCD_CS_CLK RCC_APB2Periph_GPIOA #define LCD_CS_PORT GPIOA #define LCD_CS_PIN GPIO_Pin_4 // SCK引脚 #define LCD_SCK_CLK RCC_APB2Periph_GPIOA #define LCD_SCK_PORT GPIOA #define LCD_SCK_PIN GPIO_Pin_5 // A0引脚 #define LCD_A0_CLK RCC_APB2Periph_GPIOA #define LCD_A0_PORT GPIOA #define LCD_A0_PIN GPIO_Pin_6 // SDA引脚（MOSI） #define LCD_SDA_CLK RCC_APB2Periph_GPIOA #define LCD_SDA_PORT GPIOA #define LCD_SDA_PIN GPIO_Pin_7 // 片选电平控制，低电平是选中 #define LCD_CS_LOW() GPIO_ResetBits(LCD_CS_PORT, LCD_CS_PIN) #define LCD_CS_HIGH() GPIO_SetBits(LCD_CS_PORT, LCD_CS_PIN) // A0命令电平控制，低电平是发送命令，高是发送数据 #define LCD_A0_LOW() GPIO_ResetBits(LCD_A0_PORT, LCD_A0_PIN ) #define LCD_A0_HIGH() GPIO_SetBits(LCD_A0_PORT, LCD_A0_PIN) // SCK #define LCD_SCK_LOW() GPIO_ResetBits(LCD_SCK_PORT, LCD_SCK_PIN) #define LCD_SCK_HIGH() GPIO_SetBits(LCD_SCK_PORT, LCD_SCK_PIN) // SDA #define LCD_SDA_LOW() GPIO_ResetBits(LCD_SDA_PORT, LCD_SDA_PIN) #define LCD_SDA_HIGH() GPIO_SetBits(LCD_SDA_PORT, LCD_SDA_PIN) // 硬件SPI等待数据全部发完延时计数，如果无显示可以适当调整 #define SPI_HARD_DELAY ((uint32_t)50) // 软件SPI延时 #define SPI_SOFT_DELAY ((uint32_t)10) // 列数 #define LCD_COLUMN_NUM 128 // 页面数 #define LCD_PAGE_NUM 8 void LCD_SPI_Init(void); void LCD_ST7565R_Config(void); void SPI_Send(uint8_t byte); void LCD_SendData(uint8_t byte); void LCD_SendCmd(uint8_t byte); void SPI_Delay(__IO uint32_t time); void LCD_SetPosition(uint8_t page, uint8_t column); void LCD_FlushBuffer(void); void LCD_ClearBuffer(void); void LCD_DrawHanzi16x16(int16_t x, int16_t y, char* hanzi); void LCD_DrawString(int16_t x, int16_t y, uint8_t height, char* str); void LCD_DrawAscii8x16(int16_t x, int16_t y, char* ascii); void LCD_DrawHanzi12x12(int16_t x, int16_t y, char* hanzi); void LCD_DrawAscii6x12(int16_t x, int16_t y, char* ascii); void LCD_DrawDot(uint8_t x, uint8_t y); #endif bsp_lcd.c #include \u0026#34;bsp_lcd.h\u0026#34; #include \u0026#34;font.h\u0026#34; uint8_t LCD_Buffer[LCD_PAGE_NUM][LCD_COLUMN_NUM]; /** * @brief LCD初始化 * @param 无 * @retval 无 */ void LCD_SPI_Init(void){ // 硬件SPI #if defined SPI_HARD SPI_InitTypeDef SPI_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; // 使能SPI时钟 LCD_SPI_APBxClock_FUN ( LCD_SPI_CLK, ENABLE ); // 使能SPI引脚相关的时钟 LCD_PIN_APBxClock_FUN(LCD_CS_CLK| LCD_SCK_CLK| LCD_A0_CLK| LCD_SDA_CLK, ENABLE ); // CS引脚，普通IO GPIO_InitStructure.GPIO_Pin = LCD_CS_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(LCD_CS_PORT, \u0026amp;GPIO_InitStructure); // A0引脚，普通IO GPIO_InitStructure.GPIO_Pin = LCD_A0_PIN; GPIO_Init(LCD_A0_PORT, \u0026amp;GPIO_InitStructure); // SCK引脚 GPIO_InitStructure.GPIO_Pin = LCD_SCK_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(LCD_SCK_PORT, \u0026amp;GPIO_InitStructure); // SDA(MOSI)引脚 GPIO_InitStructure.GPIO_Pin = LCD_SDA_PIN; GPIO_Init(LCD_SDA_PORT, \u0026amp;GPIO_InitStructure); // 片选拉高，先不通讯LCD LCD_CS_HIGH(); // SPI配置，单向只发送 SPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx; // 主机模式 SPI_InitStructure.SPI_Mode = SPI_Mode_Master; // 数据帧长度8bit SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; // 时钟极性，SCK空闲时高电平 SPI_InitStructure.SPI_CPOL = SPI_CPOL_High; // 时钟相位，在SCK的第二(偶数)个跳变沿采样 SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; // 软件控制片选 SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; // SCK时钟频率，PLCK2/256=72/32 SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_32; // 数据传输时高位先行 SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; // CRC校验的多项式(忽略，默认是7) SPI_InitStructure.SPI_CRCPolynomial = 7; // 初始化SPI SPI_Init(LCD_SPIx, \u0026amp;SPI_InitStructure); // 使能SPI SPI_Cmd(LCD_SPIx, ENABLE); // 软件SPI #elif defined SPI_SOFT GPIO_InitTypeDef GPIO_InitStructure; // 使能GPIO时钟 LCD_PIN_APBxClock_FUN(LCD_CS_CLK| LCD_SCK_CLK| LCD_A0_CLK| LCD_SDA_CLK, ENABLE ); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // CS GPIO_InitStructure.GPIO_Pin = LCD_CS_PIN; GPIO_Init(LCD_CS_PORT, \u0026amp;GPIO_InitStructure); // A0 GPIO_InitStructure.GPIO_Pin = LCD_A0_PIN; GPIO_Init(LCD_A0_PORT, \u0026amp;GPIO_InitStructure); // SCK GPIO_InitStructure.GPIO_Pin = LCD_SCK_PIN; GPIO_Init(LCD_SCK_PORT, \u0026amp;GPIO_InitStructure); // SDA GPIO_InitStructure.GPIO_Pin = LCD_SDA_PIN; GPIO_Init(LCD_SDA_PORT, \u0026amp;GPIO_InitStructure); LCD_CS_HIGH(); LCD_SCK_HIGH(); #endif } /** * @brief ST7565R参数配置 * @param 无 * @retval 无 */ void LCD_ST7565R_Config(void){ // 软复位 LCD_SendCmd(0xe2); // 关闭显示 LCD_SendCmd(0xAE); // 设置正向显示(Display normal/reverse) LCD_SendCmd(0xA6); // 电源控制,全部开启(Power Control set) LCD_SendCmd(0x2F); // 1/9偏压比（bias） LCD_SendCmd(0xA2); // 行扫描顺序，从上到下(Common output mode select) LCD_SendCmd(0xC8); // 列扫描顺序，从左到右(ADC select) LCD_SendCmd(0xA0); // 起始行(Display start line set) LCD_SendCmd(0x40); // 粗调对比度，范围0x20-0x27,命令17 LCD_SendCmd(0x24); // 微调对比度，命令18 LCD_SendCmd(0x81); // 微调对比度的值，范围0x00-0x3F，命令18 LCD_SendCmd(0x20); // 开启显示 LCD_SendCmd(0xAF); } /** * @brief SPI 发送函数 * @param byte: 一个字节 * @retval 无 */ void SPI_Send(uint8_t byte){ // 硬件SPI #if defined SPI_HARD __IO uint32_t timeout = 100; // 等待发送缓冲区为空，TXE事件 while(SPI_I2S_GetFlagStatus(LCD_SPIx , SPI_I2S_FLAG_TXE) == RESET){ if((timeout--) == 0) return; } SPI_I2S_SendData(LCD_SPIx , byte); // 这里必须要延时，SPI_I2S_SendData只负责把数据放入发送寄存器中， // 还需要等待移位寄存器把数据一位位发送出去 SPI_Delay(SPI_HARD_DELAY); // 软件SPI #elif defined SPI_SOFT uint8_t i = 0x80; do{ LCD_SCK_LOW(); if(byte \u0026amp; i) LCD_SDA_HIGH(); else LCD_SDA_LOW(); SPI_Delay(SPI_SOFT_DELAY); LCD_SCK_HIGH(); SPI_Delay(SPI_SOFT_DELAY); i \u0026gt;\u0026gt;= 1; }while(i \u0026gt; 0); #endif } /** * @brief 发送数据 * @param byte：一个字节 * @retval 无 */ void LCD_SendData(uint8_t byte){ LCD_CS_LOW(); LCD_A0_HIGH(); SPI_Send(byte); LCD_CS_HIGH(); } /** * @brief 发送命令 * @param byte：一个字节 * @retval 无 */ void LCD_SendCmd(uint8_t byte){ LCD_CS_LOW(); LCD_A0_LOW(); SPI_Send(byte); LCD_CS_HIGH(); } /** * @brief 延时 * @param time * @retval */ void SPI_Delay(__IO uint32_t time){ while(time--); } /** * @brief 设置LCD写入地址 * @param page：页地址 * @param column：列地址 * @retval */ void LCD_SetPosition(uint8_t page, uint8_t column){ // 设置页面地址 LCD_SendCmd(0xB0 + page); // 设置列地址高4位 LCD_SendCmd(0x10 + (column \u0026gt;\u0026gt; 4)); // 设置列地址低四位 LCD_SendCmd(0x00 + (column \u0026amp; 0x0F)); } /** * @brief 刷新缓冲区 * @param 无 * @retval 无 */ void LCD_FlushBuffer(void){ uint16_t i, j; for(i = 0; i \u0026lt; LCD_PAGE_NUM; i++){ for(j = 0; j \u0026lt; LCD_COLUMN_NUM; j++){ LCD_SetPosition(i,j); LCD_SendData(LCD_Buffer[i][j]); LCD_Buffer[i][j] = 0x00; } } } /** * @brief 清空缓冲区 * @param 无 * @retval 无 */ void LCD_ClearBuffer(void){ uint16_t i, j; for(i = 0; i \u0026lt; LCD_PAGE_NUM; i++){ for(j = 0; j \u0026lt; LCD_COLUMN_NUM; j++){ LCD_Buffer[i][j] = 0x00; } } } /** * @brief 绘制一串字符 * @param x: 横坐标 * @param y: 纵坐标 * @param height: 字体高度 12、16 * @param str: 字符串指针 * @retval */ void LCD_DrawString(int16_t x, int16_t y, uint8_t height, char* str){ uint8_t i = 0; int16_t xSaevd = x; while(str[i] != \u0026#39;\\0\u0026#39;){ // 判断换行 if(str[i] == \u0026#39;\\n\u0026#39;){ x = xSaevd; y += height; str++; } // 判断GB2312中文编码 else if((uint8_t)str[i] \u0026gt; 0xA0){ //else if((uint8_t)str[i] \u0026amp; 0x80){ if(height \u0026lt; 16){ LCD_DrawHanzi12x12(x, y, str); x += 12; }else if(height \u0026gt;= 16){ LCD_DrawHanzi16x16(x, y, str); x += 16; } str += 2; } // 判断ASCII编码 else if((uint8_t)str[i] \u0026lt; 0x7F){ if(height \u0026lt; 16){ LCD_DrawAscii6x12(x, y, str); x += 6; }else if(height \u0026gt;= 16){ LCD_DrawAscii8x16(x, y, str); x += 8; } str++; }else{ str++; } } } /** * @brief 绘制一个16x16汉字 * @param * @retval */ void LCD_DrawHanzi16x16(int16_t x, int16_t y, char* hanzi){ int16_t page = y / 8; int16_t offset = (8 - ((y + 1) % 8)) % 8; uint32_t temp = 0; uint8_t* p = (uint8_t*)\u0026amp;temp; uint8_t* mask; int16_t i; if(x \u0026lt; 0 - 15 || x \u0026gt; 127 || y \u0026lt; 0 || y \u0026gt; 63 + 15){ return; } if((mask = getHanZi16x16Mask(hanzi)) == 0){ return; } for(i = 0; i \u0026lt; 16; i++){ if(x + i \u0026lt; 0 || x + i \u0026gt; 127){ continue; } temp = 0; p[1] = mask[i]; p[2] = mask[i + 16]; temp = temp \u0026gt;\u0026gt; offset; if(page \u0026gt;= 0){ LCD_Buffer[page][x + i] \u0026amp;= ~(0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page][x + i] |= p[2]; } if(page - 1 \u0026gt;= 0){ LCD_Buffer[page - 1][x + i] = p[1]; } if(page - 2 \u0026gt;= 0){ LCD_Buffer[page - 2][x + i] \u0026amp;= (0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page - 2][x + i] |= p[0]; } } } /** * @brief 绘制一个12x12汉字 * @param * @retval */ void LCD_DrawHanzi12x12(int16_t x, int16_t y, char* hanzi){ int16_t page = (y + 4) / 8; int16_t offset = (8 - ((y + 4 + 1) % 8)) % 8; uint32_t temp = 0; uint8_t* p = (uint8_t*)\u0026amp;temp; uint8_t* mask; int16_t i; if(x \u0026lt; 0 - 11 || x \u0026gt; 127 || y \u0026lt; 0 || y \u0026gt; 63 + 11){ return; } if((mask = getHanZi12x12Mask(hanzi)) == 0){ return; } for(i = 0; i \u0026lt; 12; i++){ if(x + i \u0026lt; 0 || x + i \u0026gt; 127){ continue; } temp = 0; p[1] = mask[i]; p[2] = mask[i + 12]; temp = temp \u0026gt;\u0026gt; offset; if(page \u0026gt;= 0){ LCD_Buffer[page][x + i] \u0026amp;= ~(0x0F \u0026gt;\u0026gt; offset); LCD_Buffer[page][x + i] |= p[2]; } if(page - 1 \u0026gt;= 0){ LCD_Buffer[page - 1][x + i] = p[1]; } if(page - 2 \u0026gt;= 0){ LCD_Buffer[page - 2][x + i] \u0026amp;= (0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page - 2][x + i] |= p[0]; } } } /** * @brief 绘制一个8x16 ascii字符 * @param * @retval */ void LCD_DrawAscii8x16(int16_t x, int16_t y, char* ascii){ int16_t page = y / 8; int16_t offset = (8 - ((y + 1) % 8)) % 8; uint32_t temp = 0; uint8_t* p = (uint8_t*)\u0026amp;temp; uint8_t* mask; int16_t i; if(x \u0026lt; 0 - 7 || x \u0026gt; 127 || y \u0026lt; 0 || y \u0026gt; 63 + 15){ return; } if((mask = getAscii8x16Mask(ascii)) == 0){ return; } for(i = 0; i \u0026lt; 8; i++){ if(x + i \u0026lt; 0 || x + i \u0026gt; 127){ continue; } temp = 0; p[1] = mask[i]; p[2] = mask[i + 8]; temp = temp \u0026gt;\u0026gt; offset; if(page \u0026gt;= 0){ LCD_Buffer[page][x + i] \u0026amp;= ~(0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page][x + i] |= p[2]; } if(page - 1 \u0026gt;= 0){ LCD_Buffer[page - 1][x + i] = p[1]; } if(page - 2 \u0026gt;= 0){ LCD_Buffer[page - 2][x + i] \u0026amp;= (0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page - 2][x + i] |= p[0]; } } } /** * @brief 绘制一个6x12 ascii字符 * @param * @retval */ void LCD_DrawAscii6x12(int16_t x, int16_t y, char* ascii){ int16_t page = (y + 4) / 8; int16_t offset = (8 - ((y + 4 + 1) % 8)) % 8; uint32_t temp = 0; uint8_t* p = (uint8_t*)\u0026amp;temp; uint8_t* mask; int16_t i; if(x \u0026lt; 0 - 5 || x \u0026gt; 127 || y \u0026lt; 0 || y \u0026gt; 63 + 11){ return; } if((mask = getAscii6x12Mask(ascii)) == 0){ return; } for(i = 0; i \u0026lt; 6; i++){ if(x + i \u0026lt; 0 || x + i \u0026gt; 127){ continue; } temp = 0; p[1] = mask[i]; p[2] = mask[i + 6]; temp = temp \u0026gt;\u0026gt; offset; if(page \u0026gt;= 0){ LCD_Buffer[page][x + i] \u0026amp;= ~(0x0F \u0026gt;\u0026gt; offset); LCD_Buffer[page][x + i] |= p[2]; } if(page - 1 \u0026gt;= 0){ LCD_Buffer[page - 1][x + i] = p[1]; } if(page - 2 \u0026gt;= 0){ LCD_Buffer[page - 2][x + i] \u0026amp;= (0xFF \u0026gt;\u0026gt; offset); LCD_Buffer[page - 2][x + i] |= p[0]; } } } /** * @brief 绘制一个点 * @param * @retval */ void LCD_DrawDot(uint8_t x, uint8_t y){ uint8_t page = y / LCD_PAGE_NUM; uint8_t column = x; uint8_t offset = y % LCD_PAGE_NUM; LCD_Buffer[page][column] |= 0x01 \u0026lt;\u0026lt; offset; } font.h #ifndef __FONT_H #define __FONT_H #include \u0026#34;stm32f10x.h\u0026#34; typedef struct{ uint8_t index[2]; uint8_t mask[32]; }HZ16x16_t; #define HanZi16x16_NUM 4 typedef struct{ uint8_t index[2]; uint8_t mask[24]; }HZ12x12_t; #define HanZi12x12_NUM 4 typedef struct{ uint8_t mask[16]; }Ascii8x16_t; #define Ascii8x16_NUM 95 typedef struct{ uint8_t mask[12]; }Ascii6x12_t; #define Ascii6x12_NUM 95 uint8_t* getHanZi12x12Mask(char* str); uint8_t* getHanZi16x16Mask(char* str); uint8_t* getAscii6x12Mask(char* str); uint8_t* getAscii8x16Mask(char* str); #endif font.c #include \u0026#34;font.h\u0026#34; const HZ16x16_t HanZi16x16[HanZi16x16_NUM] = { // 你 ：GB2312十六进制区位码 {0xC4,0xE3, 0x00,0x80,0x60,0xF8,0x07,0x40,0x20,0x18,0x0F,0x08,0xC8,0x08,0x08,0x28,0x18,0x00, 0x01,0x00,0x00,0xFF,0x00,0x10,0x0C,0x03,0x40,0x80,0x7F,0x00,0x01,0x06,0x18,0x00}, // 好\t{0xBA,0xC3, 0x10,0x10,0xF0,0x1F,0x10,0xF0,0x00,0x80,0x82,0x82,0xE2,0x92,0x8A,0x86,0x80,0x00, 0x40,0x22,0x15,0x08,0x16,0x61,0x00,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,0x00}, // 世 {0xCA,0xC0, 0x20,0x20,0x20,0xFE,0x20,0x20,0xFF,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x00, 0x00,0x00,0x00,0x7F,0x40,0x40,0x47,0x44,0x44,0x44,0x47,0x40,0x40,0x40,0x00,0x00}, // 界 {0xBD,0xE7, 0x00,0x00,0x00,0xFE,0x92,0x92,0x92,0xFE,0x92,0x92,0x92,0xFE,0x00,0x00,0x00,0x00, 0x08,0x08,0x04,0x84,0x62,0x1E,0x01,0x00,0x01,0xFE,0x02,0x04,0x04,0x08,0x08,0x00}, }; const HZ12x12_t HanZi12x12[HanZi12x12_NUM] = { // 你 {0xC4,0xE3, 0x20,0x10,0xFC,0x03,0x10,0xCF,0x04,0xF4,0x04,0x54,0x8C,0x00,0x00,0x00,0x0F,0x00, 0x02,0x01,0x08,0x0F,0x00,0x00,0x03,0x00}, // 好 {0xBA,0xC3, 0x88,0x78,0x0F,0x88,0x78,0x42,0x42,0xF2,0x4A,0x46,0x40,0x00,0x08,0x05,0x02,0x05, 0x08,0x00,0x08,0x0F,0x00,0x00,0x00,0x00}, // 世 {0xCA,0xC0, 0x10,0x10,0xFE,0x10,0x10,0xFF,0x10,0x10,0xFF,0x10,0x10,0x00,0x00,0x00,0x0F,0x08, 0x08,0x09,0x09,0x09,0x09,0x08,0x08,0x00}, // 界 {0xBD,0xE7, 0x80,0x9F,0x95,0x55,0x55,0x3F,0x55,0x55,0x95,0x9F,0x80,0x00,0x00,0x08,0x04,0x03, 0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x00}, }; const Ascii8x16_t Ascii8x16[Ascii8x16_NUM] = { {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34; \u0026#34;,0*/ {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00},/*\u0026#34;!\u0026#34;,1*/ {0x00,0x10,0x0C,0x02,0x10,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;\u0026#34;\u0026#34;,2*/ {0x00,0x40,0xC0,0x78,0x40,0xC0,0x78,0x00,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x00},/*\u0026#34;#\u0026#34;,3*/ {0x00,0x70,0x88,0x88,0xFC,0x08,0x30,0x00,0x00,0x18,0x20,0x20,0xFF,0x21,0x1E,0x00},/*\u0026#34;$\u0026#34;,4*/ {0xF0,0x08,0xF0,0x80,0x60,0x18,0x00,0x00,0x00,0x31,0x0C,0x03,0x1E,0x21,0x1E,0x00},/*\u0026#34;%\u0026#34;,5*/ {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x2C,0x19,0x27,0x21,0x10},/*\u0026#34;\u0026amp;\u0026#34;,6*/ {0x00,0x12,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;\u0026#39;\u0026#34;,7*/ {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*\u0026#34;(\u0026#34;,8*/ {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*\u0026#34;)\u0026#34;,9*/ {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*\u0026#34;*\u0026#34;,10*/ {0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x0F,0x01,0x01,0x01},/*\u0026#34;+\u0026#34;,11*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x70,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;,\u0026#34;,12*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00},/*\u0026#34;-\u0026#34;,13*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;.\u0026#34;,14*/ {0x00,0x00,0x00,0x00,0xC0,0x38,0x04,0x00,0x00,0x60,0x18,0x07,0x00,0x00,0x00,0x00},/*\u0026#34;/\u0026#34;,15*/ {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*\u0026#34;0\u0026#34;,16*/ {0x00,0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00},/*\u0026#34;1\u0026#34;,17*/ {0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*\u0026#34;2\u0026#34;,18*/ {0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00},/*\u0026#34;3\u0026#34;,19*/ {0x00,0x00,0x80,0x40,0x30,0xF8,0x00,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x24,0x24},/*\u0026#34;4\u0026#34;,20*/ {0x00,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x20,0x20,0x20,0x11,0x0E,0x00},/*\u0026#34;5\u0026#34;,21*/ {0x00,0xE0,0x10,0x88,0x88,0x90,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x20,0x1F,0x00},/*\u0026#34;6\u0026#34;,22*/ {0x00,0x18,0x08,0x08,0x88,0x68,0x18,0x00,0x00,0x00,0x00,0x3E,0x01,0x00,0x00,0x00},/*\u0026#34;7\u0026#34;,23*/ {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*\u0026#34;8\u0026#34;,24*/ {0x00,0xF0,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x01,0x12,0x22,0x22,0x11,0x0F,0x00},/*\u0026#34;9\u0026#34;,25*/ {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*\u0026#34;:\u0026#34;,26*/ {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00},/*\u0026#34;;\u0026#34;,27*/ {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*\u0026#34;\u0026lt;\u0026#34;,28*/ {0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00},/*\u0026#34;=\u0026#34;,29*/ {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*\u0026#34;\u0026gt;\u0026#34;,30*/ {0x00,0x70,0x48,0x08,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x30,0x37,0x00,0x00,0x00},/*\u0026#34;?\u0026#34;,31*/ {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x28,0x2F,0x28,0x17,0x00},/*\u0026#34;@\u0026#34;,32*/ {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*\u0026#34;A\u0026#34;,33*/ {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*\u0026#34;B\u0026#34;,34*/ {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*\u0026#34;C\u0026#34;,35*/ {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*\u0026#34;D\u0026#34;,36*/ {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*\u0026#34;E\u0026#34;,37*/ {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*\u0026#34;F\u0026#34;,38*/ {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*\u0026#34;G\u0026#34;,39*/ {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*\u0026#34;H\u0026#34;,40*/ {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*\u0026#34;I\u0026#34;,41*/ {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*\u0026#34;J\u0026#34;,42*/ {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},/*\u0026#34;K\u0026#34;,43*/ {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},/*\u0026#34;L\u0026#34;,44*/ {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00},/*\u0026#34;M\u0026#34;,45*/ {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*\u0026#34;N\u0026#34;,46*/ {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*\u0026#34;O\u0026#34;,47*/ {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*\u0026#34;P\u0026#34;,48*/ {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00},/*\u0026#34;Q\u0026#34;,49*/ {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*\u0026#34;R\u0026#34;,50*/ {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*\u0026#34;S\u0026#34;,51*/ {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*\u0026#34;T\u0026#34;,52*/ {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*\u0026#34;U\u0026#34;,53*/ {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*\u0026#34;V\u0026#34;,54*/ {0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00},/*\u0026#34;W\u0026#34;,55*/ {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*\u0026#34;X\u0026#34;,56*/ {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*\u0026#34;Y\u0026#34;,57*/ {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*\u0026#34;Z\u0026#34;,58*/ {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},/*\u0026#34;[\u0026#34;,59*/ {0x00,0x04,0x38,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},/*\u0026#34;\\\u0026#34;,60*/ {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},/*\u0026#34;]\u0026#34;,61*/ {0x00,0x00,0x04,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;^\u0026#34;,62*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},/*\u0026#34;_\u0026#34;,63*/ {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;`\u0026#34;,64*/ {0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x19,0x24,0x24,0x12,0x3F,0x20,0x00},/*\u0026#34;a\u0026#34;,65*/ {0x10,0xF0,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},/*\u0026#34;b\u0026#34;,66*/ {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},/*\u0026#34;c\u0026#34;,67*/ {0x00,0x00,0x80,0x80,0x80,0x90,0xF0,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*\u0026#34;d\u0026#34;,68*/ {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00},/*\u0026#34;e\u0026#34;,69*/ {0x00,0x80,0x80,0xE0,0x90,0x90,0x20,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*\u0026#34;f\u0026#34;,70*/ {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},/*\u0026#34;g\u0026#34;,71*/ {0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*\u0026#34;h\u0026#34;,72*/ {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*\u0026#34;i\u0026#34;,73*/ {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},/*\u0026#34;j\u0026#34;,74*/ {0x10,0xF0,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x06,0x29,0x30,0x20,0x00},/*\u0026#34;k\u0026#34;,75*/ {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*\u0026#34;l\u0026#34;,76*/ {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},/*\u0026#34;m\u0026#34;,77*/ {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*\u0026#34;n\u0026#34;,78*/ {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*\u0026#34;o\u0026#34;,79*/ {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00},/*\u0026#34;p\u0026#34;,80*/ {0x00,0x00,0x00,0x80,0x80,0x00,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0x91,0xFF,0x80},/*\u0026#34;q\u0026#34;,81*/ {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},/*\u0026#34;r\u0026#34;,82*/ {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},/*\u0026#34;s\u0026#34;,83*/ {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x10,0x00},/*\u0026#34;t\u0026#34;,84*/ {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*\u0026#34;u\u0026#34;,85*/ {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x03,0x0C,0x30,0x0C,0x03,0x00,0x00},/*\u0026#34;v\u0026#34;,86*/ {0x80,0x80,0x00,0x80,0x80,0x00,0x80,0x80,0x01,0x0E,0x30,0x0C,0x07,0x38,0x06,0x01},/*\u0026#34;w\u0026#34;,87*/ {0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x20,0x31,0x0E,0x2E,0x31,0x20,0x00},/*\u0026#34;x\u0026#34;,88*/ {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00},/*\u0026#34;y\u0026#34;,89*/ {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},/*\u0026#34;z\u0026#34;,90*/ {0x00,0x00,0x00,0x00,0x00,0xFC,0x02,0x02,0x00,0x00,0x00,0x00,0x01,0x3E,0x40,0x40},/*\u0026#34;{\u0026#34;,91*/ {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*\u0026#34;|\u0026#34;,92*/ {0x02,0x02,0xFC,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x3E,0x01,0x00,0x00,0x00,0x00},/*\u0026#34;}\u0026#34;,93*/ {0x00,0x02,0x01,0x02,0x02,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;~\u0026#34;,94*/ }; const Ascii6x12_t Ascii6x12[Ascii6x12_NUM] = { {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34; \u0026#34;,0*/ {0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00},/*\u0026#34;!\u0026#34;,1*/ {0x00,0x04,0x03,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;\u0026#34;\u0026#34;,2*/ {0x90,0xFC,0x90,0xFC,0x90,0x00,0x00,0x03,0x00,0x03,0x00,0x00},/*\u0026#34;#\u0026#34;,3*/ {0x18,0x24,0xFE,0x44,0x88,0x00,0x01,0x02,0x07,0x02,0x01,0x00},/*\u0026#34;$\u0026#34;,4*/ {0x38,0x44,0xF8,0xD0,0x2C,0xC0,0x00,0x03,0x00,0x01,0x02,0x01},/*\u0026#34;%\u0026#34;,5*/ {0xC0,0x38,0xE4,0x18,0xE0,0x20,0x01,0x02,0x02,0x01,0x02,0x01},/*\u0026#34;\u0026amp;\u0026#34;,6*/ {0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;\u0026#39;\u0026#34;,7*/ {0x00,0x00,0xF8,0x06,0x01,0x00,0x00,0x00,0x00,0x03,0x04,0x00},/*\u0026#34;(\u0026#34;,8*/ {0x00,0x01,0x06,0xF8,0x00,0x00,0x00,0x04,0x03,0x00,0x00,0x00},/*\u0026#34;)\u0026#34;,9*/ {0x90,0x60,0xF8,0x60,0x90,0x00,0x00,0x00,0x01,0x00,0x00,0x00},/*\u0026#34;*\u0026#34;,10*/ {0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;+\u0026#34;,11*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x03,0x00,0x00,0x00,0x00},/*\u0026#34;,\u0026#34;,12*/ {0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;-\u0026#34;,13*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00},/*\u0026#34;.\u0026#34;,14*/ {0x00,0x00,0xC0,0x30,0x0C,0x02,0x04,0x03,0x00,0x00,0x00,0x00},/*\u0026#34;/\u0026#34;,15*/ {0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;0\u0026#34;,16*/ {0x00,0x08,0xFC,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00},/*\u0026#34;1\u0026#34;,17*/ {0x18,0x84,0x44,0x24,0x18,0x00,0x03,0x02,0x02,0x02,0x02,0x00},/*\u0026#34;2\u0026#34;,18*/ {0x08,0x04,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;3\u0026#34;,19*/ {0xC0,0xA0,0x98,0xFC,0x80,0x00,0x00,0x00,0x02,0x03,0x02,0x00},/*\u0026#34;4\u0026#34;,20*/ {0x7C,0x24,0x24,0x24,0xC4,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;5\u0026#34;,21*/ {0xF0,0x48,0x24,0x24,0xC8,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;6\u0026#34;,22*/ {0x00,0x04,0xC4,0x34,0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00},/*\u0026#34;7\u0026#34;,23*/ {0xD8,0x24,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;8\u0026#34;,24*/ {0x38,0x44,0x44,0x24,0xF8,0x00,0x01,0x02,0x02,0x01,0x00,0x00},/*\u0026#34;9\u0026#34;,25*/ {0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00},/*\u0026#34;:\u0026#34;,26*/ {0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00},/*\u0026#34;;\u0026#34;,27*/ {0x00,0x60,0x90,0x08,0x04,0x00,0x00,0x00,0x00,0x01,0x02,0x00},/*\u0026#34;\u0026lt;\u0026#34;,28*/ {0x50,0x50,0x50,0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;=\u0026#34;,29*/ {0x00,0x04,0x08,0x90,0x60,0x00,0x00,0x02,0x01,0x00,0x00,0x00},/*\u0026#34;\u0026gt;\u0026#34;,30*/ {0x18,0x04,0xC4,0x24,0x18,0x00,0x00,0x00,0x02,0x00,0x00,0x00},/*\u0026#34;?\u0026#34;,31*/ {0xF0,0x08,0xE4,0xF4,0x84,0x78,0x00,0x01,0x02,0x02,0x02,0x01},/*\u0026#34;@\u0026#34;,32*/ {0x00,0xE0,0x9C,0xF0,0x80,0x00,0x02,0x03,0x00,0x00,0x03,0x02},/*\u0026#34;A\u0026#34;,33*/ {0x04,0xFC,0x24,0x24,0xD8,0x00,0x02,0x03,0x02,0x02,0x01,0x00},/*\u0026#34;B\u0026#34;,34*/ {0xF8,0x04,0x04,0x04,0x0C,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;C\u0026#34;,35*/ {0x04,0xFC,0x04,0x04,0xF8,0x00,0x02,0x03,0x02,0x02,0x01,0x00},/*\u0026#34;D\u0026#34;,36*/ {0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x02,0x03,0x00},/*\u0026#34;E\u0026#34;,37*/ {0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x00,0x00,0x00},/*\u0026#34;F\u0026#34;,38*/ {0xF0,0x08,0x04,0x44,0xCC,0x40,0x00,0x01,0x02,0x02,0x01,0x00},/*\u0026#34;G\u0026#34;,39*/ {0x04,0xFC,0x20,0x20,0xFC,0x04,0x02,0x03,0x00,0x00,0x03,0x02},/*\u0026#34;H\u0026#34;,40*/ {0x04,0x04,0xFC,0x04,0x04,0x00,0x02,0x02,0x03,0x02,0x02,0x00},/*\u0026#34;I\u0026#34;,41*/ {0x00,0x04,0x04,0xFC,0x04,0x04,0x0C,0x08,0x08,0x07,0x00,0x00},/*\u0026#34;J\u0026#34;,42*/ {0x04,0xFC,0x24,0x50,0x8C,0x04,0x02,0x03,0x02,0x00,0x03,0x02},/*\u0026#34;K\u0026#34;,43*/ {0x04,0xFC,0x04,0x00,0x00,0x00,0x02,0x03,0x02,0x02,0x02,0x03},/*\u0026#34;L\u0026#34;,44*/ {0xFC,0x3C,0xC0,0x3C,0xFC,0x04,0x03,0x00,0x03,0x00,0x03,0x02},/*\u0026#34;M\u0026#34;,45*/ {0x04,0xFC,0x30,0xC4,0xFC,0x04,0x02,0x03,0x02,0x00,0x03,0x00},/*\u0026#34;N\u0026#34;,46*/ {0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;O\u0026#34;,47*/ {0x04,0xFC,0x24,0x24,0x18,0x00,0x02,0x03,0x02,0x00,0x00,0x00},/*\u0026#34;P\u0026#34;,48*/ {0xF8,0x84,0x84,0x04,0xF8,0x00,0x01,0x02,0x02,0x07,0x05,0x00},/*\u0026#34;Q\u0026#34;,49*/ {0x04,0xFC,0x24,0x64,0x98,0x00,0x02,0x03,0x02,0x00,0x03,0x02},/*\u0026#34;R\u0026#34;,50*/ {0x18,0x24,0x24,0x44,0x8C,0x00,0x03,0x02,0x02,0x02,0x01,0x00},/*\u0026#34;S\u0026#34;,51*/ {0x0C,0x04,0xFC,0x04,0x0C,0x00,0x00,0x02,0x03,0x02,0x00,0x00},/*\u0026#34;T\u0026#34;,52*/ {0x04,0xFC,0x00,0x00,0xFC,0x04,0x00,0x01,0x02,0x02,0x01,0x00},/*\u0026#34;U\u0026#34;,53*/ {0x04,0x7C,0x80,0xE0,0x1C,0x04,0x00,0x00,0x03,0x00,0x00,0x00},/*\u0026#34;V\u0026#34;,54*/ {0x3C,0xC0,0x7C,0xC0,0x3C,0x00,0x00,0x03,0x00,0x03,0x00,0x00},/*\u0026#34;W\u0026#34;,55*/ {0x04,0x9C,0x60,0x9C,0x04,0x00,0x02,0x03,0x00,0x03,0x02,0x00},/*\u0026#34;X\u0026#34;,56*/ {0x04,0x3C,0xC0,0x3C,0x04,0x00,0x00,0x02,0x03,0x02,0x00,0x00},/*\u0026#34;Y\u0026#34;,57*/ {0x0C,0x84,0x64,0x1C,0x04,0x00,0x02,0x03,0x02,0x02,0x03,0x00},/*\u0026#34;Z\u0026#34;,58*/ {0x00,0x00,0xFF,0x01,0x01,0x00,0x00,0x00,0x07,0x04,0x04,0x00},/*\u0026#34;[\u0026#34;,59*/ {0x00,0x06,0x38,0xC0,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x00},/*\u0026#34;\\\u0026#34;,60*/ {0x00,0x01,0x01,0xFF,0x00,0x00,0x00,0x04,0x04,0x07,0x00,0x00},/*\u0026#34;]\u0026#34;,61*/ {0x00,0x02,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;^\u0026#34;,62*/ {0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08},/*\u0026#34;_\u0026#34;,63*/ {0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;`\u0026#34;,64*/ {0x00,0x40,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x03,0x02},/*\u0026#34;a\u0026#34;,65*/ {0x02,0xFE,0x20,0x20,0xC0,0x00,0x00,0x03,0x02,0x02,0x01,0x00},/*\u0026#34;b\u0026#34;,66*/ {0x00,0xC0,0x20,0x20,0x60,0x00,0x00,0x01,0x02,0x02,0x01,0x00},/*\u0026#34;c\u0026#34;,67*/ {0x00,0xC0,0x20,0x22,0xFE,0x00,0x00,0x01,0x02,0x02,0x03,0x02},/*\u0026#34;d\u0026#34;,68*/ {0x00,0xC0,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x02,0x00},/*\u0026#34;e\u0026#34;,69*/ {0x00,0x20,0xFC,0x22,0x22,0x04,0x00,0x02,0x03,0x02,0x02,0x00},/*\u0026#34;f\u0026#34;,70*/ {0x00,0x40,0xA0,0xA0,0x60,0x20,0x00,0x05,0x0A,0x0A,0x0A,0x04},/*\u0026#34;g\u0026#34;,71*/ {0x02,0xFE,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02},/*\u0026#34;h\u0026#34;,72*/ {0x00,0x20,0xE6,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00},/*\u0026#34;i\u0026#34;,73*/ {0x00,0x00,0x20,0xE6,0x00,0x00,0x08,0x08,0x08,0x07,0x00,0x00},/*\u0026#34;j\u0026#34;,74*/ {0x02,0xFE,0x80,0x60,0x20,0x00,0x02,0x03,0x00,0x01,0x02,0x00},/*\u0026#34;k\u0026#34;,75*/ {0x02,0x02,0xFE,0x00,0x00,0x00,0x02,0x02,0x03,0x02,0x02,0x00},/*\u0026#34;l\u0026#34;,76*/ {0xE0,0x20,0xE0,0x20,0xC0,0x00,0x03,0x00,0x03,0x00,0x03,0x00},/*\u0026#34;m\u0026#34;,77*/ {0x20,0xE0,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02},/*\u0026#34;n\u0026#34;,78*/ {0x00,0xC0,0x20,0x20,0xC0,0x00,0x00,0x01,0x02,0x02,0x01,0x00},/*\u0026#34;o\u0026#34;,79*/ {0x20,0xE0,0x20,0x20,0xC0,0x00,0x08,0x0F,0x0A,0x02,0x01,0x00},/*\u0026#34;p\u0026#34;,80*/ {0x00,0xC0,0x20,0x20,0xE0,0x00,0x00,0x01,0x02,0x0A,0x0F,0x08},/*\u0026#34;q\u0026#34;,81*/ {0x20,0xE0,0x40,0x20,0x20,0x00,0x02,0x03,0x02,0x00,0x00,0x00},/*\u0026#34;r\u0026#34;,82*/ {0x00,0x60,0xA0,0xA0,0x20,0x00,0x00,0x02,0x02,0x02,0x03,0x00},/*\u0026#34;s\u0026#34;,83*/ {0x00,0x20,0xF8,0x20,0x20,0x00,0x00,0x00,0x03,0x02,0x02,0x00},/*\u0026#34;t\u0026#34;,84*/ {0x20,0xE0,0x00,0x20,0xE0,0x00,0x00,0x01,0x02,0x02,0x03,0x02},/*\u0026#34;u\u0026#34;,85*/ {0x20,0xE0,0x00,0xE0,0x20,0x00,0x00,0x00,0x03,0x00,0x00,0x00},/*\u0026#34;v\u0026#34;,86*/ {0x60,0x80,0xE0,0x80,0x60,0x00,0x00,0x03,0x00,0x03,0x00,0x00},/*\u0026#34;w\u0026#34;,87*/ {0x20,0x60,0x80,0x60,0x20,0x00,0x02,0x03,0x00,0x03,0x02,0x00},/*\u0026#34;x\u0026#34;,88*/ {0x20,0xE0,0x00,0x00,0xE0,0x20,0x08,0x08,0x05,0x03,0x00,0x00},/*\u0026#34;y\u0026#34;,89*/ {0x00,0x20,0xA0,0x60,0x20,0x00,0x00,0x02,0x03,0x02,0x02,0x00},/*\u0026#34;z\u0026#34;,90*/ {0x00,0x00,0x20,0xFF,0x01,0x00,0x00,0x00,0x00,0x07,0x04,0x00},/*\u0026#34;{\u0026#34;,91*/ {0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00},/*\u0026#34;|\u0026#34;,92*/ {0x00,0x01,0xDF,0x20,0x00,0x00,0x00,0x04,0x07,0x00,0x00,0x00},/*\u0026#34;}\u0026#34;,93*/ {0x02,0x01,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*\u0026#34;~\u0026#34;,94*/ }; /** * @brief 获取12x12大小汉字的点阵数据指针 * @param str：字符指针 * @retval 返回点阵数据首字节地址 */ uint8_t* getHanZi12x12Mask(char* str){ uint16_t i; for(i = 0; i \u0026lt; HanZi12x12_NUM; i++){ if(str[0] == HanZi12x12[i].index[0] \u0026amp;\u0026amp; str[1] == HanZi12x12[i].index[1]){ return (uint8_t*)HanZi12x12[i].mask; } } return 0; } /** * @brief 获取16x16大小汉字的点阵数据指针 * @param str：字符指针 * @retval 返回点阵数据首字节地址 */ uint8_t* getHanZi16x16Mask(char* str){ uint16_t i; for(i = 0; i \u0026lt; HanZi16x16_NUM; i++){ if(str[0] == HanZi16x16[i].index[0] \u0026amp;\u0026amp; str[1] == HanZi16x16[i].index[1]){ return (uint8_t*)HanZi16x16[i].mask; } } return 0; } /** * @brief 获取6x12大小Ascii的点阵数据指针 * @param str：字符指针 * @retval 返回点阵数据首字节地址 */ uint8_t* getAscii6x12Mask(char* str){ int16_t i = *str - 0x20; if(i\u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; Ascii6x12_NUM){ return (uint8_t*)Ascii6x12[i].mask; } return 0; } /** * @brief 获取8x16大小Ascii的点阵数据指针 * @param str：字符指针 * @retval 返回点阵数据首字节地址 */ uint8_t* getAscii8x16Mask(char* str){ int16_t i = *str - 0x20; if(i\u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; Ascii8x16_NUM){ return (uint8_t*)Ascii8x16[i].mask; } return 0; } ","permalink":"https://kingtuo123.com/posts/lcd12864-st7565r/","summary":"stm32 st7565r spi 驱动程序","title":"LCD12864 ST7565R"},{"content":"SPI 基本通讯过程 SCK： 串行时钟信号，由主机产生发送给从机\nMOSI：发送：主机输出，从机输入\nMISO：接收：主机输入，从机输出\nCS： 片选信号，通讯时拉低\nSPI 时钟 时钟极性 Clock Polarity （CPOL）\nCPOL = 0 ，SCK 空闲时低电平 CPOL = 1 ，SCK 空闲时高电平 时钟相位 Clock Phase （CPHA）\nCPHA = 0，SCK 的第一个（奇数个）跳变沿采样数据 CPHA = 1，SCK 的第二个（偶数个）跳变沿采样数据 SPI 模式 SPI 模式 CPOL CPHA SCK 空闲电平 采样沿 0 0 0 低电平 上升沿 1 0 1 低电平 下降沿 2 1 0 高电平 下降沿 3 1 1 高电平 上升沿 SPI 读写 Flash 硬件\nSTM32F103ZET6 Flash：W25Q64JV Flash 写前需要先擦除。因为 Flash 只能将 1 写为 0，而不能将 0 写为 1。擦除后 flash 全是 1。\nSPI 发送的 Dummy_Byte 是无用数据，只是为了产生时钟信号以读取数据。\nbsp_flash.h /* * flash 型号 W25Q64JV 64M-bit ------------------------------------------------------------------- | 容量 | 扇区大小 | 扇区数量 | 页面大小 | 扇区页面数量 | 页面总数 | ------------------------------------------------------------------- | 8 MB | 4 KB | 2048 | 256 byte | 16 | 32768 | ------------------------------------------------------------------- */ #ifndef __BSP_FLASH_H #define __BSP_FLASH_H #include \u0026#34;stm32f10x.h\u0026#34; #define FLASH_SPIx SPI1 #define FLASH_SPI_APBxClock_FUN RCC_APB2PeriphClockCmd #define FLASH_SPI_CLK RCC_APB2Periph_SPI1 #define FLASH_PIN_APBxClock_FUN RCC_APB2PeriphClockCmd // CS(NSS)引脚 片选选普通GPIO即可 #define FLASH_SPI_CS_CLK RCC_APB2Periph_GPIOA #define FLASH_SPI_CS_PORT GPIOA #define FLASH_SPI_CS_PIN GPIO_Pin_4 // SCK引脚 #define FLASH_SPI_SCK_CLK RCC_APB2Periph_GPIOA #define FLASH_SPI_SCK_PORT GPIOA #define FLASH_SPI_SCK_PIN GPIO_Pin_5 // MISO引脚 #define FLASH_SPI_MISO_CLK RCC_APB2Periph_GPIOA #define FLASH_SPI_MISO_PORT GPIOA #define FLASH_SPI_MISO_PIN GPIO_Pin_6 // MOSI引脚 #define FLASH_SPI_MOSI_CLK RCC_APB2Periph_GPIOA #define FLASH_SPI_MOSI_PORT GPIOA #define FLASH_SPI_MOSI_PIN GPIO_Pin_7 // 片选电平控制 #define FLASH_SPI_CS_LOW() GPIO_ResetBits( FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN ) #define FLASH_SPI_CS_HIGH() GPIO_SetBits( FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN ) // 页面大小，W25Q64JV不能跨页写 #define FLASH_PAGE_SIZE 256 // 扇区大小 #define FLASH_SECTOR_SIZE 4096 // 扇区数量 #define FLASH_SECTOR_COUNT 2048 // 等待超时时间，如果读写数据异常适当调整 #define FLASH_FLAG_TIMEOUT ((uint32_t)0x10000) #define FLASH_BUSY_TIMEOUT ((uint32_t)0x100000) // FLASH芯片状态寄存器1的BUSY标志位 #define FLASH_BUSY_FLAG 0x01 #define Dummy_Byte 0xFF // FLASH指令 #define WRITE_ENABLE 0x06 #define WRITE_DISABLE 0x04 #define READ_SR1 0x05 #define READ_DATA 0x03 #define PAGE_PROGRAM 0x02 #define SECOTR_ERASE 0x20 #define CHIP_ERASE 0xC7 #define JEDEC_ID 0x9F void FLASH_Init(void); uint32_t FLASH_ReadJedecID(void); void FLASH_Write(uint32_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite); void FLASH_Read(uint32_t ReadAddr, uint8_t* pBuffer, uint16_t NumByteToRead); void FLASH_SectorErase(uint32_t SectorAddr); void FLASH_ChipErase(void); static uint8_t FLASH_SendByte(uint8_t byte); static void FLASH_WriteEnable(void); static uint8_t FLASH_WaitForWriteEnd(void); static void FLASH_PageWrite(uint32_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite); #endif bsp_falsh.c #include \u0026#34;bsp_flash.h\u0026#34; /** * @brief FLASH初始化 * @param 无 * @retval 无 */ void FLASH_Init(void){ SPI_InitTypeDef SPI_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; // 使能SPI时钟 FLASH_SPI_APBxClock_FUN ( FLASH_SPI_CLK, ENABLE ); // 使能SPI引脚相关的时钟 FLASH_PIN_APBxClock_FUN(FLASH_SPI_CS_CLK| FLASH_SPI_SCK_CLK| FLASH_SPI_MISO_PIN| FLASH_SPI_MOSI_PIN, ENABLE ); // CS引脚，普通IO即可 GPIO_InitStructure.GPIO_Pin = FLASH_SPI_CS_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(FLASH_SPI_CS_PORT, \u0026amp;GPIO_InitStructure); // SCK引脚 GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(FLASH_SPI_SCK_PORT, \u0026amp;GPIO_InitStructure); // MISO引脚 GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MISO_PIN; GPIO_Init(FLASH_SPI_MISO_PORT, \u0026amp;GPIO_InitStructure); // MOSI引脚 GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MOSI_PIN; GPIO_Init(FLASH_SPI_MOSI_PORT, \u0026amp;GPIO_InitStructure); // 停止信号 FLASH: CS引脚高电平 FLASH_SPI_CS_HIGH(); // SPI配置 // 双线双向全双工 SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; // 主机模式 SPI_InitStructure.SPI_Mode = SPI_Mode_Master; // 数据帧长度8bit SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; // 时钟极性，SCK空闲时高电平 SPI_InitStructure.SPI_CPOL = SPI_CPOL_High; // 时钟相位，在SCK的第二(偶数)个跳变沿采样 SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; // 软件控制CS脚 SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; // SCK时钟频率，PLCK2/4=72/4=18MHz SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; // 数据传输时高位先行 SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; // CRC校验的多项式，对应X0+X1+X2,是CRC-8校验类型 SPI_InitStructure.SPI_CRCPolynomial = 7; // 初始化SPI SPI_Init(FLASH_SPIx, \u0026amp;SPI_InitStructure); // 使能SPI SPI_Cmd(FLASH_SPIx, ENABLE); } /** * @brief 使用SPI发送一个字节的数据 * @param byte：要发送的数据 * @retval 返回接收到的数据 */ static uint8_t FLASH_SendByte(uint8_t byte){ __IO uint32_t SPITimeout = FLASH_FLAG_TIMEOUT; // 等待发送缓冲区为空，TXE事件 while(SPI_I2S_GetFlagStatus(FLASH_SPIx , SPI_I2S_FLAG_TXE) == RESET){ if((SPITimeout--) == 0) return 0xFF; } // 写入数据寄存器，把要写入的数据写入发送缓冲区 SPI_I2S_SendData(FLASH_SPIx , byte); SPITimeout = FLASH_FLAG_TIMEOUT; // 等待接收缓冲区非空，RXNE事件 while (SPI_I2S_GetFlagStatus(FLASH_SPIx , SPI_I2S_FLAG_RXNE) == RESET){ if((SPITimeout--) == 0) return 0xFF; } return SPI_I2S_ReceiveData(FLASH_SPIx ); } /** * @brief 读取FLASH Jedec ID * @param 无 * @retval Jedec ID */ uint32_t FLASH_ReadJedecID(void){ uint8_t Temp[]={0,0,0,0}; FLASH_SPI_CS_LOW(); FLASH_SendByte(JEDEC_ID); Temp[2] = FLASH_SendByte(Dummy_Byte); Temp[1] = FLASH_SendByte(Dummy_Byte); Temp[0] = FLASH_SendByte(Dummy_Byte); FLASH_SPI_CS_HIGH(); return *(uint32_t *)Temp; } /** * @brief 读取FLASH数据 * @param ReadAddr，读取地址 * @param pBuffer，存储读出数据的指针 * @param NumByteToRead，读取数据长度 * @retval 无 */ void FLASH_Read(uint32_t ReadAddr, uint8_t* pBuffer, uint16_t NumByteToRead){ uint8_t* Addr = (uint8_t*)\u0026amp;ReadAddr; FLASH_SPI_CS_LOW(); FLASH_SendByte(READ_DATA); FLASH_SendByte(Addr[2]); FLASH_SendByte(Addr[1]); FLASH_SendByte(Addr[0]); while (NumByteToRead--){ *pBuffer++ = FLASH_SendByte(Dummy_Byte); } FLASH_SPI_CS_HIGH(); } /** * @brief FLASH写入指定个字节，调用本函数写入数据前需要先擦除扇区 * @param ReadAddr，写地址 * @param pBuffer，存储数据的指针 * @param NumByteToWrite，数据长度 * @retval 无 */ void FLASH_Write(uint32_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite){ uint32_t WriteLen, PageOffset; while(NumByteToWrite \u0026gt; 0){ // 计算当前页能写入的字节数 PageOffset = FLASH_PAGE_SIZE - (WriteAddr % FLASH_PAGE_SIZE); WriteLen = NumByteToWrite \u0026gt; PageOffset ? PageOffset : NumByteToWrite; FLASH_PageWrite(WriteAddr, pBuffer, WriteLen); NumByteToWrite -= WriteLen; if(NumByteToWrite \u0026gt; 0){ pBuffer += WriteLen; WriteAddr += WriteLen; } } } /** * @brief 对FLASH按页写入数据 * @param WriteAddr，写入地址 * @param pBuffer，要写入数据的指针 * @param NumByteToWrite，写入数据长度 * @retval 无 */ static void FLASH_PageWrite(uint32_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite){ uint8_t* Addr = (uint8_t*)\u0026amp;WriteAddr; FLASH_WriteEnable(); FLASH_SPI_CS_LOW(); FLASH_SendByte(PAGE_PROGRAM); FLASH_SendByte(Addr[2]); FLASH_SendByte(Addr[1]); FLASH_SendByte(Addr[0]); while(NumByteToWrite--){ FLASH_SendByte(*pBuffer++); } FLASH_SPI_CS_HIGH(); FLASH_WaitForWriteEnd(); } /** * @brief 等待SR1 BUSY标志被置0，即等待到FLASH内部数据写入完毕 * @param 无 * @retval 无 */ static uint8_t FLASH_WaitForWriteEnd(void){ __IO uint32_t SPITimeout = FLASH_BUSY_TIMEOUT; FLASH_SPI_CS_LOW(); FLASH_SendByte(READ_SR1); while((FLASH_SendByte(Dummy_Byte) \u0026amp; FLASH_BUSY_FLAG) == SET){ if(SPITimeout-- == 0) return 0xFF; } FLASH_SPI_CS_HIGH(); return 0; } /** * @brief 擦除FLASH扇区 * @param SectorAddr：地址在要擦除的扇区内就行 * @retval 无 */ void FLASH_SectorErase(uint32_t SectorAddr){ uint8_t* Addr = (uint8_t*)\u0026amp;SectorAddr; FLASH_WriteEnable(); FLASH_SPI_CS_LOW(); FLASH_SendByte(SECOTR_ERASE); FLASH_SendByte(Addr[2]); FLASH_SendByte(Addr[1]); FLASH_SendByte(Addr[0]); FLASH_SPI_CS_HIGH(); FLASH_WaitForWriteEnd(); } /** * @brief FLASH整片擦除 * @param 无 * @retval 无 */ void FLASH_ChipErase(void){ FLASH_WriteEnable(); FLASH_SPI_CS_LOW(); FLASH_SendByte(CHIP_ERASE); FLASH_SPI_CS_HIGH(); FLASH_WaitForWriteEnd(); } /** * @brief 向FLASH发送 写使能 命令 * @param 无 * @retval 无 */ static void FLASH_WriteEnable(void){ FLASH_SPI_CS_LOW(); FLASH_SendByte(WRITE_ENABLE); FLASH_SPI_CS_HIGH(); } ","permalink":"https://kingtuo123.com/posts/stm32-spi/","summary":"SPI 通讯及 W25Q64JV Flash 驱动","title":"STM32 SPI"},{"content":"10.1 引言 信号是软中断。信号提供了一种处理异步事件的方法。\n10.2 信号概念 信号名字都以3个字符 SIG 开头。\n在头文件 \u0026lt;signal.h\u0026gt; 中，信号名都被定义为正整数常量（信号编号）。\n不存在编号为0的信号。\n信号的处理：\n忽略此信号。SIGKILL 和 SIGSTOP 不能被忽略，原因：它们向内核和超级用户提供了使进程终止或停止的可靠方法。 捕捉信号。不能捕捉 SIGKILL 和 SIGSTOP 信号。 执行系统默认动作。见图10-1 kill 命令默认发送 SIGTERM 终止信号。查看所有信号：\n$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM ... 使用 kill 命令给进程发送指定信号：\n$ kill -9 pid $ kill -SIGKILL pid 10.3 函数 signal #include \u0026lt;signal.h\u0026gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); /* signal() returns the previous value of the signal handler. * On failure, it returns SIG_ERR, and errno is set to indicate the error. */ sighandler_t 是函数指针类型，该函数有一个 int 型的参数，返回值为空。\nsignum 参数是图10-1中的信号名。handler 的值是常量 SIG_IGN，SIG_DFL 或接受到此信号后要调用的函数的地址。\nsignal() 返回值类型和第二参数的类型都是 sighandler_t，若成功则返回上一个 handler，失败返回 SIG_ERR。\n\u0026lt;signal.h\u0026gt; 可能会有以下形式的声明，大多数 UNIX 系统使用以下的值：\n#define SIG_ERR (void (*)())-1 #define SIG_DFL (void (*)())0 #define SIG_IGN (void (*)())1 以下是 signal 函数简单的示例：\n#include \u0026#34;apue.h\u0026#34; static void sig_usr(int); /* one handler for both signals */ int main(void) { if (signal(SIGUSR1, sig_usr) == SIG_ERR) err_sys(\u0026#34;can\u0026#39;t catch SIGUSR1\u0026#34;); if (signal(SIGUSR2, sig_usr) == SIG_ERR) err_sys(\u0026#34;can\u0026#39;t catch SIGUSR2\u0026#34;); for ( ; ; ) pause(); } static void sig_usr(int signo) /* argument is signal number */ { if (signo == SIGUSR1) printf(\u0026#34;received SIGUSR1\\n\u0026#34;); else if (signo == SIGUSR2) printf(\u0026#34;received SIGUSR2\\n\u0026#34;); else err_dump(\u0026#34;received signal %d\\n\u0026#34;, signo); } $ ./a.out \u0026amp; [1] 27897 $ kill -SIGUSR1 27897 received SIGUSR1 $ kill -SIGUSR2 27897 received SIGUSR2 $ kill -SIGTERM 27897 [1]+ Terminated ./a.out 1. 程序启动\n当你在终端执行：\n$ cc main.c \u0026amp; shell 自动将进程 cc 对中断信号（SIGINT）和退出信号（SIGQUIT）的处理方式设置为忽略（SIG_IGN）。于是，当按下中断字符（ctrl+c）时就不会影响到后台进程。\n很多捕捉这两个信号的交互程序有以下形式的代码：\nvoid sig_int(void), sig_quit(void); if (signal(SIGINT, SIG_IGN) != SIG_IGN) signal(SIGINT,sig_int); if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) signal(SIGQUIT,sig_quit); 这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。\n2. 进程创建\n当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。\n10.4 不可靠信号 略\n10.5 中断的系统调用 早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。\n假设一个读操作被中断，我们希望重新启动它：\nagain: if ((n = read(fd, buf, BUFFSIZE)) \u0026lt; 0) if (errno == EINTR) goto again; /* handle other errors*/ 为了帮助程序不必处理中断的系统调用，4.2BSD 引进了某些自动重启的系统调用 (ioctl, read, readv, write, writev, wait, waitpid)。\nPOSIX.1 要求只有中断信号的 SA_RESTART 标志有效时，实现才重启系统调用。sigaction 函数使用这个标志允许应用程序重启被中断的系统调用。\nFreeBSD8.0、Linux3.2.0、Mac OS X10.6.8中，当信号处理程序是用 signal 函数时，被中断的系统调用会重启动。\n10.6 可重入函数 信号是异步的，它会在程序的任何地方发生。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号 而插入执行该信号处理程序，其中又调用 malloc，这时可能会对进程造成破坏。\n可重入函数是在信号处理程序中保证调用安全的函数，被称为异步信号安全的（async-signal safe）。如图10-4\n在信号处理程序中调用一个非可重入函数，其结果是不可预知的。\n10.7 SIGCLD 语义 说说SIGCLD和SIGCHLD\n10.8 可靠信号术语和语义 略\n10.9 函数 kill 和 raise kill 函数将信号发送给进程或进程组。raise 函数则允许进程向自身发送信号。\n#include \u0026lt;signal.h\u0026gt; int kill(pid_t pid, int signo); int raise(int signo); raise(signo) 与 kill(getpid(), signo) 等价。\nkill 的 pid 参数有以下4种情况：\npid \u0026gt; 0 : 将信号发送给进程 ID 为 pid 的进程 pid == 0 : 将信号发送给与发送进程属于同一进程组的所有进程 pid \u0026lt; 0 : 将信号发送给进程组 id 为 pid 绝对值的所有进程 pid == -1 : 将信号发送给发送进程有权限向它们发送信号的所有进程 10.10 函数 alarm 和 pause #include \u0026lt;unistd.h\u0026gt; // 返回值：0或以前设置的闹钟时间的余留秒数 unsigned int alarm(unsigned int seconds); // 返回值：-1，errno 设置为 EINTR int pause(void); 每个进程只能有一个闹钟时间，重复调用 alarm 会覆盖之前的闹钟时间，alarm(0) 会取消计时。闹钟时间到后会发送 SIGALRM 信号。\npause 函数使调用进程挂起直至捕捉到一个信号。且只有执行了一个信号处理程序并从其返回时，pause 才返回。\n10.11 信号集 信号集（signal set）：能表示多个信号的数据类型。POSIX.1 定义数据类型 sigset_t 以包含一个信号集。\n信号集处理函数：\n#include \u0026lt;signal.h\u0026gt; // 初始化由set指向的信号集，清除其中所有信号。 int sigemptyset(sigset_t *set); // 初始化由set指向的信号集，使其包括所有信号。 int sigfillset(sigset_t *set); // 添加一个信号至信号集。 int sigaddset(sigset_t *set, int signum); // 从信号集删除一个信号。 int sigdelset(sigset_t *set, int signum); // 测试信号是否属于信号集。 int sigismember(const sigset_t *set, int signum); 使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。\n10.12 函数 sigprocmask 每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。\n#include \u0026lt;signal.h\u0026gt; // 成功返回0，出错-1 int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oldset); 若 oldset 是非空指针，则 oldset 用于保存当前的信号屏蔽字。\n若 set 是非空指针，则参数 how 指示如何修改当前信号屏蔽字。\nhow 说明 SIG_BLOCK set 包含了希望阻塞的附加信号 SIG_UNBLOCK set 包含了希望解除阻塞的信号 SIG_SETMASK 该进程新的信号屏蔽是 set 指向的值 如果 set 是空指针，则不改变信号屏蔽字，how 的值也无意义。可以用 sigprocmask(0, NULL, \u0026amp;oldset) \u0026lt; 0 测试当前进程是否设置了屏蔽字。\n在调用 sigprocmask 后，如果有任何未决的（pending）、不再阻塞的信号，则在 sigprocmask 返回之前，会至少将其中之一递送给该进程。\n10.13 函数 sigpending 通过 set 参数返回未决的（未递送）信号集。\n#include \u0026lt;signal.h\u0026gt; // 成功返回0，出错-1 int sigpending(sigset_t *set); 如果程序阻塞期间产生多个同一信号，解除阻塞后信号只递交一次（类似位图的机制，只有0|1）。\n10.14 函数 sigaction sigaction 函数的功能是检查或修改与指定信号相关联的处理动作。\n#include \u0026lt;signal.h\u0026gt; // 成功返回0，出错-1 int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oldact); signo，信号编号。act，结构体指针，如下：\nstruct sigaction { // 信号处理函数的地址，SIG_IGN，SIG_DFL void (*sa_handler)(int); // 调用信号处理程序时，需要阻塞的信号 sigset_t sa_mask; // 信号处理选项，见下图 int sa_flags; // 一个替代的信号处理程序，需在 sa_flags 中启用 SA_SIGINFO void (*sa_sigaction)(int, siginfo_t *, void *); }; 通常，按下列方式调用信号处理程序：\nvoid handler(int signo); 但是，如果设置了 SA_SIGINFO 标志，那么按下列方式调用信号处理程序：\nvoid handler(int signo, siginfo_t *info, void *context); info 结构体指针包含了信号产生原因的有关信息。\ncontext 是无类型指针，可强制转换为　ucontext_t 结构类型，包含信号传递时进程上下文内容。\n10.15 函数 sigsetjmp 和 siglongjmp #include \u0026lt;setjmp.h\u0026gt; // 返回值：直接调用返回0；若从 siglongjmp 调用返回，则返回非0 （val）。 int sigsetjmp(sigjmp_buf env, int savemask); void siglongjmp(sigjmp_buf env, int val); 这两个函数类似 setjmp 和 longjmp，只多了一个 savemask 参数。若 savemask 非0，则调用 sigsetjmp 时会保存当前信号屏蔽字至 env，在调用 siglongjmp 后恢复保存的屏蔽字。\n当调用一个信号处理程序时，被捕捉到的信号会添加到信号屏蔽字中（执行信号处理程序时屏蔽该信号），返回时恢复原来的屏蔽字。相关：10.14 节 SA_NODEFER 选项\n10.16 函数 sigsuspend #include \u0026lt;signal.h\u0026gt; // 返回值：只返回-1，并设置 errno（通常是 EINTR） int sigsuspend(const sigset_t *sigmask); 调用时挂起进程，信号屏蔽字设置为 sigmask 指向的值，捕捉到信号后返回，并恢复调用前的屏蔽字。\n10.17 函数 abort 此函数将 SIGABRT 信号发送给调用进程，使程序异常终止。\n#include \u0026lt;stdlib.h\u0026gt; void abort(void); SIGABRT 信号默认动作是 终止+core\nSIGABRT 信号不能被忽略，即使用了信号屏蔽字。因为 abort 函数内部的实现已确保该信号不可被忽略和屏蔽。\nSIGABRT 信号如果被注册了一个信号处理函数例如 handler_abrt ，当调用 abort 函数，进程捕获到 SIGABRT 信号后，先执行 handler_abrt 函数，若 handler_abrt 没有终止自己，返回 abort 函数后，abort 函数内部将 SIGABRT 改为默认动作，然后重新发送 SIGABRT 信号，进程终止。\n10.18 函数 system system 在第8章有提到不再赘述，书中这里讲的是 system 函数 POSIX.1 的实现。\n10.19 函数 sleep、nanosleep 和 clock_nanosleep #include \u0026lt;unistd.h\u0026gt; // 返回值：0 或 未休眠完的秒数 unsigned int sleep(unsigned int seconds); 注意：sleep 计时并不精准，会被信号处理程序打断(直接返回了)。\nnanosleep 提供了纳秒级的精度。clock_nanosleep 相对于特定时钟的延迟。\n#include \u0026lt;time.h\u0026gt; // 返回值：若休眠到要求时间，返回0；若出错，返回-1 int nanosleep(const struct timespec *req, struct timespec *_Nullable rem); // 返回值：若休眠到要求时间，返回0；若出错，返回错误码 int clock_nanosleep(clockid_t clockid, int flags, const struct timespec *request, struct timespec *_Nullable remain); 10.20 函数 sigqueue 转自csdn：sigqueue 函数\n10.21 作业控制信号 POSIX.1 认为有以下6中信号与作业控制有关：\nSIGCHLD 子进程已停止或终止 SIGCONT 如果进程已停止，则使其继续运行 SIGSTOP 停止信号（不能被捕捉或忽略） SIGTSTP 交互式停止信号（Ctrl+z） SIGTTIN 后台进程组成员读控制终端 SIGTTOU 后台进程组成员写控制终端 ","permalink":"https://kingtuo123.com/posts/apue-chapter10-note/","summary":"apue 第10章 学习笔记","title":"APUE 第10章 信号"},{"content":"Dockerfile 创建 Dockerfile ：\nFROM ubuntu:latest LABEL author=\u0026#34;king\u0026#34; EXPOSE 1313 RUN set -ex \u0026amp;\u0026amp; \\ sed -i s@/archive.ubuntu.com/@/mirrors.tuna.tsinghua.edu.cn/@g /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt clean \u0026amp;\u0026amp; \\ apt update \u0026amp;\u0026amp; \\ apt -y install hugo WORKDIR /src/hugo CMD hugo server --bind 0.0.0.0 hugo 必须 --bind 绑定 0.0.0.0。 0.0.0.0 代表的是本机所有ip地址，不管你有多少个网口，多少个ip，如果监听本机的 0.0.0.0 上的端口，就等于监听机器上的所有 ip 端口。\n127.0.0.1 是一个环回地址。并不表示“本机”。0.0.0.0 才是真正表示“本网络中的本机”。\n构建 $ docker build -t myhugo:latest . 运行容器 cd 到你的网站根目录\n$ docker run -it --rm -p 1313:1313 -v $PWD:/src/hugo myhugo 查看绑定的端口\n$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 45c23e0f5112 myhugo \u0026#34;hugo server -D --bi…\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:1313-\u0026gt;1313/tcp jolly_morse ","permalink":"https://kingtuo123.com/posts/docker-build-hugo/","summary":"dockerfile 构建 hugo 镜像","title":"Docker hugo"},{"content":"Dockerfile FROM ubuntu:latest LABEL author=\u0026#34;king\u0026#34; EXPOSE 445 139 RUN set -ex \u0026amp;\u0026amp; \\ sed -i s@/archive.ubuntu.com/@/mirrors.tuna.tsinghua.edu.cn/@g /etc/apt/sources.list \u0026amp;\u0026amp; \\ apt clean \u0026amp;\u0026amp; \\ apt update \u0026amp;\u0026amp; \\ apt -y install samba CMD /etc/init.d/smbd start \u0026amp;\u0026amp; /bin/bash 最后一句 \u0026amp;\u0026amp; /bin/bash 防止容器直接退出\n构建镜像 $ docker build -t mysamba:latest . 添加 Samba 用户 进入容器：\n$ docker run -it --rm \\ -v /etc/passwd:/etc/passwd:ro \\ -v /etc/group:/etc/group:ro \\ -v /var/lib/samba/private/:/var/lib/samba/private/:rw \\ mysamba /bin/bash 注意：添加的 samba 用户是要已存在的 linux 用户，所以要映射passwd 和 group 两个文件。 当然也可以不映射直接在容器内新增用户/组。\n/var/lib/samba/private/ 目录存储了 samba 的用户信息及密码等数据，如果使用一次性的容器（--rm）需要映射该目录。\n添加 samba 用户：\n# smbpasswd -a king 打印用户列表：\n# pdbedit -L king:1000: 配置 Samba 本地创建 /etc/samba/smb.conf 配置文件，参考 Samba 安装及配置\n[global] workgroup = Home netbios name = king\u0026#39;s laptop server string = king\u0026#39;s SambaServer display charset = UTF8 #interfaces = wlp2s0 #hosts allow = 192.168.1. deadtime = 10 log file = /var/log/samba/log.%m max log size = 50 map to guest = Bad User max connections = 0 # 可guest登录，可读，指定用户可写 [public] path = /home/king/Public security = share public = yes writable = yes write list = king available = yes browseable = yes # 需要用户登录，可读写 [private] path = /home/king public = no valid users = king create mask = 0664 directory mask = 0775 available = yes browseable = yes writable = yes write list = king 运行容器 $ docker run -it --rm -d \\ --name samba \\ -v /etc/passwd:/etc/passwd:ro \\ -v /etc/group:/etc/group:ro \\ -v /etc/samba:/etc/samba:ro \\ -v /var/lib/samba/private/:/var/lib/samba/private/:rw \\ -p 445:445 \\ -p 139:139 \\ -v /home/king:/home/king:rw \\ -v /home/king/Public:/home/king/Public:rw \\ mysamba /home/king 和 /home/king/Public 这两个目录是在 smb.conf 中配置的共享目录。\n","permalink":"https://kingtuo123.com/posts/docker-build-samba/","summary":"构建 Samba 镜像 / 配置","title":"Docker Samba"},{"content":" 参考文章： Linux系统的UID和EUID Linux SetUID ruid, euid, suid usage in Linux Difference between owner/root and RUID/EUID SUID, GUID and Sticky Bit setuid()与seteuid()的区别 概述 内核为每个进程维护的三个UID值：\nRUID (Real User ID) 进程的实际拥有者 EUID (Effective User ID) 用于系统决定用户对系统资源的访问权限，通常情况下等于RUID SUID (Saved set-user-ID) 仅适用于可执行文件，若文件设置了 SUID，那么当用户执行此文件时，会以文件所有者的身份去执行此文件 示例 test.c，以普通用户打印 /etc/shadow 文件内容\n#define _GNU_SOURCE #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; int main(void){ uid_t ruid, euid, suid; getresuid(\u0026amp;ruid, \u0026amp;euid, \u0026amp;suid); printf(\u0026#34;RUID: %d, EUID: %d, SUID: %d\\n\u0026#34;, ruid, euid, suid); execlp(\u0026#34;cat\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;/etc/shadow\u0026#34;, (char *)0); exit(0); } 编译 make test，执行 ./test\n$ ls -l test -rwxr-xr-x 1 king king 15528 Mar 29 17:11 test $ ./test RUID: 1000, EUID: 1000, SUID: 1000 cat: /etc/shadow: Permission denied 修改 owner 及 suid 后再执行\n# chown root test \u0026amp;\u0026amp; chmod u+s test $ ls -l test -rwsr-xr-x 1 root king 15528 Mar 29 17:11 test $ ./test RUID: 1000, EUID: 0, SUID: 0 成功打印,略... 当可执行文件有 SUID 位时，其他用户执行时 EUID 为文件 owner 的 id，与 owner 有相同的权限\n","permalink":"https://kingtuo123.com/posts/uid-euid/","summary":"进程的三个 UID 的关系","title":"UID EUID SUID"},{"content":" 参考文章： Gentoo wiki / wpa-supplicant Arch wiki / wpa-supplicant wpa_supplicant.conf(5) 配置 编辑 /etc/wpa_supplicant/wpa_supplicant.conf\n# 允许 wheel 组的用户控制 wpa_supplicant ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel # 允许 wpa_gui / wpa_cli 可写该文件 update_config=1 添加无线网络，名称不能包含中文字符或其它特殊字符，只能是 ascii 字符：\n# wpa_passphrase 网络名称 密码 \u0026gt;\u0026gt; /etc/wpa_supplicant/wpa_supplicant.conf 上面命令会在 wpa_supplicant.conf 中添加如下内容：\nnetwork={ ssid=\u0026#34;wifi1\u0026#34; psk=6ad077ee70b4541967ee9c0bf0dc902 } 如果你添加了多个网络，可以使用 priority 变量设置连接优先级，数字越小，优先级越高：\nnetwork={ ssid=\u0026#34;wifi1\u0026#34; psk=6ad077ee70b4541967ee9c0bf0dc90 priority=1 } 其它可用的变量见 wpa_supplicant.conf(5) 中的 NETWORK BLOCKS 一节。\n最后，连接网络 + 获取IP：\n# wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf # dhclient -i wlan0 -v 开机启动（OpenRC） 编辑 /etc/conf.d/net， 替换 wlp2s0 为你的无线网卡名称：\nmodules_wlp2s0=\u0026#34;wpa_supplicant\u0026#34; config_wlp2s0=\u0026#34;dhcp\u0026#34; 添加开机启动：\n# cd /etc/init.d # ln -s net.lo net.wlp2s0 # rc-update add net.wlp2s0 default # rc-update add dhcpd default wpa_cli 交互式命令行工具 直接在终端执行 wpa_cli 命令，即可进入交互模式：\n$ wpa_cli -i wlan0 Interactive mode \u0026gt; help # 列出所有指令，及其用法 略... \u0026gt; list_networks # 打印已添加的网络 network id / ssid / bssid / flags 0 wifi1 any 1 wifi2 any [CURRENT] \u0026gt; scan # 扫描网络 OK \u0026lt;3\u0026gt;CTRL-EVENT-SCAN-STARTED \u0026lt;3\u0026gt;CTRL-EVENT-SCAN-RESULTS \u0026gt; scan_results # 查看扫描结果 1c:16:a1:12:1d:a8 5765 -27 [WPA-PSK-CCMP][WPA2-PSK-CCMP][ESS] wifi1 10:1b:13:d4:14:6c 5200 -62 [WPA-PSK-CCMP][WPA2-PSK-CCMP][ESS] wifi2 1c:16:a7:12:4d:a6 2412 -23 [WPA-PSK-CCMP][WPA2-PSK-CCMP][ESS] wifi3 \u0026gt; add_network # 添加网络 2 \u0026lt;3\u0026gt;CTRL-EVENT-NETWORK-ADDED 2 \u0026gt; set_network 2 ssid \u0026#34;wifi3\u0026#34; # 设置网络2的ssid (配置文件中 network 的 ssid 变量) \u0026gt; set_network 2 psk \u0026#34;passphrase\u0026#34; # 设置网络2的密码 \u0026gt; enable_network 2 # 使能网络2 \u0026gt; save_config # 保存到配置文件 \u0026gt; select_network 2 # 连接到网络2 非交互模式，直接在命令后面跟指令，例如：\n$ wpa_cli -i wlan0 list_networks ssid 中文字符无法显示 用下面两行命令其中一个就行：\n$ wpa_cli -i wlan0 scan_result | sed \u0026#34;s/\\\\\\/\\\\\\\\\\\\\\/g\u0026#34; | xargs -L1 echo -e # iw dev wlan0 scan | grep -i ssid |sed \u0026#34;s/\\\\\\/\\\\\\\\\\\\\\/g\u0026#34; | xargs -L1 echo -e 找到对应的中文 ssid 后，在 wpa_cli 中按上面的步骤操作。\n注意：不能直接在 wpa_supplicant.conf 中添加中文字符的 ssid。\n","permalink":"https://kingtuo123.com/posts/wpa_supplicant/","summary":"使用 wpa_supplicant 管理无线网络","title":"wpa_supplicant"},{"content":" 参考文章 Archwiki HiDPI 编辑 .xinitrc，添加：\nexport GDK_SCALE=2 export GDK_DPI_SCALE=0.5 xrdb -merge .Xresources 编辑 .Xresources\nXft.dpi: 192 Xcursor.size: 48 !Xcursor.theme: DMZ-Black Xcursor.theme: Bibata-Modern-Ice Xft.autohint: 0 Xft.lcdfilter: lcddefault Xft.hintstyle: hintfull Xft.hinting: 1 Xft.antialias: 1 Xft.rgba: rgb Xcursor.theme 用的鼠标主题需要支持 HIDPI\n","permalink":"https://kingtuo123.com/posts/xhidpi-setting/","summary":"Linux 非桌面环境在 4k 分辨率下配置 200% 缩放","title":"xHiDPI"},{"content":"配置简体中文 编辑 ~/.config/fcitx/rime/build/luna_pinyin.schema.yaml\nswitches: - name: ascii_mode reset: 0 states: [\u0026#34;中文\u0026#34;, \u0026#34;西文\u0026#34;] - name: full_shape states: [\u0026#34;半角\u0026#34;, \u0026#34;全角\u0026#34;] - name: simplification states: [\u0026#34;漢字\u0026#34;, \u0026#34;汉字\u0026#34;] - name: ascii_punct states: [\u0026#34;。，\u0026#34;, \u0026#34;．，\u0026#34;] 改为：\nswitches: - name: ascii_mode reset: 0 states: [\u0026#34;中文\u0026#34;, \u0026#34;西文\u0026#34;] - name: full_shape states: [\u0026#34;半角\u0026#34;, \u0026#34;全角\u0026#34;] - name: simplification reset: 1 states: [\u0026#34;漢字\u0026#34;, \u0026#34;汉字\u0026#34;] - name: ascii_punct states: [\u0026#34;。，\u0026#34;, \u0026#34;．，\u0026#34;] ","permalink":"https://kingtuo123.com/posts/fcitx-rime-zhcn/","summary":"解决 fcitx rime 默认繁体中文的问题","title":"Fcitx Rime 简体中文设置"},{"content":" 参考文章 Qemu-img Command Tutorial Invocation QEMU/Options Network bridge QEMU Windows 11 TUN/TAP 设备 QEMU 网络配置 NIC(Network Interface Card ，网络接口卡、网卡)\n创建虚拟磁盘 $ qemu-img create -f qcow2 ubuntu.qcow2 20G 磁盘映像类型 raw：默认类型（不指定 -f 参数），没有压缩、快照等特殊功能。优点是性能，比其他磁盘映像类型更快。 qcow2：提供压缩、快照、备份文件等功能。它在Kvm、Qemu社区很流行。 qed：支持 overlay 和 sparse images。Qed 的性能优于Qcow2。 qcow：是 Qcow2 的前身。 vmdk：VMware 流行使用的格式。 vdi：VirtualBox 流行使用的格式 vpc：第一代名为 Virtual PC 的 Microsoft 虚拟化工具使用的格式。 查看命令帮助信息：qemu-img create --help\n查看磁盘信息 $ qemu-img info ubuntu.qcow2 image: ubuntu.qcow2 file format: qcow2 virtual size: 20 GiB (21474836480 bytes) disk size: 196 KiB cluster_size: 65536 Format specific information: compat: 1.1 compression type: zlib lazy refcounts: false refcount bits: 16 corrupt: false extended l2: false 调整磁盘大小 $ qemu-img resize ubuntu.qcow2 +5G qcow2不支持缩小镜像的操作。\n安装系统至磁盘 $ qemu-system-x86_64 \\ -cdrom ~/Downloads/ubuntu.iso \\ -drive file=ubuntu.qcow2 \\ -enable-kvm \\ -cpu host \\ -smp cores=2,threads=2 \\ -m 2G \\ -vga virtio \\ -display sdl,gl=on 常用参数 -cdrom：为客户机指定光盘CD-ROM。 -drive：定义一个存储驱动器。 file：磁盘映像文件 if：驱动器接口类型，ide, scsi, sd, mtd, floppy, pflash, virtio, none index：驱动器的索引编号 media：介质类型，disk，cdrom snapshot：on|off，为on时，qemu不会将磁盘数据的更改写回到镜像文件中 -enable-kvm：使能KVM支持 -cpu：cpu模型，使用 -cpu help 查看支持的参数 host：支持宿主机cpu的所有特性 -smp： cores：每个cpu核心数 threads：每个cpu线程数 -m：内存大小，单位 M，G -vga：vga 卡类型，cirrus，std，vmware，qxl，tcx，cg3，virtio，none(Disable VGA card.) -display：显示器类型，通过 sdl 输出显示，gl=on 启用 opengl -netdev user,id=n1,ipv4=on,ipv6=off -machine type=q35,accel=kvm\n","permalink":"https://kingtuo123.com/posts/qemu-cli/","summary":"Qemu 创建虚拟机","title":"Qemu 常用命令"},{"content":" 摘自《C++ primer》 变量和基本类型 算术类型 字面值常量 初始化、赋值 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。\n声明和定义 extern int i; // 声明i而非定义i int j; // 声明并定义j 变量能且只能被定义一次，但是可以被多次声明。\nC++ 关键字 左值引用 即别名\nint ival = 1024; int \u0026amp;refVal = ival; // refVal指向ival（是ival的另一个名字） int \u0026amp;refVal2; // 报错：引用必须被初始化 命名空间的using声明 #include\u0026lt;iostream\u0026gt; //using std::cin; //单独声明cin using namespace std; int main(){ int i; cin \u0026gt;\u0026gt; i; // same as std::cin cout \u0026lt;\u0026lt; i; // same as std::cout return 0; } string 标准库类型 string 表示可变长的字符序列。\n#include\u0026lt;string\u0026gt; using namespace std; //using std::string; int main(){ string word; while(cin \u0026gt;\u0026gt; word) // 反复读取，直至到达文件末尾 cout \u0026lt;\u0026lt; word \u0026lt;\u0026lt; endl; // 逐个输出单词 return 0; } 处理单个字符 范围for语句（range for），语法形式：\nfor (declaration : expression) statement string str(\u0026#34;some string\u0026#34;) // 每行输出str中的一个字符 for(auto c : str) cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 使用下标：\nif(!s.empty()) cout \u0026lt;\u0026lt; s[0] \u0026lt;\u0026lt; endl; // 输出s的第一个字符 vector 向量 类似于 ”容器“ 。\n// 以10分为一个分数段统计成绩的数量：0~9，10~19，...，90~99，100 vector\u0026lt;usigned\u0026gt; scores(11,0); // 11个分数段，全部初始化为0 unsigned grade; while (cin \u0026gt;\u0026gt; grade){ // 输入成绩 if(grade \u0026lt;= 100) // 只处理有效成绩 ++scores[grade/10]; // 将对应分段的计数值加1 } 下图截自：Vector与数组的区别\niterator 迭代器 string s(\u0026#34;some string\u0026#34;); if(s.begin() != s.end()){ // 确保s非空 auto it = s.begin(); // it表示s的第一个字符,begin返回第一个元素的迭代器 *it = toupper(*it); // 将当前字符改成大写形式 } 输入输出 iostream 库包含 istream 和 ostream。\niostream 库定义了4个IO对象： cin：标准输入 cout：标准输出 cerr：输出警告和错误消息 clog：输出程序运行时的一般性信息 ","permalink":"https://kingtuo123.com/posts/c-plus-basic/","summary":"C++ primer 学习笔记","title":"C++ 基础"},{"content":" 参考文章： netstat(8) - Linux man page netstat 命令详解 注意：该命令已过时， netstat 的替代品是 ss 命令。\nnetstat -r 的替换是 ip route netstat -i 的替换是 ip -s link netstat -g 的替换是 ip maddr 常用参数 -r：--route，显示路由表 -l：--listening，显示所有监听的端口 -a：--all，显示所有链接和监听端口 -t：显示所有的 tcp 协议的端口 -x：显示所有的 unix 协议的端口 -u：显示所有的 udp 协议的端口 -n：--numeric，用数字显示主机名/IP/端口，例如localhost用127.0.0.1 -p：--programs，显示进程名和PID -v：--verbose，显示指令执行过程 -W：--wide，不截断IP地址 -s：--statistics，显示各协议统计信息 -i：--interface，显示接口信息 -N：--symbolic，解析硬件名称 -e：--extend，显示额外信息 -o：--timers，显示计时器 -c：--continuous，每隔一个固定时间，执行netstat命令 -g：--group，显示多重广播功能群组组员名单 -M：--masquerade，显示伪装的网络连接 -F：--fib，显示转发信息库(默认) -C：--cache，显示路由缓存而不是FIB -Z：--context，显示套接字的SELinux安全上下文 ","permalink":"https://kingtuo123.com/posts/netstat-cmd/","summary":"打印网络连接、路由表、接口统计信息 \u0026hellip;","title":"netstat"},{"content":" 参考资料： vmware中nat、bridge、host-only的区别 \u0026ldquo;Bridged, NAT, Host-only or Custom\u0026rdquo; VMWare Bridge NAT 虚拟NAT+虚拟DHCP服务器的功能相当于路由器 虚拟机通过虚拟NAT设备联网 Host-only ","permalink":"https://kingtuo123.com/posts/bridge-nat-hostonly/","summary":"桥接，中继，主机模式","title":"Bridge NAT Host-only 区别"},{"content":" 参考文章： Communication through Multiple Switches 交换机概述（MAC地址表建立与转发） 目的mac地址是如何得到的？ 通过 ARP广播（Address Resolution Protocol）获取目标的物理地址。\nMAC地址表是如何建立的？ 假设主机A向主机B发送一个数据帧，当该数据帧从端口1进入交换机后，交换机通过检查数据帧中的源MAC地址字段，将该字段的值（主机A的MAC地址）放入MAC地址表中，并把它与端口1对应起来，表示端口1所连接的主机是A。此时，由于在MAC地址表中没有关于目的地MAC地址（主机B的MAC地址）的条目。交换机将此帧向除了端口1以外的所有端口转发，从而保证主机B能收到该帧（这种操作叫flooding）。\n泛洪（flooding）：是发给除了当前发来信息的端口之外的所有端口\n同理，当交换机收到主机B、C、D的数据后也会把他们的地址学习到，写入地址表中，并将相应的端口和MAC地址对应起来。最终会把所有的主机地址都学习到，构建出完整的地址表。\n不要将泛洪与广播混淆。\n广播：是发送给当前子网内的所有端口（包括发送数据报的端口本身）\n","permalink":"https://kingtuo123.com/posts/mac-adr-table/","summary":"简述 mac 地址表的建立过程","title":"MAC 地址表"},{"content":" 参考文章： 什么是NAT？ NAT NAT技术easy IP 原理 Easy IP与NAPT的区别 NAT Static与NAT Server的区别 NAT概述 NAT（Network Address Translation）是将IP数据报文头中的IP地址转换为另一个IP地址的过程，主要用于实现内部网络（私有IP地址）访问外部网络（公有IP地址）的功能。\nBasic NAT Basic NAT方式属于一对一的地址转换，在这种方式下只转换IP地址，而不处理TCP/UDP协议的端口号，一个公网IP地址不能同时被多个私网用户使用。\n动态NAT 上图实现过程如下：\nRouter收到内网侧Host发送的访问公网侧Server的报文，其源IP地址为10.1.1.100，目的IP地址是211.100.7.34。 Router从地址池（Address group）中选取一个空闲的公网IP地址162.105.178.65。 Router建立内网侧源IP与公网IP间的双向NAT转换表（NAT table）。 Router查找正向NAT表，将报文转换后向公网侧发送，其源IP地址是162.105.178.65，目的IP地址是211.100.7.34。 Router收到公网侧的回应报文后，根据其目的IP地址查找反向NAT表项，并依据查表结果将报文转换后向私网侧发送，其源IP地址是211.100.7.34，目的IP地址是10.1.1.100。 当该公网IP空闲时也可分配给其他任一内网主机，这种分配的方式属于动态NAT。\n静态NAT 一个公网IP只会分配给唯一且固定的内网主机。 静态NAT实现了私有地址和公有地址的一对一映射。 NAPT 网络地址端口转换NAPT（Network Address Port Translation）。\nNAPT方式属于多对一的地址转换，它通过使用“IP地址＋端口号”的形式进行转换，使多个私网用户可共用一个公网IP地址访问外网。\n上图描述了NAPT的基本原理，实现过程如下：\nRouter收到内网侧Host发送的访问公网侧Server的报文。源IP是10.1.1.100，端口号1025。 Router从地址池中选取一对空闲的“公网IP地址＋端口号” 建立与内网侧报文“源IP地址＋源端口号”间的NAPT转换表项（正反向），并依据查找正向NAPT表项的结果将报文转换后向公网侧发送。Router转换后的报文源地址为162.105.178.65，端口号16384。 Router收到公网侧的回应报文后，根据其“目的IP地址＋目的端口号”查找反向NAPT表项，并依据查表结果将报文转换后向私网侧发送。比如Server回应Host A的报文经Router转换后，目的地址为10.1.1.100，端口号1025。 Easy IP Easy IP方式可以利用访问控制列表来控制哪些内部地址可以进行地址转换。\nEasy IP方式特别适合小型局域网访问Internet的情况。这里的小型局域网主要指中小型网吧、小型办公室等环境，一般具有以下特点：内部主机较少、出接口通过拨号方式获得临时公网IP地址以供内部主机访问Internet。对于这种情况，可以使用Easy IP方式使局域网用户都通过这个IP地址接入Internet。\nEasy IP方式的处理过程如下：\nRouter收到内网侧主机发送的访问公网侧服务器的报文。 Router利用公网侧接口的“公网IP地址＋端口号”，建立与内网侧报文“源IP地址＋源端口号”间的Easy IP转换表项（正反向），并依据查找正向Easy IP表项的结果将报文转换后向公网侧发送。 Router收到公网侧的回应报文后，根据其“目的IP地址＋目的端口号”查找反向Easy IP表项，并依据查表结果将报文转换后向内网侧发送。 Easy IP 与 NAPT 类似，但NAPT 不能映射像拨号上网这种不固定IP的，所以出现了 Easy IP。\n动态的公网IP适合用 Easy IP，固定的公网IP适合用 NAPT。\n","permalink":"https://kingtuo123.com/posts/nat/","summary":"Basic NAT, NAPT, Easy IP","title":"NAT 概述"},{"content":" 参考文章： Communication through Multiple Switches 源/目标MAC地址的变化释疑 ip数据包经由路由转发的时候源ip，目的ip是否改变 关于在传输过程中MAC地址和IP地址，变与不变！ 结论：源mac地址在同一个广播域传输过程中是不变的，在跨越广播域的时候会发生改变的；而源IP地址在传输过程中是不会改变的（除NAT的时候）。\n","permalink":"https://kingtuo123.com/posts/tcpip-transmit/","summary":"NOTE","title":"MAC 与 IP 地址在传输时的变化"},{"content":" 整理自以下文章：\nIP报文格式大全\n以太网帧结构（知乎）\n以太网数据包结构\n以太网数据格式与封装解封\n以太网帧格式 Ethernet Ⅱ帧，也称为Ethernet V2帧，是如今局域网里最常见的以太帧，是以太网事实标准。如今大多数的TCP/IP应用（如HTTP、FTP、SMTP、POP3等）都是采用Ethernet II帧承载。\nIPV4头部格式 TCP头部格式 ","permalink":"https://kingtuo123.com/posts/ethernet-packet-structure/","summary":"Note","title":"以太网数据帧格式"},{"content":" 参考文章 Samba Samba.conf linux网络共享服务Samba服务器配置和应用 Linux Samba服务主配文件smb.conf中文详解 Samba配置文件常用参数详解 如何添加Samba用户 安装 内核配置 File Systems ---\u0026gt; [*] Network File Systems ---\u0026gt; [*] CIFS support (advanced network filesystem, SMBFS successor)---\u0026gt; [*] CIFS Statistics [*] Extended Statistics [*] CIFS Extended Attributes [*] CIFS POSIX Extentions [*] SMB2 and SMB3 network file system support Emerge 安装 Samba：\n# emerge --ask --noreplace net-fs/samba 用法 OpenRc 添加开机启动：\n# rc-update add samba default 启动服务：\n# eselect rc start samba 列出局域网内工作组 # nmblookup -S __SAMBA__ # smbtree -D 查看工作组内可用主机 # nmblookup -T \u0026lt;WORKGROUP\u0026gt; # nmblookup -S \u0026lt;WORKGROUP\u0026gt; # smbtree -S 挂载共享的文件夹 手动挂载：\n# mount.cifs //O2-Foobar/Shared /mnt/My-Disk/Shared -o guest 开机自动挂载，编辑 /etc/fstab：\n//O2-Foobar/Shared /mnt/My-Disk/Shared cifs guest 添加Samba用户 添加的Samba用户首先必须是Linux用户\n用户密码管理工具：smbpasswd -a：向smbpasswd文件中添加用户 -c：指定samba的配置文件 -x：删除用户 -d：禁用用户，无法登录 -e：激活用户 -n：将指定用户密码置空，要在 [global] 中写入 null passwords = yes 配置文件 主配置文件 /etc/samba/smb.conf\n示例配置 [global] workgroup = Home netbios name = king\u0026#39;s laptop server string = king\u0026#39;s SambaServer display charset = UTF8 interfaces = wlp2s0 hosts allow = 192.168.1. deadtime = 10 log file = /var/log/samba/log.%m max log size = 50 map to guest = Bad User max connections = 0 # 可guest登录，可读，指定用户可写 [public] path = /home/king/Public security = share public = yes writable = yes write list = king available = yes browseable = yes # 需要用户登录，可读写 [private] path = /home/king public = no valid users = king create mask = 0664 directory mask = 0775 available = yes browseable = yes writable = yes write list = king 常用参数 [global]\nsamba服务器的全局设置，对整个服务器有效。 workgroup = WORKGROUP\n设定 Samba Server 所要加入的工作组或者域。 server string = Samba Server Version %v\n其他 Linux 主机查看共享时的提示符。 netbios name = MYSERVER\n用于在 Windows 网上邻居上显示的主机名 interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24\n设置Samba Server监听哪些网卡，可以写网卡名，也可以写该网卡的IP地址。 hosts allow = 127. 192.168.1. 192.168.10.1\n表示允许连接到Samba Server的客户端，多个参数以空格隔开。可以用一个IP表示，也可以用一个网段表示。hosts deny 与hosts allow 刚好相反。 max connections = 0\n最大连接数目。0表示不限制。 deadtime = 0\n设置断掉一个没有打开任何文件的连接的时间。单位是分钟，0代表Samba Server不自动切断任何连接。 log file = /var/log/samba/log.%m\n设置Samba Server日志文件的存储位置以及日志文件名称。在文件名后加个宏%m（主机名），表示对每台访问Samba Server的机器都单独记录一个日志文件。 max log size = 50\n设置Samba Server日志文件的最大容量，单位为kB，0代表不限制。 security = user\nshare：不需要提供用户名和密码。 user：需要提供用户名和密码，而且身份验证由 samba server 负责。 server：需要提供用户名和密码，可指定其他机器(winNT/2000/XP)或另一台 samba server作身份验证。 domain：需要提供用户名和密码，指定winNT/2000/XP域服务器作身份验证。 map to guest = Never\nNever：无效的密码或账户不存在将被拒绝登录（默认） Bad User：如果账户不存在，则使用 guest 登录 Bad Password：密码无效或账户不存在，则使用 guest 登录 Bad Uid：\u0026lt;Unknow\u0026gt; comment = 任意字符串\ncomment是对该共享的描述，可以是任意字符串。 path = /var/test\n共享目录路径 veto files = /foo/*bar*/\n隐藏文件，斜杠表示分隔符，foo 和 *bar* 匹配的文件不会在共享中显示 writable = yes/no\n指定该共享是否可写。 available = yes/no\n是否可连接，no 将拒绝所有连接请求。 browseable = yes/no\n指定该共享是否可以浏览。 valid users = smbuser,root\n允许访问该共享的用户 directory mask = 0775\n默认创建目录权限 rwxrwxr_x create mask = 0775\n默认创建文件权限 rwxrwxr_x public = yes/no\n允许guest用户访问，同 guest ok = yes/no guest account = nobody\n设置匿名账户为nobody write list = smbuser,root\n有写入权限的用户列表 deadtime = 10\n客户端在10分钟内没有打开任何 Samba 资源，服务器将自动关闭会话 display charset = UTF8\n设置显示的字符集 null passwords = yes/no\n允许或禁止客户端访问具有空密码的帐户 include = /usr/local/samba/lib/admin_smb.conf\n包含外部其他的配置文件 config file = /usr/local/samba/lib/smb.conf.%m\n在该配置文件的基础上覆盖参数配置 ","permalink":"https://kingtuo123.com/posts/samba-config/","summary":"Samba 安装及配置，配置文件常用参数及用法","title":"Samba 安装及配置"},{"content":"什么是CRC 循环冗余校验码 ( cyclie redundancy check ) 简称CRC（循环码）。\nCRC算法原理 假如有数据A：1011 1001\n以 CRC-4 为例计算该数据的 CRC 码，它的多项式公式 g(x) = x⁴ + x + 1 , 用二进制表示为 10011\n计算它的 CRC 码（冗余位）： CRC-4 表示所得 CRC 码为 4 位，在数据 A 右侧补上 4 个 0，数据 A：1011 1001 0000 数据A做被除数，用除数 10011 做模2除法，如下图 关于模2除法： 本质是异或运算 舍去最左侧 0，以 1 对齐 最后结果 1001 就是 CRC 冗余位，将它附加在原数据帧末尾，构建成一个新的数据帧进行发送；最后接收方将整个数据帧以模2除法除相同的除数，如果没有余数，则说明数据帧在传输的过程中没有出错。\nCRC算法参数模型 为了方便机器更好的计算CRC所以制定了一些规则，添加了一些参数参与计算，称为CRC参数模型。如 CRC-8、CRC-16/MODBUS、CRC-32。\n以CRC-16/MODBUS 为例，它的参数模型如下： CRC算法名称 多项式公式 宽度 多项式 初始值 结果异或值 输入反转 输出反转 CRC-4/ITU x⁴ + x + 1 4 03 00 00 true true CRC-16/MODBUS x¹⁶ + x¹⁵ + x² + 1 16 8005 FFFF 0000 true true CRC算法参数模型解释：\nCRC算法名称（NAME）：名称后面的数字就表示生成的冗余位的位数。\n宽度（WIDTH）：CRC 校验宽度，即 CRC 比特数。\n多项式（POLY）：生成项的简写，以16进制表示。例如：CRC-16/MODBUS 即是0x8005，忽略最高位的\u0026quot;1\u0026quot;，即完整的生成项是0x18005。\n初始值（INIT）：算法开始时计算（crc）的初始化预置值，一般取值FFFF或0000。当数据前几位为0时，因为模2除法会忽略0，先用FFFF异或将0取反为1，再进行模2除法，使数据开头的0也参与运算，以上是个人理解仅供参考。\n结果异或值（REFIN）：计算结果和该值异或运算。\n输入反转（REFOUT）：输入数据高低位互换，类似镜像。\n输出反转（XOROUT）：计算结果高低位互换，类似镜像。\n为什么可以忽略最高位的\u0026quot;1\u0026quot; 以 CRC-4 为例，它的多项式公式 g(x) = x⁴ + x + 1 , 用二进制表示为 10011，多项式用十六进制表示应该是13，为什么参数模型里用 03 表示？\n再来观察上面的式子,看下图左侧，模2除法里除数和被除数左侧以 1 对齐后再异或运算，最左侧1在每次运算后都会被丢弃（因为 1 异或 1 为 0，而模 2 除法会舍去 0），并不会对最终结果产生影响\n我们把除数左侧的 1 去掉，如图右侧所示，可以看出，只要将除数与被除数的第 2 位对齐再异或运算 ，最后结果是一样的，所以除数最高位1可以舍去，13 就可以简写为 03。\n直接计算法 - 正/反向 以CRC-16/MODBUS 参考模型为例编程\n第一步，输入数据反转，只反转单个字节不改变字节顺序，例如 0x0903 反转为 0x90C0\n第二步，定义初始值 FFFF，以除数 8005 进行模 2 运算\n最后，输出数据反转,反转整个CRC寄存器，例如 0x0903 反转为 0xC090\n#include\u0026lt;stdio.h\u0026gt; /* 字节反转 */ unsigned char Flip(unsigned char data) { data = ((data\u0026amp;0x55)\u0026lt;\u0026lt;1)|((data\u0026amp;0xaa)\u0026gt;\u0026gt;1); data = ((data\u0026amp;0x33)\u0026lt;\u0026lt;2)|((data\u0026amp;0xcc)\u0026gt;\u0026gt;2); data = ((data\u0026amp;0x0f)\u0026lt;\u0026lt;4)|((data\u0026amp;0xf0)\u0026gt;\u0026gt;4); return data; } /* CRC算法正向 */ unsigned short CRC16( unsigned char * data, unsigned short len) { int i,j; unsigned short CRC = 0xFFFF; /* CRC寄存器，初始化预置值 */ for( i = 0;i \u0026lt; len; i++ ) { CRC ^= (unsigned short)Flip(*data++)\u0026lt;\u0026lt;8; /* 单个字节反转 */ for(j = 0; j\u0026lt; 8; j++) { if(CRC \u0026amp; 0x8000) CRC = CRC \u0026lt;\u0026lt; 1 ^ 0x8005; else CRC \u0026lt;\u0026lt;= 1; } } /* 全反转 */ CRC = (unsigned short)Flip((unsigned char)CRC)\u0026lt;\u0026lt;8|Flip((unsigned char)(CRC\u0026gt;\u0026gt;8)); return CRC; } /* CRC算法反向，比正向效率要高，网上找的算法大多是反向的*/ unsigned short CRC16_Rev( unsigned char * data, unsigned short len) { int i,j; unsigned short CRC = 0xFFFF; for( i = 0;i \u0026lt; len; i++ ) { CRC ^= *data++; for(j = 0; j\u0026lt; 8; j++) { if(CRC \u0026amp; 0x0001) CRC = CRC \u0026gt;\u0026gt; 1 ^ 0xA001; /* 8005反转就是A001 */ else CRC \u0026gt;\u0026gt;= 1; } } return CRC; } int main(void) { unsigned char data[6] = {0x01,0x04,0x00,0x00,0x00,0x01}; printf(\u0026#34;%x\\n\u0026#34;,CRC16(data,6)); /* 正向 */ printf(\u0026#34;%x\\n\u0026#34;,CRC16_Rev(data,6)); /* 反向 */ getchar(); return 0; } 这里举一个简单的例子。假设从设备地址为 1,要求读取输人寄存器地址 30001 的值，则 RTU 模式下具体的查询消息帧如下： 0x01，0x04，0x00，0x00，0x00，0x01，0x31，0xCA 其中，0xCA31 即为 CRC 值。因为 Modbus 规定发送时 CRC 必须低字节在前，高字节在后，因此实际的消息帧的发送顺序为 0x31,0xCA。\n查表法 异或运算有结合律：(a^b)^c=a^(b^c)\n大概的原理如下图\n8 位一共有 256 种结果，可以先将结果计算好后存入数组中。按 16 位查表太多有 65536 种结果。所以按 8 位查表是最合适的。\n程序如下 ( CRC 反向算法的表 )\n#include\u0026lt;stdio.h\u0026gt; unsigned short crc16_table[] = { 0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040 }; unsigned short CRC16(unsigned char * data, unsigned short len){ unsigned short crc = 0xFFFF; unsigned char index = 0; unsigned char *p = data; while(len--){ index = *p++ ^ crc; crc \u0026gt;\u0026gt;= 8; crc ^= crc16_table[index]; } return crc; } int main(void){ unsigned short crc; unsigned char data[6] = {0x01,0x04,0x00,0x00,0x00,0x01}; crc = CRC16(data,6); printf(\u0026#34;%x \u0026#34;,crc); getchar(); return 0; } 余项表生成算法 #include\u0026lt;stdio.h\u0026gt; /*余项表生成函数*/ void generate_table(unsigned short * crc16_table, unsigned short poly){ unsigned int i,j; unsigned short crc; for(i = 0; i \u0026lt; 256; i++){ crc = i; for(j = 0; j \u0026lt; 8; j++){ if(crc \u0026amp; 0x0001){ crc = (crc \u0026gt;\u0026gt; 1) ^ 0xa001;\t}else{ crc \u0026gt;\u0026gt;= 1; } } crc16_table[i] = crc; } } /*打印表*/ void print_table(unsigned short * crc16_table){ unsigned int i; printf(\u0026#34;unsigned short crc16_table[] = {\\n \u0026#34;); for(i = 0; i \u0026lt; 256; i++){ printf(\u0026#34;0x%04x, \u0026#34;,crc16_table[i]); if(i == 255) printf(\u0026#34;\\b\\b \u0026#34;); if(!((i+1)%8)) printf(\u0026#34;\\n \u0026#34;); } printf(\u0026#34;\\b\\b\\b\\b};\\n\u0026#34;); } int main(void) { unsigned short crc16_table[256]; unsigned short poly = 0xA001; generate_table(crc16_table,poly); print_table(crc16_table); getchar(); return 0; } ","permalink":"https://kingtuo123.com/posts/modbus-crc/","summary":"CRC 校验原理","title":"Modbus 协议 CRC 校验"},{"content":"参考文章\nI2C I2C 时钟延展 基本结构 起始和停止信号 当 SCL 是高电平时 SDA 线从高电平向低电平切换，表示通讯的起始。（下降沿触发）\n当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。（上升沿触发）\n数据有效性 SCL 为高电平的时候 SDA 表示的数据有效\n7 位地址 如上图所示，通常地址高 4 位 A6-A3 表示器件类型，存储类芯片一般是 1010b ，这是由半导体厂家固定的。\n低 3 位 A2-A0 表示器件地址，一般由器件的引脚电路决定。\nR/W 位指示这是读取 (1) 还是写入 (0) 操作的 。\n10 位地址 10 位的地址分为两帧发送。\n第一帧，0b 11110 表示使用 10 位的地址。A9、A8 是地址的高 2 位。 第二帧，A7-A0 是地址的后 8 位。 第三帧，普通的数据帧。 响应 响应包括 “应答 (ACK)” 和 “非应答 (NACK)” 两种信号。\nACK：继续发送 NACK：结束发送 重复起始信号 I2C 通讯更常用的是复合格式，例如：第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。\n重复起始信号如下：\n时钟延展 在 I2C 的主从通信过程中，总线上的 SCL 时钟总是由主机来产生和控制的，但如果从机跟不上主机的速率，I2C 协议规定从机是可以通过将 SCL 时钟线拉低来暂停一下传输，直到从机释放掉SCL线，传输继续进行。\n总的来说，clock stretching 其实是一种降频的手段，使得更高频率的主机也能适应低频率从机的通信。\nSTM32 I2C 收发事件 主机发送序列 主机接收序列 寄存器 控制寄存器 1（I2C CR1） 控制寄存器 2（I2C_CR2） 自身地址寄存器 1（I2C_OAR1） 自身地址寄存器 2（I2C_OAR2） 数据寄存器（I2C_DR） 状态寄存器 1（I2C_SR1） 状态寄存器 2 （I2C_SR2） 时钟控制寄存器（I2C_CCR） TRISE寄存器（I2C_TRISE） EEPROM I2C 驱动（标准库） 单片机：STM32F103ZET6 EEPROM：AT24C02 使用硬件 I2C 驱动 bsp_eeprom.h #ifndef __BSP_EEPROM_H #define __BSP_EEPROM_H #include \u0026#34;stm32f10x.h\u0026#34; #define EEPROM_I2Cx I2C1 #define EEPROM_I2C_APBxClock_FUN RCC_APB1PeriphClockCmd #define EEPROM_I2C_CLK RCC_APB1Periph_I2C1 #define EEPROM_I2C_GPIO_APBxClock_FUN RCC_APB2PeriphClockCmd #define EEPROM_I2C_GPIO_CLK RCC_APB2Periph_GPIOB #define EEPROM_I2C_SCL_PORT GPIOB #define EEPROM_I2C_SCL_PIN GPIO_Pin_6 #define EEPROM_I2C_SDA_PORT GPIOB #define EEPROM_I2C_SDA_PIN GPIO_Pin_7 // 地址 #define EEPROM_ADDRESS 0xA0 // 存储容量（字节） #define EEPROM_SIZE_BYTE 256 // 页面大小（字节） #define EEPROM_PAGE_SIZE_BYTE 8 // 页数 #define EEPROM_PAGE_NUM 32 // I2C应答等待超时时间 #define I2CT_FLAG_TIMEOUT ((uint32_t)0x1000) #define I2CT_LONG_TIMEOUT ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)) // 本机地址 #define I2Cx_OWN_ADDRESS7 0x01 // I2C总线速度(Hz) 快速模式 #define I2C_SPEED 400000 // I2C总线速度(Hz) 标准模式 // #define I2C_SPEED 100000 void EEPROM_Init(void); uint8_t EepromWriteByte(uint8_t WriteAddr, uint8_t Byte); uint8_t EepromWriteHalfWord(uint8_t WriteAddr, uint16_t HalfWord); uint8_t EepromWriteWord(uint8_t WriteAddr, uint32_t Word); uint8_t EepromWrite(uint8_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite); static uint8_t EepromWritePage(uint8_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite); static void EepromWaitStandby(void); uint8_t EepromRead(uint8_t ReadAddr, uint8_t* pBuffer, uint16_t NumByteToRead); bsp_eeprom.c #include \u0026#34;bsp_eeprom.h\u0026#34; /** * @brief EEPROM初始化 * @param * @retval */ void EEPROM_Init(void){ GPIO_InitTypeDef GPIO_InitStructure; I2C_InitTypeDef I2C_InitStructure; // 使能与 I2C 有关的时钟 EEPROM_I2C_APBxClock_FUN(EEPROM_I2C_CLK, ENABLE); EEPROM_I2C_GPIO_APBxClock_FUN(EEPROM_I2C_GPIO_CLK, ENABLE); // I2C_SCL 开漏输出 GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_Init(EEPROM_I2C_SCL_PORT, \u0026amp;GPIO_InitStructure); // I2C_SDA 开漏输出 GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_Init(EEPROM_I2C_SDA_PORT, \u0026amp;GPIO_InitStructure); // I2C 配置 I2C_InitStructure.I2C_Mode = I2C_Mode_I2C; // SCL占空比2:1，低电平/高电平，SCL为高电平的时读SDA数据 I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2; // 本机地址 I2C_InitStructure.I2C_OwnAddress1 =I2Cx_OWN_ADDRESS7; // ACK应答使能 I2C_InitStructure.I2C_Ack = I2C_Ack_Enable ; // 7位寻址模式 I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; // 通信速率，不能大于400KHz I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED; // I2C初始化 I2C_Init(EEPROM_I2Cx, \u0026amp;I2C_InitStructure); // 使能I2C I2C_Cmd(EEPROM_I2Cx, ENABLE); // 使能应答 I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE); } /** * @brief EEPROM 写单个字节 * @param * @arg WriteAddr * @arg Byte * @retval 成功返回0，失败\u0026gt;0 */ uint8_t EepromWriteByte(uint8_t WriteAddr,uint8_t Byte){ return EepromWrite(WriteAddr, \u0026amp;Byte, 1); } /** * @brief EEPROM 写半字，小端存储 * @param * @arg WriteAddr * @arg HalfWord * @retval 成功返回0，失败\u0026gt;0 */ uint8_t EepromWriteHalfWord(uint8_t WriteAddr, uint16_t HalfWord){ return EepromWrite(WriteAddr, (uint8_t*)\u0026amp;HalfWord, 2); } /** * @brief EEPROM 写字，小端存储 * @param * @arg WriteAddr * @arg Word * @retval 成功返回0，失败\u0026gt;0 */ uint8_t EepromWriteWord(uint8_t WriteAddr, uint32_t Word){ return EepromWrite(WriteAddr, (uint8_t*)\u0026amp;Word, 4); } /** * @brief EEPROM 写入指定个数的字节 * @param * @arg WriteAddr: EEPROM内部写地址 * @arg pBuffer:缓冲区指针 * @arg NumByteToWrite:字节数 * @retval 成功返回0，失败\u0026gt;0 */ uint8_t EepromWrite(uint8_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite){ uint8_t WriteLen, PageOffset, errno; while(NumByteToWrite \u0026gt; 0){ // 计算当前页能写入的字节数, 24C02不能跨页写(页面大小8字节) PageOffset = EEPROM_PAGE_SIZE_BYTE - (WriteAddr % EEPROM_PAGE_SIZE_BYTE); WriteLen = NumByteToWrite \u0026gt; PageOffset ? PageOffset : NumByteToWrite; // 写入一页 errno = EepromWritePage(WriteAddr, pBuffer, WriteLen); if(errno != 0){ return errno; } NumByteToWrite = NumByteToWrite - WriteLen; // 剩余要写入的字节数大于0 if(NumByteToWrite \u0026gt; 0){ pBuffer += WriteLen; WriteAddr += WriteLen; } } return 0; } /** * @brief 等待 EEPROM 芯片就绪 * @param * @retval */ static void EepromWaitStandby(void){ __IO uint16_t SR1_Tmp = 0; do{ // 发送起始信号 I2C_GenerateSTART(EEPROM_I2Cx, ENABLE); // 读 I2C1 SR1 寄存器 SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1); // 发送EEPROM地址+写方向 I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter); // 当I2C设备响应了地址的时候，ADDR会置1 }while(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) \u0026amp; 0x0002)); // 清除AF标志 I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF); // 发送停止信号 I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); } /** * @brief 页写 * @brief AT24C02每页有8个字节, 且不能跨页写入 * @param * @arg WriteAddr:写地址 * @arg pBuffer:缓冲区指针 * @arg NumByteToWrite:字节数 * @retval 正常返回0，异常返回\u0026gt;0 */ static uint8_t EepromWritePage(uint8_t WriteAddr, uint8_t* pBuffer, uint16_t NumByteToWrite){ __IO uint32_t I2CTimeout = I2CT_LONG_TIMEOUT; // 等待总线空闲 while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY)){ if((I2CTimeout--) == 0) return 1; } // 发送起始信号 I2C_GenerateSTART(EEPROM_I2Cx, ENABLE); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT)){ if((I2CTimeout--) == 0) return 2; } // 发送EEPROM地址+写方向 I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)){ if((I2CTimeout--) == 0) return 3; } // 发送EEPROM内部要写入的起始地址 I2C_SendData(EEPROM_I2Cx, WriteAddr); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED)){ if((I2CTimeout--) == 0) return 4; } // 发送数据 while(NumByteToWrite--) { // 发送一个字节 I2C_SendData(EEPROM_I2Cx, *pBuffer++); I2CTimeout = I2CT_FLAG_TIMEOUT; while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED)){ if((I2CTimeout--) == 0) return 5; } } // 发送停止信号 I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); // 等待芯片页写完成 EepromWaitStandby(); return 0; } /** * @brief 读取指定个数的字节到pBuffer * @param * @arg ReadAddr:接收数据的EEPROM的地址 * @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针 * @arg NumByteToRead:要从EEPROM读取的字节数 * @retval 正常返回0，异常返回\u0026gt;0 */ uint8_t EepromRead(uint8_t ReadAddr, uint8_t* pBuffer, uint16_t NumByteToRead){ __IO uint32_t I2CTimeout = I2CT_LONG_TIMEOUT; // 等待总线空闲 while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY)){ if((I2CTimeout--) == 0) return 6; } // 产生I2C起始信号 I2C_GenerateSTART(EEPROM_I2Cx, ENABLE); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT)){ if ((I2CTimeout--) == 0) return 7; } // 发送EEPROM地址+写方向 I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS,I2C_Direction_Transmitter); I2CTimeout = I2CT_FLAG_TIMEOUT; while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)){ if ((I2CTimeout--) == 0) return 8; } // 通过重新设置PE位清除EV6事件 I2C_Cmd(EEPROM_I2Cx, ENABLE); // 发送要读取的EEPROM内部地址 I2C_SendData(EEPROM_I2Cx, ReadAddr); I2CTimeout = I2CT_FLAG_TIMEOUT; while (!I2C_CheckEvent(EEPROM_I2Cx,I2C_EVENT_MASTER_BYTE_TRANSMITTED)){ if ((I2CTimeout--) == 0) return 9; } // 产生第二次I2C起始信号 I2C_GenerateSTART(EEPROM_I2Cx, ENABLE); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT)){ if ((I2CTimeout--) == 0) return 10; } // 发送EEPROM设备地址+读方向 I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver); I2CTimeout = I2CT_FLAG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)){ if ((I2CTimeout--) == 0) return 11; } do{ // 若是最后一个数据，发送非应答信号，结束传输 if (NumByteToRead-- == 1){ // 发送非应答信号 I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE); // 发送停止信号 I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); } I2CTimeout = I2CT_LONG_TIMEOUT; while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)){ if((I2CTimeout--) == 0) return 12; } // 读取一个字节 *pBuffer++ = I2C_ReceiveData(EEPROM_I2Cx); }while(NumByteToRead); // 使能应答，方便下一次I2C传输 I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE); return 0; } ","permalink":"https://kingtuo123.com/posts/stm32-i2c/","summary":"Note","title":"STM32 I2C"},{"content":" 参考 Android/adb 安装 安装 ADB # emerge --ask dev-util/android-tools 检测设备 首先确保手机开启 USB 调试功能，然后执行下面命令，检测成功后会列出设备：\n$ adb devices List of devices attached 8NH7N17B0XX9898 device 非 ROOT 用户使用 ADB：\n# gpasswd -a \u0026lt;username\u0026gt; plugdev 进入 shell $ adb shell 连接多个设备 使用 -s 参数指定设备\n$ adb devices List of devices attached 9QZ7N11B0ZX8999 device 8NH7N17B0XX9898 device $ adb -s \u0026lt;device̠-number\u0026gt; shell 常用命令 命令 说明 adb device 查看连接设备 adb install \u0026lt; apk name \u0026gt; 安装应用 adb uninstall \u0026lt; pak name \u0026gt; 卸载应用 adb shell pm list packages 列出手机装的所有 app 的包名 adb shell pm list packages -3 列出除了系统应用的第三方应用包名 adb shell pm clear \u0026lt; pak name \u0026gt; 清除应用数据与缓存 adb shell pm disable-user \u0026lt; pak name \u0026gt; 禁用应用 adb shell pm enable \u0026lt; pak name \u0026gt; 启用应用 ","permalink":"https://kingtuo123.com/posts/linux-adb/","summary":"常用 ADB 命令及使用","title":"Linux 下使用 adb 工具"},{"content":"寄存器 DMA_ISR DMA 中断状态寄存器（ DMA interrupt status register ） TEIFx：通道x的传输错误标志 HTIFx：通道x的半传输标志 TCIFx：通道x的传输完成标志 GIFx： 通道x的全局中断标志 （TE、HT或TC事件） DMA_IFCR DMA中断标志清除寄存器（DMA interrupt flag clear register） CTEIFx：清除通道x的传输错误标志 CHTIFx：清除通道x的半传输标志 CTCIFx：清除通道x的传输完成标志 CGIFx： 清除通道x的全局中断标志 DMA_CCRx DMA通道x配置寄存器（DMA channel x configuration register） MEM2MEM：存储器到存储器模式 (Memory to memory mode) PL[1:0]：通道优先级 (Channel priority level) MSIZE[1:0]：存储器数据宽度 (Memory size) PSIZE[1:0]：外设数据宽度 (Peripheral size) MINC：存储器地址增量模式 (Memory increment mode) PINC：外设地址增量模式 (Peripheral increment mode) CIRC：循环模式 (Circular mode) DIR：数据传输方向 (Data transfer direction) TEIE：允许传输错误中断 (Transfer error interrupt enable) HTIE：允许半传输中断 (Half transfer interrupt enable) TCIE：允许传输完成中断 (Transfer complete interrupt enable) EN：通道开启 (Channel enable) DMA_CNDTRx DMA通道x传输数量寄存器（DMA channel x number of data register） NDT[15:0]：数据传输数量 (Number of data to transfer) 数据传输数量为0至65535。这个寄存器只能在通道不工作(DMA_CCRx的EN=0)时写入。通道开启后该寄存器变为只读，指示剩余的待传输字节数目。寄存器内容在每次DMA传输后递减。\n数据传输结束后，寄存器的内容或者变为0；或者当该通道配置为自动重加载模式时，寄存器的内容将被自动重新加载为之前配置时的数值。\n当寄存器的内容为0时，无论通道是否开启，都不会发生任何数据传输。\nDMA_CPARx DMA通道x外设地址寄存器（DMA channel x peripheral address register） DMA_CMARx DMA通道x存储器地址寄存器（DMA channel x memory address register） DMA_InitTypeDef 结构体 typedef struct { uint32_t DMA_PeripheralBaseAddr; // 外设地址 uint32_t DMA_MemoryBaseAddr; // 存储器地址 uint32_t DMA_DIR; // 传输方向 uint32_t DMA_BufferSize; // 传输数目 uint32_t DMA_PeripheralInc; // 外设地址增量模式 uint32_t DMA_MemoryInc; // 存储器地址增量模式 uint32_t DMA_PeripheralDataSize; // 外设数据宽度 uint32_t DMA_MemoryDataSize; // 存储器数据宽度 uint32_t DMA_Mode; // 模式选择 uint32_t DMA_Priority; // 通道优先级 uint32_t DMA_M2M; // 存储器到存储器模式 }DMA_InitTypeDef; typedef struct { __IO uint32_t CCR; __IO uint32_t CNDTR; __IO uint32_t CPAR; __IO uint32_t CMAR; } DMA_Channel_TypeDef; 例程 外设到存储器 uint8_t ReceiveBuff[100]; void USART1_DMA_Config(void){ RCC-\u0026gt;APB2ENR |= (uint32_t)0x05; // 使能GPIOA/AFIO时钟 GPIOA-\u0026gt;CRH |= (uint32_t)0x0B \u0026lt;\u0026lt; 4; // 配置PA9复用推挽输出，最高50MHZ GPIOA-\u0026gt;CRH |= (uint32_t)0x04 \u0026lt;\u0026lt; 8; // 配置PA10浮空输入 RCC-\u0026gt;APB2ENR |= (uint32_t)0x01 \u0026lt;\u0026lt; 14; // 使能USART1时钟 USART1-\u0026gt;CR1 |= (uint16_t)0x00 \u0026lt;\u0026lt; 12; // 一个起始位，8个数据位 USART1-\u0026gt;CR2 |= (uint16_t)0x00 \u0026lt;\u0026lt; 12; // 一个停止位 USART1-\u0026gt;CR3 |= (uint16_t)0x00 \u0026lt;\u0026lt; 8; // 禁用CTS，RTS硬件流控制 USART1-\u0026gt;CR3 |= (uint16_t)0x0040; // 使能USART1 DMA接收 USART1-\u0026gt;BRR = (uint16_t)0x1D4C; // 波特率9600 USART1-\u0026gt;CR1 |= (uint16_t)0x0B; // 收/发使能 NVIC-\u0026gt;ISER[1] |= (uint32_t)0x01 \u0026lt;\u0026lt; (37-32); // 使能USART1中断，中断号是37 NVIC-\u0026gt;IP[9] |= (uint32_t)0x40; // 配置优先级主1子1 USART1-\u0026gt;CR1 |= (uint16_t)0x01 \u0026lt;\u0026lt; 0; // 使能USART1 RCC-\u0026gt;APB2ENR |= (uint32_t)0x01 \u0026lt;\u0026lt; 0; // 使能DMA1时钟 DMA1_Channel5-\u0026gt;CPAR = USART1_BASE + 0x04; // 外设地址 DMA1_Channel5-\u0026gt;CMAR = (uint32_t)ReceiveBuff;// 存储器地址 DMA1_Channel5-\u0026gt;CCNDTR |= (uint16_t)0x1388; // 数据传输数量 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 14; // 禁止存储器到存储器 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x01 \u0026lt;\u0026lt; 12; // 优先级：中 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 10; // 存储器数据宽度8位 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 8; // 外设数据宽度8位 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x01 \u0026lt;\u0026lt; 7; // 存储器地址自增 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 6; // 外设地址不自增 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x01 \u0026lt;\u0026lt; 5; // 循环模式 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 4; // 从外设读 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 3; // 禁止传输错误中断 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 2; // 禁止半传输中断 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x00 \u0026lt;\u0026lt; 1; // 禁止传输完成中断 DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x01 \u0026lt;\u0026lt; 0; // 开启该DMA通道 //NVIC-\u0026gt;ISER[0] |= (uint32_t)0x01 \u0026lt;\u0026lt; 15; // 使能DMA1_Channel5中断，中断号是15 //NVIC-\u0026gt;IP[3] |= (uint32_t)0x40 \u0026lt;\u0026lt; 23; // 配置优先级主1子1 } void USART1_IRQHandler(void){ uint8_t ucTemp; if(USART1-\u0026gt;SR \u0026amp; (uint16_t)0x10){ // IDLE总线空闲标志 DMA1_Channel5-\u0026gt;CCR \u0026amp;= ~((uint32_t)0x01 \u0026lt;\u0026lt; 0); // 关闭该DMA通道 ucTemp = (uint8_t)(USARTx-\u0026gt;DR \u0026amp; (uint16_t)0x01FF); // 读取一次数据,清除IDLE DMA1_Channel5-\u0026gt;CCR |= (uint32_t)0x01 \u0026lt;\u0026lt; 0; // 开启该DMA通道 } } void DMA1_Channel5_IRQHandler(void){ } ","permalink":"https://kingtuo123.com/posts/stm32-dma/","summary":"Note","title":"STM32 DMA"},{"content":" ","permalink":"https://kingtuo123.com/posts/stm32-abbreviations-for-registers/","summary":"Note","title":"STM32 寄存器描述表中使用的缩写列表"},{"content":"USARTx_SR 状态寄存器（ Status register ） CTS: CTS标志 (CTS flag) LBD: LIN断开检测标志 (LIN break detection flag) TXE: 发送数据寄存器空 (Transmit data register empty) TC: 发送完成 (Transmission complete) RXNE：读数据寄存器非空 (Read data register not empty) IDLE：监测到总线空闲 (IDLE line detected) ORE：过载错误 (Overrun error) NE: 噪声错误标志 (Noise error flag) FE: 帧错误 (Framing error) PE: 校验错误 (Parity error) USARTx_DR 数据寄存器（ Data register ） USARTx_CR1 控制寄存器 1 UE：USART使能 (USART enable) M：字长 (Word length) WAKE：唤醒的方法 (Wakeup method) PCE：检验控制使能 (Parity control enable) PS：校验选择 (Parity selection) PEIE：PE中断使能 (PE interrupt enable) TXEIE：发送缓冲区空中断使能 (TXE interrupt enable) TCIE：发送完成中断使能 (Transmission complete interrupt enable) RXNEIE：接收缓冲区非空中断使能 (RXNE interrupt enable) IDLEIE：IDLE中断使能 (IDLE interrupt enable) TE：发送使能 (Transmitter enable) RE：接收使能 (Receiver enable) RWU：接收唤醒 (Receiver wakeup) SBK：发送断开帧 (Send break) USARTx_CR2 控制寄存器 2 LINEN：LIN模式使能 (LIN mode enable) STOP：停止位 (STOP bits) CLKEN：时钟使能 (Clock enable) CPOL：时钟极性 (Clock polarity) CPHA： 时钟相位 (Clock phase) LBCL：最后一位时钟脉冲 (Last bit clock pulse) LBDIE：LIN断开符检测中断使能 (LIN break detection interrupt enable) LBDL：LIN断开符检测长度 (LIN break detection length) ADD[3:0]：本设备的USART节点地址 USARTx_CR3 控制寄存器 3 CTSIE：CTS中断使能 (CTS interrupt enable) CTSE：CTS使能 (CTS enable) RTSE：RTS使能 (RTS enable) DMAT：DMA使能发送 (DMA enable transmitter) DMAR: DMA使能接收 (DMA enable receiver) SCEN: 智能卡模式使能 (Smartcard mode enable) NACK：智能卡NACK使能 (Smartcard NACK enable) HDSEL：半双工选择 (Half-duplex selection) IRLP：红外低功耗 (IrDA low-power) IREN：红外模式使能 (IrDA mode enable) EIE：错误中断使能 (Error interrupt enable) USART_GTPR 保护时间和预分频寄存器（ Guard time and prescaler register ） GT[7:0]：保护时间值 (Guard time value) PSC[7:0]：预分频器值 (Prescaler value) USARTx_BRR 波特率寄存器（ Baud rate register ） DIV_Mantissa[11:0]： 定义 USARTDIV 的整数部分 DIV_Fraction[3:0]： 定义 USARTDIV 的小数部分 公式如下，以 fPLCK = 72MHZ，Baud Rate = 9600 为例：\nUSARTDIV：我是理解为 fPCLK 的分频系数 fPLCK ：为 USART 时钟 OVER8：读取 1 bit 所用的采样次数 0：采样 16 次 1：采样 8 次 OVER8 是 USART_BRR 的第 15 位，该位在参考手册中没有描述，但是在标准库 stm32f10x_usart.c 中有相关代码，如下：\n/* 篇幅有限，只截取 USART_Init 函数部分代码 */ /* USART OverSampling-8 Mask */ #define CR1_OVER8_Set ((u16)0x8000) /* USART OVER8 mode Enable Mask */ #define CR1_OVER8_Reset ((u16)0x7FFF) /* USART OVER8 mode Disable Mask */ /* Determine the integer part */ if ((USARTx-\u0026gt;CR1 \u0026amp; CR1_OVER8_Set) != 0) { /* Integer part computing in case Oversampling mode is 8 Samples */ integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct-\u0026gt;USART_BaudRate))); } else /* if ((USARTx-\u0026gt;CR1 \u0026amp; CR1_OVER8_Set) == 0) */ { /* Integer part computing in case Oversampling mode is 16 Samples */ integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct-\u0026gt;USART_BaudRate))); } OVER8 复位值是0，也就是 16 次采样，即 16 个时钟周期读取 1 bit。波特率单位 bps（bit per second），即每秒传输比特位个数。结合上面两点，公式也就不难理解。\n再看上述结果 468.75，将它转化为二进制即 000111010100.1100 ：\n整数部分：即 0x1D4 写入 DIV_Mantissa[11:0] 小数部分：即 0xC 写入 DIV_Fraction[3:0] 有的教程是将小数部分乘上16：0.75x16=12，其实就是小数部分左移 4 位，结果是一样的（个人觉得上面更好理解）。\n链接：在线进制转换\nCPU 的时钟频率越低，则某一特定波特率的误差也越低。可以达到的波特率上限可以由这组数据得到。 只有 USART1 使用 PCLK2 (最高72MHz)。其它 USART 使用 PCLK1 (最高36MHz)。 中断控制 USART 有多个中断请求事件\n中断事件 事件标志 寄存器 使能控制位 奇偶校验错误 PE CR1 位8 发送数据寄存器为空 TXE CR1 位7 发送完成 TC CR1 位6 准备好读取接收到的数据 / 检测到上溢出错误 RXNE / ORE CR1 位5 检测到空闲线路 IDLE CR1 位4 断路标志 LBD CR2 位6 CTS标志 CTS CR3 位10 多缓冲通信中的噪声标志、上溢出错误和帧错误 NF/ORE/FE CR3 位0 事件标志对应状态寄存器 USART_SR 中的位，当对应位为 1 时触发中断事件。\n例程 寄存器 void USART_Config(){ RCC-\u0026gt;APB2ENR |= (uint32_t)0x05; // 使能GPIOA/AFIO时钟 GPIOA-\u0026gt;CRH |= (uint32_t)0x0B \u0026lt;\u0026lt; 4; // 配置PA9复用推挽输出，最高50MHZ GPIOA-\u0026gt;CRH |= (uint32_t)0x04 \u0026lt;\u0026lt; 8; // 配置PA10浮空输入 RCC-\u0026gt;APB2ENR |= (uint32_t)0x01 \u0026lt;\u0026lt; 14; // 使能USART1时钟 USART1-\u0026gt;CR1 |= (uint16_t)0x00 \u0026lt;\u0026lt; 12; // 一个起始位，8个数据位 USART1-\u0026gt;CR2 |= (uint16_t)0x00 \u0026lt;\u0026lt; 12; // 一个停止位 USART1-\u0026gt;CR3 |= (uint16_t)0x00 \u0026lt;\u0026lt; 8; // 禁用CTS，RTS硬件流控制 USART1-\u0026gt;BRR = (uint16_t)0x1D4C; // 波特率9600 USART1-\u0026gt;CR1 |= (uint16_t)0x0B; // 收/发使能 NVIC-\u0026gt;ISER[1] |= (uint32_t)0x01 \u0026lt;\u0026lt; (37-32); // 使能USART1中断，中断号是37 NVIC-\u0026gt;IP[9] |= (uint32_t)0x40; // 配置优先级主1子1 USART1-\u0026gt;CR1 |= (uint16_t)0x01 \u0026lt;\u0026lt; 5; // 使能接收中断 USART1-\u0026gt;CR1 |= (uint16_t)0x01 \u0026lt;\u0026lt; 0; // 使能USART1 } void USART1_IRQHandler(void) { uint8_t ucTemp; if(USART1-\u0026gt;SR \u0026amp; (uint16_t)0x20) { ucTemp = (uint8_t)(USARTx-\u0026gt;DR \u0026amp; (uint16_t)0x01FF); // 接收数据 USARTx-\u0026gt;DR = (uint16_t)ucTemp \u0026amp; (uint16_t)0x01FF; // 发送数据 }\t} 标准库 void USART_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; // 打开串口 GPIO 的时钟 DEBUG_USART_GPIO_APBxClkCmd(GPIOA, ENABLE); // 打开串口外设的时钟 DEBUG_USART_APBxClkCmd(RCC_APB2Periph_USART1, ENABLE); // 将 USART1 Tx 的 GPIO 配置为推挽复用模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); // 将 USART1 Rx 的 GPIO 配置为浮空输入模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); // 配置串口的工作参数 USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, \u0026amp;USART_InitStructure); // 串口中断优先级配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(\u0026amp;NVIC_InitStructure); // 使能串口接收中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 使能串口 USART_Cmd(USART1, ENABLE); } void USART1_IRQHandler(void) { uint8_t ucTemp; if(USART_GetITStatus(DEBUG_USARTx,USART_IT_RXNE)!=RESET) {\tucTemp = USART_ReceiveData(DEBUG_USARTx); USART_SendData(DEBUG_USARTx,ucTemp); }\t} ","permalink":"https://kingtuo123.com/posts/stm32-usart/","summary":"Note","title":"STM32 USART"},{"content":"寄存器 STK_CTRL SysTick 控制和状态寄存器（ SysTick control and status register ） COUNTFLAG: 如果在上次读取本寄存器后， SysTick 已经计到了 0，则该位为 1 CLKSOURCE: 时钟源选择 0：AHB/8 1：处理器时钟 AHB TICKINT: SysTick异常请求使能 0：数到 0 时无动作。 1：数到 0 时触发 SysTick 异常请求 ENABLE: SysTick 定时器的使能位 0：禁止 1：使能 STK_LOAD 重装载数值寄存器（SysTick reload value register） RELOAD[23:0]: 当倒数计数至零时，将被重装载的值 STK_VAL 当前数值寄存器（SysTick current value register） CURRENT[23:0]: 读取时返回当前倒计数的值，写任意值则使之清零（包括COUNTFLAG）\nSTK_CALIB 校准数值寄存器（SysTick calibration value register），用法不明，略过。 上述寄存器在内核头文件中的定义 typedef struct { __IO uint32_t CTRL; __IO uint32_t LOAD; __IO uint32_t VAL; __I uint32_t CALIB; } SysTick_Type; 例程 寄存器 int main(void){ while(1){ LED_ON(); Delay_ms(1000); LED_OFF(); Delay_ms(1000); } return 0; } void Delay_ms(__IO uint32_t ms){ SysTick-\u0026gt;LOAD = 72000; // 计数器重装载值，1ms 中断一次(系统时钟72MHZ) SCB-\u0026gt;SHP[11] |= (uint8_t)0xF0; // 配置 SysTick 中断优先级，具体看下一小节说明 SysTick-\u0026gt;VAL = (uint32_t)0x00; // 计数器初始值 SysTick-\u0026gt;CTRL |= (uint32_t)0x07; // 选择AHB时钟源，使能 SysTick 中断，使能 SysTick while(ms-- \u0026gt; 0){ // 当计数器的值减小到 0 的时候，CRTL 寄存器的位 16 会置 1 while(!((SysTick-\u0026gt;CTRL) \u0026amp; ((uint32_t)0x01 \u0026lt;\u0026lt; 16))); } SysTick-\u0026gt;CTRL \u0026amp;= ~(uint32_t)0x01; //关闭 SysTick } void SysTick_Handler(void){ // SysTick中断函数，本例中用不到 } SCB-\u0026gt;SHP[11] 配置 SysTick 中断优先级 系统中断优先级寄存器 （System handler priority register） SysTicks 属于内核（中断号 -1），不要和外部中断搞混，下面是官方手册的描述：\nSysTick 中断优先级设置对应 SCB_SHPR3 寄存器的 PRI_15[7:0]，高四位有效。\n再看头文件 core_cm3.h 中的定义：\ntypedef struct { /* 篇幅有限略去 */ __IO uint8_t SHP[12]; /* 篇幅有限略去 */ } SCB_Type; 刚好每个 SHPR 寄存器占 4 个\n可知，SHP[11] 对应 PRI_15[7:0]\n","permalink":"https://kingtuo123.com/posts/stm32-systick/","summary":"Note","title":"STM32 SysTick"},{"content":" 中断优先级 SCB 和 NVIC 相关寄存器属于内核，在 stm32编程手册 或 CM3权威指南中 能找到有关描述，参考手册是没有的。\nSCB_AIRCR 系统控制块（ System control block (SCB) ）\n应用程序中断和复位控制寄存器（ Application interrupt and reset control register ）\nPRIGROUP[2:0] ：中断优先级分组字段 NVIC_IPRx 嵌套的矢量中断控制器（ Nested vectored interrupt controller ） 中断优先级寄存器（ Interrupt priority registers ） NVIC_IPRx 用来配置外部中断 EXTIx 的优先级，IP[m] 宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。但是绝大多数 CM3 芯片都会精简设计，以致实际上支持的优先级数减少，在 F103 中，只使用了高 4bit，IP[m] 如下所示：\nbit7bit6bit5bit4bit3bit2bit1bit0 用于表达优先级未使用，读回为 0 用于表达优先级的这 4bit，又被分组成 抢占优先级 和 子优先级。如果有多个中断同时响应，抢占优先级高的就会优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。\n优先级分组 优先级的分组由内核外设 SCB 的应用程序中断及复位控制寄存器 AIRCR 的 PRIGROUP[2:0] 位决定，F103 分为了 5 组，具体如下：主优先级 = 抢占优先级\nPRIGROUP[2:0] 中断优先级值 PRI_N[7:4] 级数 二进制点 主优先级位 子优先级位 主优先级 子优先级 0b 011 0b xxxx. [7:4] None 16 None 0b 100 0b xxx.y [7:5] [4] 8 2 0b 101 0b xx.yy [7:6] [5:4] 4 4 0b 110 0b x.yyy [7] [6:4] 2 9 0b 111 0b .yyyy None [7:4] None 16 以 0b 100 为例，二进制点为 0b xxx.y，表示前 3 位 [7:5] 用来表示主优先级，取值范围 0-7，共 8 级；后 1 位 [4] 用来表示子优先级，取值范围 0-1，共 2 级。\n中断禁用/使能 中断函数 中断函数定义在 startup_stm32f10x_hd.s 中：\n; External Interrupts DCD WWDG_IRQHandler ; Window Watchdog DCD PVD_IRQHandler ; PVD through EXTI Line detect DCD TAMPER_IRQHandler ; Tamper DCD RTC_IRQHandler ; RTC DCD FLASH_IRQHandler ; Flash DCD RCC_IRQHandler ; RCC DCD EXTI0_IRQHandler ; EXTI Line 0 DCD EXTI1_IRQHandler ; EXTI Line 1 DCD EXTI2_IRQHandler ; EXTI Line 2 DCD EXTI3_IRQHandler ; EXTI Line 3 DCD EXTI4_IRQHandler ; EXTI Line 4 /* 篇幅有限，略去*/ 中断号 中断号定义在头文件 stm32f10x.h 的枚举 IRQn 中：\ntypedef enum IRQn { /* 篇幅有限，略去*/ EXTI0_IRQn = 6, /*!\u0026lt; EXTI 0号线*/ EXTI1_IRQn = 7, /*!\u0026lt; EXTI 1号线*/ EXTI2_IRQn = 8, /*!\u0026lt; EXTI 2号线*/ EXTI3_IRQn = 9, /*!\u0026lt; EXTI 3号线*/ EXTI4_IRQn = 10, /*!\u0026lt; EXTI 4号线*/ ... EXTI9_5_IRQn = 23, /*!\u0026lt; External 5号到9号线*/ ... EXTI15_10_IRQn = 40, /*!\u0026lt; External 10号到15号线*/ /* 篇幅有限，略去*/ } 操作下面两个寄存器对应中断号的位，即可禁用/使能该中断。\nNVIC_ISERx 中断使能寄存器（ Interrupt set-enable registers ） SETENA[31:0]: 中断使能\n写： 0：无效果 1：使能中断 读： 0：中断禁用 1：中断使能 NVIC_ICERx 中断清除使能寄存器（ Interrupt clear-enable registers ） CLRENA[31:0]: 清除中断使能\n写： 0：无效果 1：禁用中断 读： 0：中断禁用 1：中断使能 NVIC 结构体定义 在文件 core_cm3.h 中：\ntypedef struct { __IO uint32_t ISER[8]; /*!\u0026lt; Offset: 0x000 Interrupt Set Enable Register*/ uint32_t RESERVED0[24]; __IO uint32_t ICER[8]; /*!\u0026lt; Offset: 0x080 Interrupt Clear Enable Register*/ uint32_t RSERVED1[24]; __IO uint32_t ISPR[8]; /*!\u0026lt; Offset: 0x100 Interrupt Set Pending Register*/ uint32_t RESERVED2[24]; __IO uint32_t ICPR[8]; /*!\u0026lt; Offset: 0x180 Interrupt Clear Pending Register*/ uint32_t RESERVED3[24]; __IO uint32_t IABR[8]; /*!\u0026lt; Offset: 0x200 Interrupt Active bit Register*/ uint32_t RESERVED4[56]; __IO uint8_t IP[240]; /*!\u0026lt; Offset: 0x300 Interrupt Priority Register (8Bit wide) */ uint32_t RESERVED5[644]; __O uint32_t STIR; /*!\u0026lt; Offset: 0xE00 Software Trigger Interrupt Register*/ } NVIC_Type; 由上面可知，NVIC_ISERx 和 NVIC_ICERx 寄存器各有 8 个\n外部中断寄存器 AFIO_EXTICRx 复用功能 I/O 口（ alternate-function I/O ）\n外部中断配置寄存器（ External interrupt configuration register ）\nAFIO_EXTICR1，如下图：\n. . .\nAFIO_EXTICR2\nAFIO_EXTICR3\n. . .\nAFIO_EXTICR4，如下图：\nEXTIx[3:0]: 配置外部中断源 0000：PAx 0001：PBx 0010：PCx 0011：PDx 0100：PEx 0101：PFx 0110：PGx 对应关系如下图：\nEXTI_IMR 外部中断/事件控制器（ External interrupt/event controller (EXTI) ）\n中断屏蔽寄存器（ Interrupt mask register ）\nMRx: 屏蔽 EXTIx 中断 0：屏蔽 1：不屏蔽 EXTI_EMR 事件屏蔽寄存器（ Event mask register ） MRx: 屏蔽 EXTIx 事件 0：屏蔽 1：不屏蔽 EXTI_RTSR 上升沿触发选择寄存器（ Rising trigger selection register ） TRx: 配置 EXTIx 上升沿触发 0：禁用上升沿触发 1：使能上升沿触发 EXTI_FTSR 下降沿触发选择寄存器（Falling trigger selection register） TRx: 配置 EXTIx 下降沿触发 0：禁用下降沿触发 1：使能下降沿触发 EXTI_SWIER 软件中断事件寄存器（ Software interrupt event register ） SWIERx: 触发 EXTIx 中断 0：无效果 1：触发中断 该寄存器通过软件控制触发中断，如下图：\nEXTI_SWIER 寄存器连接到一个或门，该寄存器或外部输入信号有一个符合条件就能触发中断。\nEXTI_PR 挂起寄存器（ Pending register ） PRx: 挂起位（ Pending bit ） 0： 没有触发请求 1：EXTIx 发生了中断触发请求 当在外部中断线上发生了选择的边沿事件，该位被置 1。在该位中写入 1 可以清除它，也可以改变边沿检测的极性清除。\n例程 寄存器 void EXTI0_Config(void) { RCC-\u0026gt;APB2ENR |= (unsigned int)0x01 \u0026lt;\u0026lt; 2; //使能GPIOA时钟 GPIOA-\u0026gt;CRL |= (unsigned int)0x04 \u0026lt;\u0026lt; 0; //PA0 配置浮空输入 RCC-\u0026gt;APB2ENR |= (unsigned int)0x01 \u0026lt;\u0026lt; 0; //使能AFIO时钟 AFIO-\u0026gt;EXTICR[0] |= (unsigned int)0x00 \u0026lt;\u0026lt; 0; //连接EXTI0输入线到PA0上 SCB-\u0026gt;AIRCR |= (unsigned int)0x05 \u0026lt;\u0026lt; 8; //中断控制器配置优先级分组，主2比特子2比特 NVIC-\u0026gt;IP[0] |= (unsigned int)0xC0 \u0026lt;\u0026lt; 0; //配置优先级主3子0（0b 1100 0000） NVIC-\u0026gt;ISER[0] |= (unsigned int)0x01 \u0026lt;\u0026lt; 6; //使能EXTI0中断 EXTI-\u0026gt;IMR |= (unsigned int)0x01 \u0026lt;\u0026lt; 0; //不屏蔽EXTI0中断 EXTI-\u0026gt;RTSR |= (unsigned int)0x01 \u0026lt;\u0026lt; 0; //配置上升沿触发 } void EXTI0_IRQHandler(void) { if(EXTI-\u0026gt;PR \u0026amp; 0x01) //检查EXTI0中断挂起标志 {\tEXTI-\u0026gt;PR = 0x01; //清除EXTI0中断挂起标志 }\t} 标准库 void EXTI0_Config(void) { /* Enable GPIOA clock */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /* Configure PA.00 pin as input floating */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); /* Enable AFIO clock */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); /* Connect EXTI0 Line to PA.00 pin */ GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); /* Configure EXTI0 line */ EXTI_InitStructure.EXTI_Line = EXTI_Line0; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(\u0026amp;EXTI_InitStructure); /* Enable and set EXTI0 Interrupt to the lowest priority */ NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(\u0026amp;NVIC_InitStructure); } void EXTI0_IRQHandler(void) { if(EXTI_GetITStatus(EXTI_Line0) != RESET) { /* Toggle LED1 */ STM_EVAL_LEDToggle(LED1); /* Clear the EXTI line 0 pending bit */ EXTI_ClearITPendingBit(EXTI_Line0); } } ","permalink":"https://kingtuo123.com/posts/stm32-exti/","summary":"Note","title":"STM32 EXTI 外部中断"},{"content":" 寄存器 寄存器 说明 RCC_CR 时钟控制寄存器（Clock control register） RCC_CFGR 时钟配置寄存器（Clock configuration register） RCC_CIR 时钟中断寄存器（Clock interrupt register） RCC_APB2RSTR APB2 外设复位寄存器（APB2 peripheral reset register） RCC_APB1RSTR APB1 外设复位寄存器（APB1 peripheral reset register） RCC_AHBENR AHB 外设时钟使能寄存器（AHB peripheral clock enable register） RCC_APB2EBR APB2 外设时钟使能寄存器 （APB2 peripheral clock enable register） RCC_APB1ENR APB1 外设时钟使能寄存器 （APB1 peripheral clock enable register） RCC_BDCR 备份域控制寄存器（Backup domain control register） RCC_CSR 控制状态寄存器（Control/status register） 头文件定义 typedef struct { __IO uint32_t CR; __IO uint32_t CFGR; __IO uint32_t CIR; __IO uint32_t APB2RSTR; __IO uint32_t APB1RSTR; __IO uint32_t AHBENR; __IO uint32_t APB2ENR; __IO uint32_t APB1ENR; __IO uint32_t BDCR; __IO uint32_t CSR; #ifdef STM32F10X_CL __IO uint32_t AHBRSTR; __IO uint32_t CFGR2; #endif /* STM32F10X_CL */ #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) uint32_t RESERVED0; __IO uint32_t CFGR2; #endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */ } RCC_TypeDef; 例程 寄存器 void SetSysClockTo72(void) { __IO uint32_t StartUpCounter = 0, HSEStatus = 0; RCC_DeInit(); // 使能 HSE RCC-\u0026gt;CR |= ((uint32_t)0x01 \u0026lt;\u0026lt; 16); // 等待 HSE 启动 do{ HSEStatus = RCC-\u0026gt;CR \u0026amp; ((uint32_t)0x01 \u0026lt;\u0026lt; 17); StartUpCounter++; }while((HSEStatus == 0) \u0026amp;\u0026amp; (StartUpCounter != HSE_STARTUP_TIMEOUT)); if ((RCC-\u0026gt;CR \u0026amp; ((uint32_t)0x01 \u0026lt;\u0026lt; 17)) != RESET){ HSEStatus = (uint32_t)0x01; }else{ HSEStatus = (uint32_t)0x00; } if (HSEStatus == (uint32_t)0x01){ /* 使能 FLASH 预存取缓冲区 */ FLASH-\u0026gt;ACR |= FLASH_ACR_PRFTBE; /* Flash 2 wait state */ FLASH-\u0026gt;ACR \u0026amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY); FLASH-\u0026gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_2; // AHB 时钟 HCLK = SYSCLK 不分频 RCC-\u0026gt;CFGR |= (uint32_t)0x00 \u0026lt;\u0026lt; 4; // 高速 APB2 时钟 PCLK2 = HCLK 不分频 RCC-\u0026gt;CFGR |= (uint32_t)0x00 \u0026lt;\u0026lt; 11; // 低速 APB1 时钟 PCLK1 = HCLK/2 二分频 RCC-\u0026gt;CFGR |= (uint32_t)0x04 \u0026lt;\u0026lt; 8; // PLL 输入时钟源 HSE RCC-\u0026gt;CFGR |= (uint32_t)0x01 \u0026lt;\u0026lt; 16; // HSE 不分频 RCC-\u0026gt;CFGR |= (uint32_t)0x00 \u0026lt;\u0026lt; 17; // PLL 9倍频 PLLCLK = 8MHz * 9 = 72 MHz RCC-\u0026gt;CFGR |= (uint32_t)0x07 \u0026lt;\u0026lt; 18; // 使能 PLL RCC-\u0026gt;CR |= (uint32_t)0x01 \u0026lt;\u0026lt; 24; // 等待 PLL 时钟就绪 while((RCC-\u0026gt;CR \u0026amp; ((uint32_t)0x01 \u0026lt;\u0026lt; 25)) == 0); // 选择 PLL 作为系统时钟源 RCC-\u0026gt;CFGR |= (uint32_t)0x02 \u0026lt;\u0026lt; 0; // 等待 PLL 作为系统时钟源 while ((RCC-\u0026gt;CFGR \u0026amp; ((uint32_t)0x02 \u0026lt;\u0026lt; 2)) != (uint32_t)0x08); }else{ // HSE 启动失败 } } 标准库 void SetSysClockTo72(void) { /* RCC system reset(for debug purpose) */ RCC_DeInit(); /* Enable HSE */ RCC_HSEConfig(RCC_HSE_ON); /* Wait till HSE is ready */ HSEStartUpStatus = RCC_WaitForHSEStartUp(); if (HSEStartUpStatus == SUCCESS){ /* Enable Prefetch Buffer */ FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); /* Flash 2 wait state */ FLASH_SetLatency(FLASH_Latency_2); /* HCLK = SYSCLK */ RCC_HCLKConfig(RCC_SYSCLK_Div1); /* PCLK2 = HCLK */ RCC_PCLK2Config(RCC_HCLK_Div1); /* PCLK1 = HCLK/2 */ RCC_PCLK1Config(RCC_HCLK_Div2); /* PLLCLK = 8MHz * 9 = 72 MHz */ RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9); /* Enable PLL */ RCC_PLLCmd(ENABLE); /* Wait till PLL is ready */ while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET); /* Select PLL as system clock source */ RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); /* Wait till PLL is used as system clock source */ while(RCC_GetSYSCLKSource() != 0x08); }else{ /* If HSE fails to start-up, the application will have wrong clock configuration. User can add here some code to deal with this error */ /* Go to infinite loop */ while (1); } } ","permalink":"https://kingtuo123.com/posts/stm32-rcc-config/","summary":"Note","title":"STM32 RCC 时钟配置"},{"content":" 参考文章： gcc -ffunction-sections -fdata-sections -Wl,–gc-sections 参数详解 dwarf 调试信息存储格式 GCC STM32 链接文件和启动文件分析 源码 Github 下载地址 使用标准库 目录结构 $ tree . ├── Libraries │ ├── CMSIS │ └── STM32F10x_StdPeriph_Driver │ ├── inc │ └── src ├── makefile ├── STM32F103ZETx_FLASH.ld └── User ├── led │ ├── bsp_led.c │ └── bsp_led.h ├── main.c ├── stm32f10x_conf.h ├── stm32f10x_it.c └── stm32f10x_it.h Libraries 是从官方下载固件包中直接拷贝过来，内部目录不作调整。\nUser 是存放用户代码的目录。\nmakefile 文件 TARGET := LED-BLINK # 存放编译文件的目录 BUILD_DIR := ./Build # ARM GCC 工具链 TOOLCHAIN = arm-none-eabi- CC := $(TOOLCHAIN)gcc CP := $(TOOLCHAIN)objcopy AS := $(TOOLCHAIN)gcc -x assembler-with-cpp SZ := $(TOOLCHAIN)size HEX := $(CP) -O ihex BIN := $(CP) -O binary -S # CPU 内核架构 CPU := cortex-m3 # 链接脚本 LINK_SCRIPT := ./STM32F103ZETx_FLASH.ld # gcc 预定义参数 DEFS := -D STM32F10X_HD -D USE_STDPERIPH_DRIVER # 标准库头文件路径 INC_DIR := ./Libraries/CMSIS/CM3/CoreSupport/ INC_DIR += ./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/ INC_DIR += ./Libraries/STM32F10x_StdPeriph_Driver/inc/ # 启动文件 ASM_SRC := ./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/startup_stm32f10x_hd.s # CMSIS 内核文件 C_SRC := ./Libraries/CMSIS/CM3/CoreSupport/core_cm3.c C_SRC += ./Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c # 标准库外设源码 C_SRC += $(wildcard ./Libraries/STM32F10x_StdPeriph_Driver/src/*.c) # 用户头文件路径 INC_DIR += ./User/ INC_DIR += ./User/led/ # 用户代码 C_SRC += $(wildcard ./User/*.c) C_SRC += $(wildcard ./User/led/*.c) # 目标文件 C_OBJ := $(addprefix $(BUILD_DIR)/,$(notdir $(C_SRC:.c=.o))) ASM_OBJ := $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SRC:.s=.o))) # 编译参数 CP_FLAGS := $(addprefix -I,$(INC_DIR)) -mcpu=$(CPU) -g -gdwarf-2 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP $(DEFS) # 汇编参数 AS_FLAGS := $(addprefix -I,$(INC_DIR)) -mcpu=$(CPU) -g -gdwarf-2 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP # 链接参数 LD_FLAGS := -mcpu=$(CPU) -specs=nano.specs -T $(LINK_SCRIPT) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref,--gc-sections # 设置 make 文件搜索路径，.h文件由 gcc -I 参数包含了 vpath %.c $(sort $(dir $(C_SRC))) vpath %.s $(sort $(dir $(ASM_SRC))) # 保留目标文件，make 默认会删除编译生成的 .o 文件 .PRECIOUS: $(BUILD_DIR)/%.o # 编译规则 .PHONY: all all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).bin $(BUILD_DIR)/$(TARGET).hex @echo \u0026#34;-------------------------------------------------------------------------------\u0026#34; $(SZ) $(BUILD_DIR)/$(TARGET).elf @echo \u0026#34;-------------------------------------------------------------------------------\u0026#34; @stat $(BUILD_DIR)/$(TARGET).bin | head -n2 @echo \u0026#34;-------------------------------------------------------------------------------\u0026#34; $(BUILD_DIR)/%.o: %.c $(CC) -c $(CP_FLAGS) $\u0026lt; -o $@ $(BUILD_DIR)/%.o: %.s $(AS) -c $(AS_FLAGS) $\u0026lt; -o $@ %.elf: $(C_OBJ) $(ASM_OBJ) $(CC) $(LD_FLAGS) $^ -o $@ %.hex: %.elf $(HEX) $\u0026lt; $@ %.bin: %.elf $(BIN) $\u0026lt; $@ $(BUILD_DIR): mkdir -p $@ # 下面是清理和烧录命令 clean: rm $(BUILD_DIR)/* -rf rebuild: make clean \u0026amp;\u0026amp; make install: st-flash write $(BUILD_DIR)/$(TARGET).bin 0x8000000 st-flash: st-flash write $(BUILD_DIR)/$(TARGET).bin 0x8000000 st-erase: st-flash erase isp-flash: stm32flash -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; -v -w $(BUILD_DIR)/$(TARGET).bin /dev/ttyUSB0 isp-erase: stm32flash -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; -o /dev/ttyUSB0 isp-info: stm32flash -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; /dev/ttyUSB0 # 包含由 gcc -MMD 参数生成的 .d 文件 -include $(BUILD_DIR)/*.d STM32F103ZETx_FLASH.ld 链接脚本 链接脚本使用 STM32CubeMX 生成：\n随便建个工程，按图中所示选择 Makefile 生成代码即可，如下：\n// 设置入口符号 ENTRY(Reset_Handler) // 初始栈顶地址 _estack = ORIGIN(RAM) + LENGTH(RAM); // 设置堆栈大小 _Min_Heap_Size = 0x200; _Min_Stack_Size = 0x400; MEMORY { // RAM 起始地址和大小 RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K // FLASH 起始地址和大小 FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 512K } // 后面是段的分配，一般不需要改 // 略... 编译出错解决 $ make /tmp/cceEC3n9.s:599: Error: registers may not be the same -- `strexb r0,r0,[r1]\u0026#39; /tmp/cceEC3n9.s:629: Error: registers may not be the same -- `strexh r0,r0,[r1]\u0026#39; 修改标准库中 Libraries/CMSIS/CM3/CoreSupport/core_cm3.c 文件\n将 __STREXB 和 __STREXH 函数中的 =r 改为 =\u0026amp;r ，一共有两处：\n__ASM volatile (\u0026#34;strexb %0, %2, [%1]\u0026#34; : \u0026#34;=\u0026amp;r\u0026#34; (result) : \u0026#34;r\u0026#34; (addr), \u0026#34;r\u0026#34; (value) ); 貌似是 gcc 编译优化导致的问题，参考下列文章：\nError: registers may not be the same \u0026ndash; strexb r0,r0,[r1] Fix registers may not be the same ARM GCC error gcc编译后出现与CMSIS相关的错误 成功编译后如下：\n$ make ------------------------------------------------------------------------------- arm-none-eabi-size ./Build/LED-BLINK.elf text data bss dec hex filename 1812 8 5152 6972 1b3c ./Build/LED-BLINK.elf ------------------------------------------------------------------------------- File: ./Build/LED-BLINK.bin Size: 1820 Blocks: 8 IO Block: 4096 regular file ------------------------------------------------------------------------------- GCC 参数说明 参数 说明 -D STM32F10X_HD 表示芯片容量 -D USE_STDPERIPH_DRIVER 表示使用官方标准固件库 -mcpu=cortex-m3 指定芯片内核架构 -g 产生调试信息 -gdwarf-2 调试信息格式 -mthumb 表示使用 thumb 指令集 -Os 优化代码大小 -Wall 允许输出所有警告 -MMD 生成依赖关系文件 .d，依赖不包括系统头文件 -MP 依赖规则中的所有 .h 依赖项都会在该文件中生成一个伪目标，其不依赖任何其他依赖项 -fdata-sections 为每个 data item 分配独立的 section，方便后面链接器优化 -ffunction-sections 为每个 function 分配独立的 section，方便后面链接器优化 -specs=nano.specs 使用精简版的C库替代标准C库，可以减少最终程序映像的大小 -T 指定链接脚本 -Wl 表示后面跟的参数传递给链接器，用逗号分隔 -Map=\u0026lt;filename\u0026gt; 生成 map 映射文件 \u0026ndash;cref Cross Reference 的简写，输出交叉引用表 \u0026ndash;gc-sections 不链接未用函数，减小可执行文件大小 使用 HAL 库 目录结构 . ├── Drivers │ ├── CMSIS │ │ ├── Device │ │ └── Include │ └── STM32F1xx_HAL_Driver │ ├── Inc │ └── Src ├── makefile ├── STM32F103ZETx_FLASH.ld └── User ├── led │ ├── bsp_led.c │ └── bsp_led.h ├── main.c ├── stm32f1xx_hal_conf.h ├── stm32f1xx_it.c └── stm32f1xx_it.h Drivers 从 HAL 库包中直接拷贝，不做调整。 makefile 只列出一部分，其它部分与上面标准库的 makefile 相同 # gcc 预定义参数 DEFS := -D USE_HAL_DRIVER -D STM32F103xE # HAL 库头文件路径 INC_DIR := ./Drivers/CMSIS/Include/ INC_DIR += ./Drivers/CMSIS/Device/ST/STM32F1xx/Include/ INC_DIR += ./Drivers/STM32F1xx_HAL_Driver/Inc/ # 启动文件 ASM_SRC := ./Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/gcc/startup_stm32f103xe.s # CMSIS 系统文件 C_SRC := ./Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/system_stm32f1xx.c # HAL 库外设源文件，最后去掉几个 template 模板文件 C_SRC += $(wildcard ./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal*.c) C_SRC += ./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usb.c C_SRC += ./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_sdmmc.c C_SRC += ./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_fsmc.c C_SRC := $(filter-out %template.c, $(C_SRC)) 使用 LL 库 目录结构 . ├── Drivers │ ├── CMSIS │ │ ├── Device │ │ └── Include │ └── STM32F1xx_HAL_Driver │ ├── Inc │ └── Src ├── makefile ├── STM32F103ZETx_FLASH.ld └── User ├── led │ ├── bsp_led.c │ └── bsp_led.h ├── main.c ├── stm32f1xx_it.c └── stm32f1xx_it.h makefile # gcc 预定义参数 DEFS := -D STM32F103xE \\ -D USE_FULL_LL_DRIVER \\ -D HSE_VALUE=8000000 \\ -D HSE_STARTUP_TIMEOUT=100 \\ -D LSE_STARTUP_TIMEOUT=5000 \\ -D LSE_VALUE=32768 \\ -D HSI_VALUE=8000000 \\ -D LSI_VALUE=40000 \\ -D VDD_VALUE=3300 \\ -D PREFETCH_ENABLE=1 # LL 库头文件路径 INC_DIR := ./Drivers/CMSIS/Include/ INC_DIR += ./Drivers/CMSIS/Device/ST/STM32F1xx/Include/ INC_DIR += ./Drivers/STM32F1xx_HAL_Driver/Inc/ # 启动文件 ASM_SRC := ./Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/gcc/startup_stm32f103xe.s # CMSIS 系统文件 C_SRC := ./Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/system_stm32f1xx.c # LL 库外设源文件，后面 3 个依赖 HAL 库，去掉 C_SRC += $(wildcard ./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll*.c) C_SRC := $(filter-out %ll_usb.c, $(C_SRC)) C_SRC := $(filter-out %ll_sdmmc.c, $(C_SRC)) C_SRC := $(filter-out %ll_fsmc.c, $(C_SRC)) ","permalink":"https://kingtuo123.com/posts/build-stm32-in-linux/","summary":"使用 make 管理 stm32 工程","title":"Linux 下编译 STM32"},{"content":" 基于 STM32F10x 系列 GPIO 寄存器 GPIOx_CRL 端口配置低位寄存器（0-7脚）（ Port configuration register low ） GPIO_CRH 端口配置高位寄存器（8-15脚）（ Port configuration register high ） 每一个引脚有4位可配置\nMODE：模式设置\n00：输入模式 01：输出模式，最大 10 MHZ 10：输出模式，最大 2 MHZ 11：输出模式，最大 50 MHZ CNF：输入模式配置\n00：模拟输入 01：浮空输入 10：上拉/下拉输入 11：保留 CNF：输出模式配置\n00：推挽输出 01：开漏输出 10：复用推挽输出 11：复用开漏输出 GPIOx_IDR 端口输入数据寄存器（ Port input data register ） 0-15 位只读，读出的数值为 IO 口对应状态\nGPIOx_ODR 端口输出数据寄存器（ Port output data register ） 0-15 位可读写\nGPIOx_BSRR 端口位设置/清除寄存器（ Port bit set/reset register ） 31:16 位：复位（只写）\n0：不做操作 1：清除对应 ODRy 位为 0，就是对应引脚拉低电平 15:0 位：置位（只写）\n0：不做操作 1：设置对应 ODRy 位为 1 GPIOx_BRR 端口位清除寄存器（ Port bit reset register ） 结构同 GPIOx_IDR ，0-15 位只写 0：不做操作 1：清除对应 ODRy 位为 0 GPIOx_LCKR 端口配置锁定寄存器（ Port configuration lock register ） 用来锁定对应位的端口位配置，当端口被锁定时，不再有可能修改它的值，直到系统复位。每一个锁都冻结相应的4位控制寄存器 (CRL,CRH)\nLCKK[16]: 锁键，写入序列：写1 -\u0026gt; 写0 -\u0026gt; 写1 -\u0026gt; 读0 -\u0026gt; 读1\n0：LCKy 配置未激活 1：LCKy 配置已激活，激活后只能通过复位解锁 LCKy: 端口 x 的锁位，只能在 LCKK 位为 0 时写入\n0：不锁定端口配置 1：锁定端口配置 例程 if(GPIOA-\u0026gt;LCKR \u0026amp; (unsigned int)0x01 \u0026lt;\u0026lt; 16){ GPIOA-\u0026gt;LCKR |= (unsigned int)0x01 \u0026lt;\u0026lt; 16; GPIOA-\u0026gt;LCKR \u0026amp;= ~((unsigned int)0x01 \u0026lt;\u0026lt; 16); GPIOA-\u0026gt;LCKR |= (unsigned int)0x01 \u0026lt;\u0026lt; 16; } 标准库头文件定义 typedef struct { __IO uint32_t CRL; __IO uint32_t CRH; __IO uint32_t IDR; __IO uint32_t ODR; __IO uint32_t BSRR; __IO uint32_t BRR; __IO uint32_t LCKR; } GPIO_TypeDef; 例程 寄存器 void GPIO_Config(void){ RCC-\u0026gt;APB2ENR |= (unsigned int)0x01 \u0026lt;\u0026lt; 2; //使能GPIOA时钟 GPIOA-\u0026gt;CRL |= (unsigned int)0x03 \u0026lt;\u0026lt; 4; //配置PA1推挽输出，最高50MHZ } 标准库 void GPIO_Config(void){ /* 定义一个 GPIO_InitTypeDef 类型的结构体 */ GPIO_InitTypeDef GPIO_InitStructure; /* 开启相关的 GPIO 外设时钟 */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); /* 选择要控制的 GPIO 引脚 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; /* 设置引脚模式为通用推挽输出 */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; /* 设置引脚速率为 50MHz */ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* 调用库函数，初始化 GPIO*/ GPIO_Init(GPIOB, \u0026amp;GPIO_InitStructure); } ","permalink":"https://kingtuo123.com/posts/stm32-gpio/","summary":"Note","title":"STM32 GPIO"},{"content":"类似于51单片机中 sbit LED = P0^1; 直接操作 LED 变量就可以控制 P0_1 端口了。\nSTM32 中是通过对处在 位带区 的寄存器的对应位映射到 别名区 ，再通过操作 别名区 来控制对应寄存器的位。\nSTM32 是32位系统总线，所以位带区的一个位对应别名区会膨胀为32位，即四个字节。\n位带区 外设位带区的地址为：0X40000000 ~ 0X40100000\nSRAM 的位带区的地址为：0X20000000 ~ X20100000\n位带别名区地址 对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n∈[0,7]，\n则该比特在别名区的地址为：\nAliasAddr = 0x42000000 + (A - 0x40000000)*8*4 + n*4 0x42000000：别名区起始地址 (A - 0x40000000)：外设地址相对基地址偏移多少个字节 (A - 0x40000000)*8：偏移的字节总共有多少位，所以乘 8 (A - 0x40000000)*8*4：每一位膨胀为 32 位（四个字节），所以乘 4 n*4：所在字节上的第 n 位膨胀为 32 位，所以乘 4 操作别名区只对 LSB 有效，即第 0 位\n同样对于 SRAM 位带区的某个比特在别名区的地址为：\nAliasAddr = 0x22000000 + (A - 0x20000000)*8*4 + n*4 统一公式 #define BITBAND(addr, bitnum) ((addr \u0026amp; 0xF0000000) + 0x02000000 + ((addr \u0026amp; 0x000FFFFF)\u0026lt;\u0026lt;5) + (bitnum\u0026lt;\u0026lt;2)) 最后我们就可以通过指针的形式操作这些位带别名区地址，最终实现位带区的比特位操作。\n// 把一个地址转换成一个指针 #define MEM_ADDR(addr) *((volatile unsigned long *)(addr)) // 把位带别名区地址转换成指针 #define BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum)) GPIO 位带操作 #define BITBAND(addr, bitnum) ((addr \u0026amp; 0xF0000000) + 0x02000000 + ((addr \u0026amp; 0x000FFFFF)\u0026lt;\u0026lt;5) + (bitnum\u0026lt;\u0026lt;2)) #define MEM_ADDR(addr) *((volatile unsigned long *)(addr)) #define BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum)) // GPIOA ODR 寄存器地址映射 #define GPIOA_ODR_Addr (GPIOA_BASE+0x0C) // 单独操作 GPIO 的某一个 IO 口，n(0,1,2...16),n 表示具体是哪一个 IO 口 #define PAout(n) BIT_ADDR(GPIOA_ODR_Addr,n) int main(void){ /* LED 端口初始化 */ LED_GPIO_Config(); while(1){ PAout(10) = 0;\t// PA10 = 0,点亮 LED SOFT_Delay(0x0FFFFF); PAout(10) = 1;\t// PA10 = 1,熄灭 LED SOFT_Delay(0x0FFFFF); } } ","permalink":"https://kingtuo123.com/posts/stm32-bit-banding/","summary":"Note","title":"STM32 位带操作"},{"content":" 问题：MPD 与其他应用如 Firefox 冲突，导致另一个应用没有声音 MPD 编辑 /etc/mpd.conf\nuser \u0026#34;mpd\u0026#34; music_directory \u0026#34;/var/lib/mpd/music\u0026#34; playlist_directory \u0026#34;/var/lib/mpd/playlists\u0026#34; db_file \u0026#34;/var/lib/mpd/database\u0026#34; log_file \u0026#34;/var/lib/mpd/log\u0026#34; pid_file \u0026#34;/var/lib/mpd/pid\u0026#34; state_file \u0026#34;/var/lib/mpd/state\u0026#34; bind_to_address \u0026#34;127.0.0.1\u0026#34; port \u0026#34;6600\u0026#34; restore_paused \u0026#34;yes\u0026#34; audio_output { type \u0026#34;pulse\u0026#34; name \u0026#34;My PULSE Device\u0026#34; server \u0026#34;127.0.0.1\u0026#34; } 注意 server 不要填 localhost ，因为 MPD 可能会访问 ipv6 的 localhost 即 ::1，导致连接失败\n可能需要添加 mpd 到 audio 组\n/var/lib/mpd/music 存放用户音频，这里我用的链接到用户目录\n$ ls -al /var/lib/mpd/music lrwxrwxrwx 1 root root 17 Jun 10 21:16 /var/lib/mpd/music -\u0026gt; /home/king/Music/ $ ls -ld Music/ drwxr-xr-x 2 mpd audio 12288 Jun 19 06:41 Music/ PulseAudio 编辑 /etc/pulse/default.pa ，增加下面一行\nload-module module-native-protocol-tcp auth-ip-acl=127.0.0.1 ","permalink":"https://kingtuo123.com/posts/mpd-config/","summary":"解决 MPD 与其他应用音频冲突","title":"MPD PulseAudio 配置"},{"content":" 参考文章： ldconfig ldconfig 命令 概述 ldconfig 搜索 /lib，/usr/lib 和 /etc/ld.so.conf 文件内所列的目录，找到可共享的动态链接库，为动态装载程序 ld.so 创建所需的链接和缓存。\n缓存文件默认为 /etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。\nldconfig 通常在系统启动时运行，当用户安装了一个新的动态链接库时，就需要手动运行这个命令。\n参数 参数 说明 -v 显示正在扫描的目录及搜索到的动态链接库以及所创建的链接的名字 -n 仅扫描命令行指定的目录，不扫描默认目录，也不扫描配置文件所列的目录 -N 不重建缓存文件 -X 不更新文件的链接 -f conf 指定动态链接库的配置文件为 conf，系统默认是 /etc/ld.so.conf -C cache 指定生成的缓存文件为 cache，系统默认是 /etc/ld.so.cache -r root 改变应用程序的根目录为 root -l 进入专家模式手动设置链接 -p 打印当前缓存文件 -c format 指定缓存文件的格式 -V 打印 ldconfig 版本信息 --help 打印帮助信息 示例 将 libfoo.so 添加到系统共享库中：\n# cp libfoo.so /usr/lib # chmod 0755 /usr/lib/libfoo.so 更新共享库缓存列表：\n# ldconfig 更新完成后检查（从当前缓存文件的中搜索 libfoo.so 库）：\n# ldconfig -p | grep foo libfoo.so (libc6) =\u0026gt; /usr/lib/libfoo.so LIBRARY_PATH 和 LD_LIBRARY_PATH 区别 LIBRARY_PATH：编译程序时用到\nLD_LIBRARY_PATH：程序运行时用到\n/etc/ld.so.conf 和 LD_LIBRARY_PATH 具有同等的作用，程序运行时链接库的时候，优先链接后者，即环境变量 LD_LIBRARY_PATH 目录下的库。如果不能满足一些共享库相关性要求，则转回到 /etc/ld.so.conf 中指定的库。\n/etc/ld.so.conf 由 env-update 生成，这些路径来自 /etc/env.d/ 下的文件，如下：\n$ grep LDPATH /etc/env.d/ -r /etc/env.d/60llvm-9985:LDPATH=\u0026#34;/usr/lib/llvm/14/lib64\u0026#34; /etc/env.d/50baselayout:LDPATH=\u0026#39;/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib\u0026#39; /etc/env.d/00glibc:LDPATH=\u0026#34;include ld.so.conf.d/*.conf\u0026#34; /etc/env.d/50rust-bin-1.60.0:LDPATH=\u0026#34;/usr/lib/rust/lib\u0026#34; /etc/env.d/gcc/x86_64-pc-linux-gnu-11.3.0:LDPATH=\u0026#34;/usr/lib/gcc/x86_64-pc-linux-gnu/11.3.0:/usr/lib/gcc/x86_64-pc-linux-gnu/11.3.0/32\u0026#34; 如果修改了 /etc/env.d/ 下的文件，执行以下命令\n# env-update # ldconfig ","permalink":"https://kingtuo123.com/posts/ldconfig/","summary":"动态链接库管理命令","title":"ldconfig"},{"content":"安装 参考：Linux 下搭建 STM32 开发环境\n命令 stlink 安装后有这几个命令：\nst-info st-flash st-trace st-util st-info 读取设备信息 参数 说明 --version 打印版本信息 --flash 显示设备中可用的 flash 数量 --sram 显示设备中可用的 sram 内存量 --descr 显示设备的文字描述 --pagesize 显示设备的页面大小 --chipid 显示设备的芯片ID --serial 显示设备的序列号 --probe 显示连接的编程器和设备的汇总信息 st-flash 读写 flash 常用示例：\n# 烧录 bin 文件 st-flash --format binary write firmware.bin 0x08000000 # 烧录 hex 文件 st-flash --format ihex write firmware.hex # 从 FLASH 读取 0x1000 个字节 st-flash read firmware.bin 0x08000000 0x1000 # 擦除 FLASH st-flash erase st-trace 未完待续\nst-util 未完待续\n","permalink":"https://kingtuo123.com/posts/stlink-linux/","summary":"几个常用的命令行下载工具","title":"Linux 使用 stlink 下载 stm32"},{"content":" ST标准外设库 参考\u0026amp;数据手册 ST英文官网-参考手册 半导小芯-数据手册 Keil Pack STM32CubeMX HAL 库 ","permalink":"https://kingtuo123.com/posts/stm32-resources/","summary":"一些常用资源的下载链接","title":"STM32 常用资源"},{"content":"arm gcc 工具链 下载地址 解压：\n$ tar xvf gcc-arm-*-arm-none-eabi.tar.xz 安装：\n$ sudo mv gcc-arm-*-arm-none-eabi /opt/arm-none-eabi-gcc 添加 PATH 到 /etc/profile：\nexport PATH=${PATH}:/opt/arm-none-eabi-gcc/bin ISP 串口下载工具 下载地址 解压：\n$ tar xvf stm32flash-0.7.tar.gz 编译：\n$ cd stm32flash-0.7/ $ make 安装，默认安装路径 /usr/local/bin：\n$ sudo make install 使用方法详见：ISP 一键下载\n串口驱动安装：CH340 驱动\nST-LINK 下载工具 下载地址：选择 Source Code 解压：\n$ tar xvf stlink-1.7.0.tar.gz 安装依赖库（可选）：\n$ sudo emerge -av virtual/libusb 编译安装：\n$ cd stlink-1.7.0/ $ make release $ make debug $ sudo make install 测试：\n$ st-info --version libstlink.so.1: cannot open shared object file: No such file or directory $ sudo ldconfig # 如果显示上面的信息，则执行该命令 $ st-info --version v1.7.0 使用方法详见：使用 stlink 烧录程序 STM32CubeMX 安装 CubeMX 下载地址 HAL 库下载地址 解压：\n$ unzip en.stm32cubemx-lin-v6-9-1.zip 安装：\n$ sudo ./SetupSTM32CubeMX-6.9.1 HAL 库导入：Help -\u0026gt; Manage embedded software packages -\u0026gt; From Local\nopenocd 安装 Gentoo 软件仓库有：\n# emerge -av dev-embedded/openocd gdb Gentoo 需要启用 USE 标记 multitarget，其他发行版安装 gdb-multiarch 这个包\n# emerge -av sys-devel/gdb ","permalink":"https://kingtuo123.com/posts/linux-stm32-development/","summary":"安装 gcc 工具链，isp / stlink 下载工具","title":"Linux 下搭建 stm32 开发环境"},{"content":"参考 gentoo wiki：\nQEMU Virt-manager QEMU 内核配置 参考 QEMU#Kernel\nUSE 标记 QEMU 是一款开源的模拟器，提供两种使用模式：user mode 和 system mode。user mode 可在 Host 主机下直接执行目标架构程序。system mode 可以在Host主机下启动目标架构的操作系统并执行应用程序。\n下面的 softmmu 对应 system mode，user 对应 user mode\n在 /etc/portage/make.conf 中添加全局的标记\nQEMU_SOFTMMU_TARGETS=\u0026#34;arm x86_64 sparc\u0026#34; QEMU_USER_TARGETS=\u0026#34;x86_64\u0026#34; 或者在 /etc/portage/package.use 中添加\napp-emulation/qemu qemu_softmmu_targets_arm qemu_softmmu_targets_x86_64 qemu_softmmu_targets_sparc app-emulation/qemu qemu_user_targets_x86_64 按需添加，使用 equery u app-emulation/qemu 查看 use 标记。\n如果要使用 virt-manager ，usbredir 和 spice 也要添加进去。\n安装 emerge --ask app-emulation/qemu 添加用户到 kvm 组：\ngpasswd -a \u0026lt;username\u0026gt; kvm 用法 参考 QEMU#Command_line\n安装 virt-manager qemu 只提供命令行，virt-manager 是它的前端应用。\n内核配置，参考 Virt-manager#Kernel\n[*] Networking support Networking Options ---\u0026gt; [*] Network packet filtering framework (Netfilter) ---\u0026gt; [*] Advanced netfilter configuration Core Netfilter Configuration ---\u0026gt; \u0026lt;*\u0026gt; \u0026#34;conntrack\u0026#34; connection tracking match support \u0026lt;*\u0026gt; CHECKSUM target support IPv6: Netfilter Configuration ---\u0026gt; \u0026lt;*\u0026gt; ip6tables NAT support \u0026lt;*\u0026gt; Ethernet Bridge tables (ebtables) support ---\u0026gt; \u0026lt;*\u0026gt; ebt: nat table support \u0026lt;*\u0026gt; ebt: mark filter support [*] QoS and/or fair queueing ---\u0026gt; \u0026lt;*\u0026gt; Hierarchical Token Bucket (HTB) \u0026lt;*\u0026gt; Stochastic Fairness Queueing (SFQ) \u0026lt;*\u0026gt; Ingress/classifier-action Qdisc \u0026lt;*\u0026gt; Netfilter mark (FW) \u0026lt;*\u0026gt; Universal 32bit comparisons w/ hashing (U32) [*] Actions \u0026lt;*\u0026gt; Traffic Policing 安装\nemerge --ask app-emulation/virt-manager 添加用户到组\nusermod -a -G libvirt \u0026lt;user\u0026gt; 取消文件 /etc/libvirt/libvirtd.conf 下面几行的注释\nauth_unix_ro = \u0026#34;none\u0026#34; auth_unix_rw = \u0026#34;none\u0026#34; unix_sock_group = \u0026#34;libvirt\u0026#34; unix_sock_ro_perms = \u0026#34;0777\u0026#34; unix_sock_rw_perms = \u0026#34;0770\u0026#34; 添加开机启动\nrc-update add libvirtd default 遇到的问题 libvirtd 启动服务失败 net.wlp2s0 |wlp2s0: CTRL-EVENT-DSCP-POLICY clear_all net.wlp2s0 |wlp2s0: CTRL-EVENT-DSCP-POLICY clear_all net.wlp2s0 |nl80211: deinit ifname=wlp2s0 disabled_11b_rates=0 net.wlp2s0 | * start-stop-daemon: failed to start `/usr/sbin/wpa_supplicant\u0026#39; net.wlp2s0 | * ERROR: net.wlp2s0 failed to start libvirtd 需要 net 服务，由于我是直接用 wpa_supplicant 联网，并未启用 net.wlp2s0。\n故在 /etc/conf.d/libvirtd 中注释掉下面一行\n#rc_need=\u0026#34;net\u0026#34; Couldn\u0026rsquo;t load target \u0026lsquo;REJECT\u0026rsquo; virt-manager 启用 NAT 时报错\nCouldn\u0026#39;t load target `REJECT\u0026#39;:No such file or directory 解决: 启用 REJECT 相关的内核参数，参考 wiki iptables 。\n","permalink":"https://kingtuo123.com/posts/gentoo-qemu/","summary":"Gentoo qemu virt-manager 安装配置","title":"Gentoo qemu 安装记录"},{"content":"参考文档\nDockerfile reference Docker 从入门到实践 常用指令 FROM 设置基础镜像：\nFROM \u0026lt;image name\u0026gt; MAINTAINER 已弃用，用 LABEL 替代\n设置镜像作者：\nMAINTAINER \u0026lt;author name\u0026gt; LABLE 设置元数据（键值对）：\nLABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 可替代 MATINTAINER 设置作者：\nLABEL author=king 其他常用的设置还有：version、description、other 等任意参数。\nRUN 编译镜像时运行的脚本：\nRUN \u0026lt;command\u0026gt; RUN [ \u0026#34;\u0026lt;command\u0026gt;\u0026#34; , \u0026#34;[param1]\u0026#34; , \u0026#34;[param2]\u0026#34; ] 如：\nRUN set -ex; apt update \u0026amp;\u0026amp; \\ apt install -y vim 注意：尽量减少 RUN 命令的个数，一个 RUN 就会创建一层 layer 使用 set -x 或 set -ex 开头，查看 man set。\nCOPY 复制文件：\nCOPY \u0026lt;src\u0026gt; \u0026lt;image dest\u0026gt; 如：\nCOPY package.json /usr/src/app/ COPY hom* /mydir/ COPY hom?.txt /mydir/ ADD 复制文件（比 COPY 更高级）：\nADD \u0026lt;src\u0026gt; \u0026lt;image dest\u0026gt; \u0026lt;src\u0026gt; 可以是一般文件、目录，压缩文件（自动解压）、URL（自动下载，不解压），如：\nADD test.txt /mydir ADD bin /mydir ADD nginx.tar.gz /usr ADD http://example.com/nginx.tar.gz /mydir WORKDIR 指定工作目录：\nWORKDIR \u0026lt;image path\u0026gt; 如下 a.txt 会被拷贝到 /mydir ：\nWORKDIR /mydir COPY a.txt . USER 指定当前用户，USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN、CMD 以及 ENTRYPOINT 这类命令的身份。\nRUN groupadd -r redis \u0026amp;\u0026amp; useradd -r -g redis redis USER redis RUN [ \u0026#34;redis-server\u0026#34; ] VOLUME 设置容器匿名挂载卷：\nVOLUME [ \u0026#34;\u0026lt;dir\u0026gt;\u0026#34; , \u0026#34;\u0026lt;dir\u0026gt;\u0026#34; , \u0026#34;...\u0026#34; ] VOLUME \u0026lt;dir\u0026gt; EXPOSE 声明运行时容器提供服务的端口：\nEXPOSE \u0026lt;port\u0026gt;[/protocol] 如：\nEXPOSE 80/tcp EXPOSE 80/udp EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。\n在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n如果指定了 \u0026ndash;net=host 宿主机网络模式，容器中 EXPOSE 指令暴露的端口会直接使用宿主机对应的端口，不存在映射关系\nCMD 设置容器启动命令：\nCMD \u0026lt;command\u0026gt; CMD [ \u0026#34;\u0026lt;command\u0026gt;\u0026#34; , [\u0026#34;param1\u0026#34;] , [\u0026#34;param2\u0026#34;] ... ] 如：\nCMD [\u0026#34;zsh\u0026#34;] docker run -it ubuntu 后面不跟命令，启动后会默认打开 zsh 。\ndocker run -it ubuntu /bin/bash 中的 /bin/bash 会替换 dockerfile 中定义的 CMD，启动后会打开 bash 。\nENTRTPOINT 设置容器入口程序：\n# exec 格式 ENTRYPOINT [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] # shell 格式 ENTRYPOINT command param1 param2 ENTRYPOINT 和 CMD 一样，都是在指定容器启动程序及参数。当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：\n\u0026lt;ENTRYPOINT\u0026gt; \u0026#34;\u0026lt;CMD\u0026gt;\u0026#34; 如：\nENTRYPOINT [ \u0026#34;ls\u0026#34; ] docker run -it ubuntu -al 中的 -al 为 \u0026lt;CMD\u0026gt;，作为参数传递给 ENTRYPOINT ，相当于启动时执行了 ls-al 。\nENV 设置环境变量：\nENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt; ... 如：\nENV VERSION=1.0 DEBUG=on \\ NAME=\u0026#34;Happy Feet” ARG 构建参数和 ENV 的效果一样，都是设置环境变量。\nARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] 所不同的是，ARG 所设置的是 构建环境 的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。\nDockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg \u0026lt;参数名\u0026gt;=\u0026lt;值\u0026gt; 来覆盖。\nARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于 FROM 指令中。\nARG DOCKER_USERNAME=library FROM ${DOCKER_USERNAME}/alpine RUN set -x ; echo ${DOCKER_USERNAME} ONBUILD ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN、COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。\nONBUILD RUN echo \u0026#34;--- i am onbuild ---\u0026#34; ","permalink":"https://kingtuo123.com/posts/dockerfile/","summary":"dockerfile 常用指令","title":"Dockerfile"},{"content":"参考资料：\nV2rayA 文档 有完整的安装教程 V2rayA 仓库 v2ray-core 仓库 安装 v2ray-core V2rayA 是 Linux 的 V2Ray 客户端，依赖 v2ray-core 运行。\n从这里下载 v2ray-core release 。\n解压后文件夹内有 v2ctl 和 v2ray， ln 链接一下即可。\n安装 V2rayA 从这里下载 v2raya release。\n解压后文件夹内有 v2raya，链接一下。\n客户端设置 root 运行 sudo v2raya 。\n非 root 运行 v2raya --lite ，但没有透明代理等功能。\n浏览器打开 127.0.0.1:2017，首次需要设置用户名密码。\n忘记密码执行 sudo v2raya --reset-password 重置。\n","permalink":"https://kingtuo123.com/posts/v2raya-deploy/","summary":"Linux下V2rayA安装配置","title":"V2rayA 安装配置"},{"content":"安装 vim-plug curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 在 .vimrc 中添加插件，格式如下：\ncall plug#begin() Plug \u0026#39;\u0026lt;插件\u0026gt;\u0026#39; call plug#end() Command Description PlugInstall [name ...] [#threads] 安装插件 PlugUpdate [name ...] [#threads] 安装或更新插件 PlugClean[!] 删除未列出的插件 PlugUpgrade 升级 vim-plug PlugStatus 检查插件的状态 PlugDiff 检查上一次更新的更改和待处理的更改 PlugSnapshot[!] [output path] 生成用于恢复当前插件快照的脚本 常用插件 外观及主题：\nPlug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;arcticicestudio/nord-vim\u0026#39; 常用插件的替代品：\nNERDTree：可以用 vim 自带的 netrw 替代 YouCompleteMe：用 ctrl-p 和　ctrl-n 替代 ","permalink":"https://kingtuo123.com/posts/vim-configuration/","summary":"Linux下Vim插件管理/安装配置","title":"Vim 配置"},{"content":" 本文翻译自 Autodependencies with GNU make 水平有限仅供参考。\n问题描述 编译器将 C 源文件（.c 文件）和一些头文件（.h 文件）编译成目标文件（.o 文件）。 make 是一种编排构建过程的工具，因此每当源文件更改时，依赖它的文件都会重新构建。\n虽然 make 能很好地处理 .o 文件对 .c 文件的依赖关系，但它没有内置工具来确定对 .h 文件的依赖关系，也没有方便的表达方式。更重要的是，任何解决方案都必须处理好自动生成的源文件。\n本文概述了我对这个问题的解决方案，实际上非常简单。我最初写这个是因为我认为它是原创的，但事实证明 Paul Smith 已经记录了这个 解决方案。\n情景描述 假设我有一个像这样的（GNU）Makefile：\nOBJS := foo.o bar.o # 链接 proggie: $(OBJS) gcc $(OBJS) -o proggie # 编译 %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o # 清除编译生成的文件 clean: rm -f proggie *.o 这个 Makefile 中描述了两个源文件 foo.c 和 bar.c，它们被编译和链接以生成可执行的 proggie。它还描述了在一般情况下如何在给定 .c 文件的情况下构建 .o 文件。\n但是，假设 foo.c 和 bar.c 都包含 foo.h。这意味着各自的 .o 文件都依赖于 foo.h 的内容，但这一事实并未在 Makefile 中表达。因此，如果程序员更改了 foo.h，那么程序在重建时很可能会出现不一致。\n当然可以添加更多行，例如：\nfoo.o: foo.h bar.o: bar.h 但很明显，除了最小的程序之外，这后续维护起来是个麻烦。\n解决方法 解决方案相当简单：每次我们构建一个 .o 文件时，我们还创建一个扩展名为 .d（用于依赖关系）的文件，该文件记录了哪些文件用于创建相应的 .o 文件。 （请注意，与某些方法相比，我们不会提前创建 .d 文件。） .d 文件将用 make 语言本身编写，并包含在主 Makefile 中。我们可以使用 gcc 的 -MM 选项生成该文件：\nOBJS := foo.o bar.o # link proggie: $(OBJS) gcc $(OBJS) -o proggie # 获取所有 .o 文件的依赖关系 -include $(OBJS:.o=.d) # 编译并生成依赖信息 %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d # remove compilation products clean: rm -f proggie *.o *.d 鉴于上述情况，我们会在编译后得到两个 .d 文件。其中之一 bar.d 看起来像：\nbar.o: bar.c foo.h 当 make 读取这一行时，由于没有指定 shell 命令，它会将依赖项列表附加到 bar.o 已经拥有的任何依赖项，而不会影响用于构建它的命令。\n请注意，当且仅当对应的 .o 文件存在时，.d 文件才存在。这是有道理的，因为如果 .o 文件还不存在，我们不需要 .d 文件来告诉我们必须重建它。\n最巧妙的是，在我们拥有构建相应 .o 文件的必要成分之前，我们从不尝试构建 .d 文件。当项目有一些自动构建的源文件（例如 Bison 输出）时，这一点很重要，因为任何过早构建 .d 文件的尝试都会失败。\n-include $(OBJS:.o=.d) 语法可能需要一些解释。首先，$(OBJS:.o=.d) 取 $(OBJS) 的值，并将名称末尾的所有 .o 替换为 .d。接下来，字符（“-”）表示如果某些 .d 文件不存在，make 应该继续进行而不报错（同样，如果 .d 文件不存在，那么 .o 文件也不存在，所以 .o 文件将被正确重建）。\n关于头文件依赖，参考 这篇文章\n改进一下 上面的 Makefile 有一个问题。假设我将 foo.h 重命名为 foo2.h，并相应地更改 foo.c 和 bar.c。当我尝试重新编译时，make 会提示（例如）bar.o 依赖于不存在的 foo.h。我必须执行 make clean 或类似的事情才能让它再次正常工作。\n参阅 make 手册的第 4 章，“没有命令或先决条件的规则”。 GNU make 有一个晦涩难懂的功能：如果一个文件作为目标出现在没有先决条件和命令的规则中，并且该文件不存在且无法重新创建，那么 make 将重建所有依赖于该文件的目标并且不报告错误。\n要利用此功能，必须为每个 .d 文件添加无命令、无先决条件的规则。有很多方法可以实现，我选择使用 sed 和 fmt 的组合。我还选择在新命令前添加 @ 符号，因此在 make 运行时它们不会得到回显：\nOBJS := foo.o bar.o # link proggie: $(OBJS) gcc $(OBJS) -o proggie # pull in dependency info for *existing* .o files -include $(OBJS:.o=.d) # compile and generate dependency info; # more complicated dependency computation, so all prereqs listed # will also become command-less, prereq-less targets # sed: strip the target (everything before colon) # sed: remove any continuation backslashes # fmt -1: list words one per line # sed: strip leading spaces # sed: add trailing colons %.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d @cp -f $*.d $*.d.tmp @sed -e \u0026#39;s/.*://\u0026#39; -e \u0026#39;s/\\\\$$//\u0026#39; \u0026lt; $*.d.tmp | fmt -1 | \\ sed -e \u0026#39;s/^ *//\u0026#39; -e \u0026#39;s/$$/:/\u0026#39; \u0026gt;\u0026gt; $*.d @rm -f $*.d.tmp # remove compilation products clean: rm -f proggie *.o *.d 现在依赖文件看起来像这样：\nbar.o: bar.c foo.h bar.c: foo.h: 再来看之前的假设：假设我将 foo.h 重命名为 foo2.h。由于规则 foo.h: 没有依赖条件且 bar.o 依赖于 foo.h ，bar.o 将被重新编译并生成新的 .d 依赖关系。\n最后调整 如果源文件（和目标 .o 文件）位于与运行 make 的目录不同的目录中，则上述命令将无法正常工作。事实证明，gcc -MM 将创建一个目标名为 bar.o 的 .d 依赖文件，而正确的目标名应为 dir/bar.o。\n例如，上面的 makefile 可能会创建 .d 文件：\nbar.o: dir/bar.c dir/foo.h dir/bar.c: dir/foo.h: 这将起不到作用，因为 Makefile 中没有其他内容引用 bar.o。\n为了解决这个问题，在构建依赖项的块中还需要一个 sed 命令：\n%.o: %.c gcc -c $(CFLAGS) $*.c -o $*.o gcc -MM $(CFLAGS) $*.c \u0026gt; $*.d @mv -f $*.d $*.d.tmp @sed -e \u0026#39;s|.*:|$*.o:|\u0026#39; \u0026lt; $*.d.tmp \u0026gt; $*.d @sed -e \u0026#39;s/.*://\u0026#39; -e \u0026#39;s/\\\\$$//\u0026#39; \u0026lt; $*.d.tmp | fmt -1 | \\ sed -e \u0026#39;s/^ *//\u0026#39; -e \u0026#39;s/$$/:/\u0026#39; \u0026gt;\u0026gt; $*.d @rm -f $*.d.tmp 这将生成一个依赖文件，如下：\ndir/bar.o: dir/bar.c dir/foo.h dir/bar.c: dir/foo.h: ","permalink":"https://kingtuo123.com/posts/autodependencies-with-gnu-make/","summary":"make 自动生成依赖关系","title":"Autodependencies with GNU make"},{"content":"Note 之前学习 makefile 时发现不需要使用 gcc 的 -MMD 参数生成的依赖关系，程序也能编译通过。因为只要你的 makefile 中包含了头文件的路径，编译器在编译时会自动找到这个头文件。\n本以为可以省去生成依赖关系这一步，后来发现。\n如果你引用了隐式规则外的头文件，且头文件发生了改变，你再 make 是不会重新编译的（除非你 make clean），因为该头文件不在依赖中。\n很简单的问题，有时候还是脑子短路了。\n","permalink":"https://kingtuo123.com/posts/makefile-include-file/","summary":"Makefile 的规则中为何要包含头文件依赖","title":"Makefile 头文件依赖"},{"content":"创建卷 $ docker volume create my-vol 挂载数据卷 指定路径挂载\n$ docker run -it -v \u0026lt;宿主机路径\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 具名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;卷名\u0026gt;/_data，没有该卷则自动创建\n$ docker run -it -v \u0026lt;卷名\u0026gt;:\u0026lt;容器内路径\u0026gt; nginx 匿名挂载，主机路径 /var/lib/docker/volumes/\u0026lt;一串随机字符\u0026gt;/_data，自动创建卷，名称是随机字符\n$ docker run -it -v \u0026lt;容器内路径\u0026gt; nginx 查看数据卷 列出数据卷\n$ docker volume ls DRIVER VOLUME NAME local 0b60738f27c8adc38559981ad727d36a722b70b1736b20d8f3020ffc88d202b2 local 21f61aa404a0fe9c15a6a6ad4a6a056a0ee009a98af593c2092a14062fa7c02e local test # 上面两个是匿名挂载 # test是具名挂载 查看卷详情\n$ docker volume inspect \u0026lt;卷名\u0026gt; [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-01-24T17:08:58+08:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/test/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 读写权限 ro 只读，容器对该数据卷只读\n$ docker run -d -v /home/nginx:/etc/nginx:ro nginx rw 读写，容器对该数据卷可读写\n$ docker run -d -v /home/nginx:/etc/nginx:rw nginx 数据卷共享 $ docker run -it --name docker01 -v volume01 ubuntu bash $ docker run -it --name docker02 --volume-from docker01 ubuntu bash 上面的命令中 docker02 与 docker01 共享 volume01 ，用到参数 --volume-from 。\n我们来查看下两个容器数据卷的关系\n$ docker inspect docker01 docker02 | grep volume \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/505a478d050df91857b156119a9d83626614ffb3962d1ac3459d14756c5544dc/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume01\u0026#34;, \u0026#34;volume01\u0026#34;: {} \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/505a478d050df91857b156119a9d83626614ffb3962d1ac3459d14756c5544dc/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume01\u0026#34;, \u0026#34;volume01\u0026#34;: {} 可以看到两个容器匿名挂载的宿主机路径是一样的\n","permalink":"https://kingtuo123.com/posts/docker-volume/","summary":"docker volume 数据卷常用命令及操作","title":"Docker volume"},{"content":" 参考文章： Gentoo AMD64 Handbook Gentoo安装流程分享 内核总体设置和性能调优 连接无线网 # wpa_passphrase \u0026lt;wifi\u0026gt; \u0026lt;passwd\u0026gt; \u0026gt; /etc/wpa_supplicant/wpa_supplicant.conf # wpa_supplicant -i \u0026lt;dev\u0026gt; -c /etc/wpa_supplicant/wpa_supplicant.conf -B # dhcpd 可选：使用 SSH 连接 # rc-service sshd start # passwd root 这里注意记得修改 root 密码，因为不知道 livecd 的 root 密码。\n准备磁盘 分区 # parted /dev/nvme0n1 # 创建 gpt 分区 (parted) mklabel gpt # 创建引导分区，注意这里从2048个扇区开始，对齐分区 (parted) mkpart EFI fat32 2048s 512MB # 创建根分区 (parted) mkpart root ext4 512MB 100% # 设置分区1 flag boot, esp (parted) set 1 # 打印分区信息 (parted) p Model: PM981 NVMe Samsung 512GB (nvme) Disk /dev/nvme0n1: 512GB Sector size (logical/physical): 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 512MB 511MB fat32 EFI boot, esp 2 512MB 512GB 512GB ext4 root 格式化分区 # mkfs.fat -F 32 /dev/nvme0n1p1 # mkfs.ext4 /dev/nvme0n1p2 挂载 root 分区 # mount /dev/nvme0n1p2 /mnt/gentoo 安装 stage3 设置日期和时间 格式：月日时分年，如 060504032022 ，表示 2022 年 06 月 05 日 04 时 03 分。\n# date 060504032022 下载 stage3 这里使用 links 访问清华开源镜像站下载：\n# cd /mnt/gentoo/ # links https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64-desktop-openrc/ 解压 stage3 # tar xpvf stage3-*.tar.xz --xattrs-include=\u0026#39;*.*\u0026#39; --numeric-owner 配置 make.conf # vi /mnt/gentoo/etc/portage/make.conf 修改如下：\n# These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\u0026#34;-march=native -O3 -pipe\u0026#34; CFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; CXXFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; FCFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; FFLAGS=\u0026#34;${COMMON_FLAGS}\u0026#34; # NOTE: This stage was built with the bindist Use flag enabled PORTDIR=\u0026#34;/var/db/repos/gentoo\u0026#34; DISTDIR=\u0026#34;/var/cache/distfiles\u0026#34; PKGDIR=\u0026#34;/var/cache/binpkgs\u0026#34; # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C # 核心数*2 MAKEOPTS=\u0026#34;-j8\u0026#34; # 清华源 GENTOO_MIRRORS=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/gentoo\u0026#34; # 阿里源 #GENTOO_MIRRORS=\u0026#34;https://mirrors.aliyun.com/gentoo/\u0026#34; USE=\u0026#34;-kde -systemd -gnome -wayland -bluetooth efi-64 pulseaudio dbus caps\u0026#34; VIDEO_CARDS=\u0026#34;i965 intel\u0026#34; INPUT_DEVICES=\u0026#34;libinput synaptics\u0026#34; GRUB_PLATFORMS=\u0026#34;efi-64\u0026#34; ACCEPT_LICENSE=\u0026#34;*\u0026#34; 安装基本系统 拷贝 DNS 信息 # cp --dereference /etc/resolv.conf /mnt/gentoo/etc/ 挂载文件系统 # mount --types proc /proc /mnt/gentoo/proc # mount --rbind /sys /mnt/gentoo/sys # mount --make-rslave /mnt/gentoo/sys # mount --rbind /dev /mnt/gentoo/dev # mount --make-rslave /mnt/gentoo/dev # mount --bind /run /mnt/gentoo/run # mount --make-slave /mnt/gentoo/run 进入新环境 # chroot /mnt/gentoo /bin/bash # source /etc/profile # export PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 挂载 EFI 分区 # mkdir -p /boot/EFI # mount /dev/nvme0n1p1 /boot/EFI/ 配置 Portage 更新 ebuild 仓库 # emerge-webrsync 选择配置文件 # eselect profile list 输出如下：\nAvailable profile symlink targets: [1] default/linux/amd64/17.1 (stable) [2] default/linux/amd64/17.1/selinux (stable) [3] default/linux/amd64/17.1/hardened (stable) [4] default/linux/amd64/17.1/hardened/selinux (stable) [5] default/linux/amd64/17.1/desktop (stable) * [6] default/linux/amd64/17.1/desktop/gnome (stable) [7] default/linux/amd64/17.1/desktop/gnome/systemd (stable) ... # eselect profile set 5 更新 world # emerge --ask --verbose --update --deep --newuse @world 预安装一些软件 # emerge -av vim \\ wpa_supplicant \\ net-misc/dhcp \\ app-text/tree \\ mlocate \\ linux-firmware \\ gentoolkit \\ net-wireless/iw \\ pciutils 时区设置 # echo \u0026#34;Asia/Shanghai\u0026#34; \u0026gt; /etc/timezone # emerge --config sys-libs/timezone-data 配置语言环境 编辑 /etc/locale.gen 添加如下：\nen_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_CN.GBK GBK 然后执行\n# locale-gen 语言选择：\n# eselect locale list Available targets for the LANG variable: [1] C [2] C.utf8 [3] POSIX [4] en_US.utf8 [5] zh_CN.gbk [6] zh_CN.utf8 [7] C.UTF8 * [ ] (free form) 设置 en_US.utf8 ：\n# eselect locale set 4 # env-update \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026amp; export PS1=\u0026#34;(chroot) ${PS1}\u0026#34; 配置内核 下载固件和CPU微代码 # emerge --ask sys-kernel/linux-firmware sys-firmware/intel-microcode 下载内核源码 # emerge --ask sys-kernel/gentoo-sources 选择内核版本 # eselect kernel list Available kernel symlink targets: [1] linux-5.15.41-gentoo # eselect kernel set 1 配置内核 # cd /usr/src/linux # make menuconfig 内核参数配置因人、机器而异，这里不详述。\n编译安装 # make -j8 # make install # make modules_install 可选：构建 initramfs # emerge --ask sys-kernel/dracut # dracut --kver=5.15.41-gentoo 系统配置 配置 /etc/fstab /dev/nvme0n1p1\t/boot\tvfat\tdefaults,noatime\t0 2 /dev/nvme0n1p2\t/\text4\tnoatime\t0 1 主机和域信息 # vim /etc/conf.d/hostname hostname=\u0026#34;gentoo\u0026#34; # vim /etc/conf.d/net dns_domain_lo=\u0026#34;localhost\u0026#34; # vim /etc/host 127.0.0.1 gentoo.localhost gentoo localhost # vim /etc/rc.conf rc_parallel=\u0026#34;YES\u0026#34; # vim /etc/conf.d/hwclock clock=\u0026#34;local\u0026#34; 安装系统工具 日志系统 # emerge --ask app-admin/sysklogd # rc-update add sysklogd default 时钟同步 # emerge --ask net-misc/chrony # rc-update add chronyd default 配置引导加载程序 # emerge --ask sys-boot/grub # grub-install --target=x86_64-efi --efi-directory=/boot/EFI --removable grub 内核启动参数 编辑 /etc/default/grub ，添加下面一行\nGRUB_CMDLINE_LINUX=\u0026#34;root=/dev/nvme0n1p2\u0026#34; 生成 grub 配置文件：\n# grub-mkconfig -o /boot/grub/grub.cfg 收尾工作 添加用户 # useradd -m -G users,wheel,audio,usb -s /bin/bash king 修改用户和 root 密码\n# passwd king # passwd root 默认密码强度需要数字大小写字母，你可以修改 /etc/security/passwdqc.conf 配置。\nwpa_supplicant 配置 编辑 /etc/wpa_supplicant/wpa_supplicant.conf\nupdate_config=1 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel 添加开机启动，编辑 /etc/local.d/boot.start\nwpa_supplicant -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -B \u0026amp;\u0026amp; dhclient wlp2s0 \u0026amp; 执行：\n# chmod +x /etc/local.d/boot.start # rc-update add local default # rc-update del netmount default 也可以用 rc-update add wpa_supplicant default 添加开机启动，但是启动时连接 wifi 会阻塞十来秒。暂时只想到上面的方法。\nnetwork 启动时提示 service 'netmount' needs non existent 'net' ，解决办法：\n# ln -s /etc/init.d/net.lo /etc/init.d/net.wlp2s0 hidpi tty\u0026amp;grub font 安装字体：\n# emerge -av terminus-font 编辑 /etc/conf.d/consolefont，添加如下：\nconsolefont=\u0026#34;ter-d32n\u0026#34; 添加开机启动：\n# rc-update add consolefont default 生成 grub 字体：\n# grub-mkfont -s 32 -o /boot/grub/fonts/terminus32b.pf2 /usr/share/fonts/terminus/ter-u32b.otb 编辑 /etc/default/grub，如下：\nGRUB_FONT=\u0026#34;/boot/grub/fonts/terminus32b.pf2\u0026#34; 然后\n# grub-mkconfig -o /boot/grub/grub.cfg 其他常用程序 app-admin/sudo app-portage/pfl xorg #emerge --ask x11-base/xorg-server #emerge --ask x11-base/xorg-x11 至此基本系统就已安装完毕，剩下的就是桌面环境安装配置。\n未完待续\u0026hellip;\n","permalink":"https://kingtuo123.com/posts/gentoo-installation/","summary":"Note","title":"Gentoo 安装配置"},{"content":"安装 $ emerge -av xf86-input-mtrack 添加用户到 input 组\n$ gpasswd -a \u0026lt;user\u0026gt; input 配置 添加文件 /etc/X11/xorg.conf.d/40-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;libinput touchpad catchall\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;True\u0026#34; Option \u0026#34;TappingDrag\u0026#34; \u0026#34;True\u0026#34; Option \u0026#34;NaturalScrolling\u0026#34; \u0026#34;False\u0026#34; Option \u0026#34;ScrollUpButton\u0026#34; \u0026#34;5\u0026#34; Option \u0026#34;ScrollDownButton\u0026#34; \u0026#34;4\u0026#34; Driver \u0026#34;mtrack\u0026#34; Option \u0026#34;TransformationMatrix\u0026#34; \u0026#34;0.4 0 0 0 0.4 0 0 0 1\u0026#34; EndSection 各项参数参考这里\n启用/禁用触摸板 获取设备 id\n# 这里id是14 $ xinput list | grep -i touchpad ⎜ ↳ SynPS/2 Synaptics TouchPad id=14 [slave pointer (2)] 查看设备属性\n$ xinput list-props 14 Device \u0026#39;SynPS/2 Synaptics TouchPad\u0026#39;: # 这里可以用 Device Enabled (186) 来启用或禁用触摸板 Device Enabled (186): 0 Device Accel Profile (318): 0 Device Accel Constant Deceleration (319): 1.000000 Device Accel Adaptive Deceleration (320): 1.000000 Device Accel Velocity Scaling (321): 10.000000 Trackpad Disable Input (356): 0 Trackpad Sensitivity (357): 1.000000 Trackpad Touch Pressure (358): 5, 5 Trackpad Button Settings (359): 1, 1 Trackpad Button Emulation Settings (360): 0, 1, 100 ...... 启用触摸板\n$ input set-prop 14 \u0026#34;Device Enabled\u0026#34; 1 # 或者使用属性id $ xinput set-prop 14 186 1 禁用触摸板\n$ input set-prop 14 \u0026#34;Device Enabled\u0026#34; 0 $ xinput set-prop 14 186 0 其他参数参照上面方法修改\n","permalink":"https://kingtuo123.com/posts/linux-touchpad-driver/","summary":"Gentoo touchpad driver installation and configure","title":"Gentoo touchpad 驱动"},{"content":" 参考文档1 参考文档2 问题描述:\n使用xf86-video-intel驱动和启用硬件加速会导致画面概率性冻结 使用modesetting驱动会导致画面撕裂 解决方法 不使用 xf86-video-intel 驱动。\n使用 picom 渲染器解决 modesetting 驱动下画面撕裂的问题\n修改 /etc/X11/xorg.conf.d/20-intel.conf\nSection \u0026#34;Device\u0026#34; Identifier \u0026#34;Intel Graphics\u0026#34; Driver \u0026#34;modesetting\u0026#34; Option \u0026#34;AccelMethod\u0026#34; \u0026#34;glamor\u0026#34; Option \u0026#34;DRI\u0026#34; \u0026#34;3\u0026#34; EndSection 在 picom 配置文件 ~/.config/picom/picom.conf 中添加\nvsync = true; 在 ~/.xinitrc 中添加\npicom --experimental-backend \u0026amp; # 新的版本没有了上面的参数 picom \u0026amp; ","permalink":"https://kingtuo123.com/posts/linux-intel-graphics-tearing-issue/","summary":"intel驱动导致的画面撕裂和冻结","title":"Linux下intel核显驱动问题"},{"content":"stm32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 厂家的 BootLoader 已提供了串口下载的功能，所以我们只要进入 BootLoader 即可。\n即在单片机启动时将BOOT0置高电平，BOOT1置低电平。\n一键下载电路 本文以野火霸道V2.0开发板为例\n要进入bootloader，有以下流程:\nBOOT1 跳线接 GND DTR 置高电平，RTS 置低电平 Q3 被导通，NRST 被拉低，单片机复位 Q5 被导通，BOOT0 被拉高 DTR 置低电平，释放复位 启动进入 BootLoader 这里注意CH340G 芯片，DTR 和 RTS 输出电平是反向的（芯片图DTR上方有一横线）。所以实际是， DTR 低电平复位，RTS 高电平进入BootLoader。\nWindows ISP 下载 如上图所示：DTR 低电平复位，RTS 高电平进入BootLoader。\nLinux ISP 下载 Linux 下使用 stm32flash 下载。下载解压后文件夹内有 stm32flash_linux 。\n该命令有以下参数\nUsage: stm32flash_linux [-bvngfhc] [-[rw] filename] [tty_device|i2c_device] -a bus_address # 总线地址 -b rate # 波特率 -m mode # 串口模式 -r filename # 读取flash到文件（或者使用 - 符号， 表示标准输出） -w filename # 写入文件到flash（或者使用 - 符号， 表示标准输出） -C # 计算flash crc校验码 -u # 禁用flash写保护 -j # 启用flash读保护 -k # 禁用flash读保护 -o # 仅擦除 -e n # 写入flash前仅擦除n页，默认全擦 -v # 写入后校验 -n count # 写入失败重试次数，默认10 -g address # 指定程序开始执行的地址 -S address[:length] # 指定读取/写入的起始地址和长度（可选） -F RX_length[:TX_length] # 指定接收/发送帧的最大长度 -s start_page # 在指定的页面写入 -f # 强制二进制解析 -h # 显示帮助信息 -c # 恢复连接 -R # 退出时复位设备 -i GPIO_string # 设置进入/退出BootLoader时信号输出的顺序 # GPIO_string=[entry_seq][:[exit_seq]] # sequence=[[-]signal]\u0026amp;|,[sequence] GPIO sequence: # 使用‘dtr’，‘rts’，‘brk’表示串口输出信号 # ‘,’表示在在两个信号之间加100ms延时 # ‘\u0026amp;’表示两个信号之间不加延时 # 在信号前加‘-’表示低电平，不加表示高电平 读取芯片信息，执行以下命令（root）：\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; /dev/ttyUSB0 参数说明：\n-b 115200 ，指定115200波特率 -dtr\u0026amp;rts,dtr -dtr\u0026amp; 拉低复位 rts, 拉高 BOOT0，延时100ms dtr 释放复位，进入 BootLoader -dtr\u0026amp;-rts,dtr -dtr\u0026amp; 拉低复位 -rts, 拉低 BOOT0，延时100ms dtr 释放复位，flash启动进入用户程序 /dev/ttyUSB0，设备串口 上述命令执行成功输出以下信息：\nInterface serial_posix: 115200 8E1 GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 1... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end Version : 0x22 Option 1 : 0x00 Option 2 : 0x00 Devive ID : 0x0414 (STM32F10XX High-density) - RAM : Up to 64KiB (512b reserved by bootloader) - Flash : Up to 512Kib (size first sector: 2x2048) - Option RAM : 16b - System RAm : 2KiB GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 0... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end 下载程序，执行以下命令\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; -v -w test.bin /dev/ttyUSB0 ","permalink":"https://kingtuo123.com/posts/stm32-isp-flash/","summary":"ISP 一键下载原理，windows 和 linux 平台 ISP 下载方法","title":"STM32 ISP 一键下载"},{"content":" 翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\nMakefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command targets 是文件名，以空格分隔。通常一个规则只有一个目标。\ncommand 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\nprerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\nmake 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的C程序。 blah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c # 第一个运行 下面这个 makefile 有一个目标 some_file 。默认目标是第一个目标，所以将执行 some_file 下的 echo 命令。\nsome_file: echo \u0026#34;This line will always print\u0026#34; 下面这个 makefile 第一次运行会生成 some_file 。第二次运行由于 some_file 已存在，会提示 make: 'some_file' is up to date 。\nsome_file: echo \u0026#34;This line will only print once\u0026#34; touch some_file 下面这个 makefile 中 some_file 依赖 other_file 。当第一次执行 make ，默认目标是 some_file ，它首先会查找依赖文件 other_file ，只要依赖文件比目标文件 some_file 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。\nsome_file: other_file echo \u0026#34;This will run second, because it depends on other_file\u0026#34; touch some_file other_file: echo \u0026#34;This will run first\u0026#34; touch other_file 下面这个 makefile 始终会执行默认目标的命令，因为它的依赖始终无法满足。\nsome_file: other_file touch some_file other_file: echo \u0026#34;nothing\u0026#34; clean 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file 变量 变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。\n使用 $( ) 调用或 ${ }。\nobj = a.o b.o c.o test: $(obj) gcc -o test $(obj) 变量赋值一般有如下符号：\n符号 作用 = 变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。 := 变量赋值，与普通的编程语言中的赋值一样。 += 变量追加赋值 ?= 变量为空则给它赋值 = 与 := 的区别：\n# 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: echo $(one) echo $(two) := 允许你追加变量，但会导致死循环，如下。\none = hello # one gets defined as a simply expanded variable (:=) and thus can handle appending one := ${one} there all: echo $(one) ?= 仅设置尚未设置的变量\none = hello one ?= will not be set two ?= will be set all: echo $(one) # 打印 hello echo $(two) # 打印 will be set 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\n以下 makefile 使用 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 通配符 通配符 作用 * 匹配零或多个字符 % 匹配一个或多个字符 ? 匹配单个字符 * 和 % 在 makefile 中都是通配符，但它们的含义完全不同。\n* 会搜索你的文件系统来匹配文件名。个人建议调用 wildcard 函数来使用 * 。\n# 打印出当前路径下所有以.c结尾的文件的信息 print: $(wildcard *.c) ls -la $? 危险：不要在变量定义中使用 * 。\n危险：当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\nthing_wrong := *.o # 不要这样做，\u0026#39;*\u0026#39; 不会被展开，会被视作 \u0026#34;*.o\u0026#34; 字符串 thing_right := $(wildcard *.o) # 正确做法 all: one two three four # 这里会出错，因为 $(thing_wrong) 是字符串 \u0026#34;*.o\u0026#34; one: $(thing_wrong) # 如果没有文件以 \u0026#34;.o\u0026#34; 结尾，匹配不到文件时也会被视作字符串 \u0026#34;*.o\u0026#34; two: *.o # 正确运行 three: $(thing_right) # 同规则 \u0026#34;three\u0026#34; four: $(wildcard *.o) 自动化变量 符号 描述 $@ 当前目标名 $^ 所有依赖名，去重 $\u0026lt; 第一个依赖名 $+ 所有依赖名，不去重 $? 比目标新的依赖名 $* 目标中%匹配的部分 hey: one two # 输出 \u0026#34;hey\u0026#34; echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two 规则 隐式规则 隐式规则会让东西变得混乱，不推荐使用，但是要了解。\n编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的 隐式规则常用的几个变量：\nCC ：C 程序编译器，默认 cc 。 CXX ：C++ 程序编译器，默认 g++ 。 CFLAGS ：提供给 C 编译器的参数。 CXXFLAGS ：提供给 C++ 编译器的参数。 CPPFLAGS ：提供给 C 预处理器的参数。 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数。 下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c clean: rm -f blah* 静态模式规则 下面是语法：\ntargets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 函数搭配使用，如下\nobj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u0026lt; -o $@ 模式规则在目标中包含一个 % 。这个 % 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 % 代表与目标中的 % 匹配的相同词干。\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # $@ 表示目标文件 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。\nall: blah blah:: echo \u0026#34;hello\u0026#34; blah:: echo \u0026#34;hello again\u0026#34; 命令 不打印命令 在命令前加 @ ，在运行时这条命令不会被打印出来。在 make 时加上 -s 参数有同样的效果。\nall: @echo \u0026#34;This make line will not be printed\u0026#34; echo \u0026#34;But this will\u0026#34; 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\ echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \u0026#34;Hello from bash\u0026#34; 错误处理 在运行 make 时添加 -k 参数（\u0026ndash;keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （\u0026ndash;ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n嵌套执行 make 要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。\n# 双引号中的内容等同于 # hello: # touch inside_file new_contents = \u0026#34;hello:\\n\\ttouch inside_file\u0026#34; all: mkdir -p subdir printf $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile #去掉第一行的空格并写入subdir/makefile cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 使用 export 嵌套 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：\nnew_contents = \u0026#34;hello:\\n\\\\techo \\$$(cooly)\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) # 注意输出的信息，可以看到 export 全局声明起到了作用 cooly = \u0026#34;The subdirectory can see me!\u0026#34; export cooly # 取消全局: unexport cooly clean: rm -rf subdir 你也可以在 shell 中使用全局变量\none=this will only work locally export two=we can run subcommands with this all: @echo $(one) # $$ 的意思是使用真实的 $ 符号 # 即 echo $one，由于one未声明全局环境变量，所以这条打印为空 @echo $$one @echo $(two) @echo $$two 也可以使用 .EXPORT_ALL_VARIABLES 将所用的变量都声明为全局的。\n.EXPORT_ALL_VARIABLES: new_contents = \u0026#34;hello:\\n\\techo \\$$(cooly)\u0026#34; cooly = \u0026#34;The subdirectory can see me!\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量。在这里，我们使用 make option_one=hi 运行 make\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: echo $(option_one) echo $(option_two) define函数定义 one = export blah=\u0026#34;I was set!\u0026#34;; echo $$blah define two export blah=set echo $$blah endef # One 和 two 是不一样的 all: @echo \u0026#34;这条会打印 \u0026#39;I was set\u0026#39;\u0026#34; @$(one) @echo \u0026#34;这条不会打印 \u0026#39;I was set\u0026#39; 因为每条命令运行在不同的shell中\u0026#34; @$(two) 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 if/else foo = ok all: ifeq ($(foo), ok) echo \u0026#34;foo equals ok\u0026#34; else echo \u0026#34;nope\u0026#34; endif 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格 all: ifeq ($(strip $(foo)),) echo \u0026#34;foo is empty after being stripped\u0026#34; endif ifeq ($(nullstring),) echo \u0026#34;nullstring doesn\u0026#39;t even have spaces\u0026#34; endif 检查变量是否定义 bar = foo = $(bar) all: ifdef foo echo \u0026#34;foo is defined\u0026#34; endif ifdef bar echo \u0026#34;but bar is not\u0026#34; endif 命令行参数 $(MAKEFLAGS) bar = foo = $(bar) all: # 查找 \u0026#34;-i\u0026#34; 参数。 ifneq (,$(findstring i, $(MAKEFLAGS))) echo \u0026#34;i was passed to MAKEFLAGS\u0026#34; endif 函数 函数主要只是用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\n# 字符串替换，这里 totally 替换 not bar := ${subst not, totally, \u0026#34;I am not superman\u0026#34;} all: @echo $(bar) 如果要替换空格或逗号，请使用变量\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \u0026#34;a,b,c\u0026#34; @echo $(bar) 不要在第一个参数之后包含空格。这将被视为字符串的一部分。\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 后面有一个空格 all: # 输出是 \u0026#34;, a , b , c\u0026#34;，注意空格 @echo $(bar) 字符串替换 $(patsubst pattern,replacement,text) 执行以下操作：\n使用 pattern 匹配 text 中的文件名，使用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 $(foreach var,list,text) ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\n这会在每个单词后附加一个感叹号：\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \u0026#34;who! are! you!\u0026#34; @echo $(bar) if 函数 if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 Make 支持创建基本函数。语法是 $(call variable,param,param)\n$(0) 是变量名，$(1) 、$(2) 等是参数。\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \u0026#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\u0026#34; @echo $(call sweet_new_fn, go, tigers) shell 函数 这会调用 shell，但它用空格替换了换行符。\nall: # 非常难看，因为换行符不见了 @echo $(shell ls -la) 其他特性 应用外部makefile include 的语法是\ninclude filenames vpath 指令 语法 vpath \u0026lt;pattern\u0026gt; \u0026lt;directories\u0026gt; ，\u0026lt;pattern\u0026gt; 会匹配 \u0026lt;directories\u0026gt; 中的文件名，多个目录使用 空格 或 冒号 分隔。\nvpath %.h ../headers ../other-directory some_binary: ../headers blah.h touch some_binary ../headers: mkdir ../headers blah.h: touch ../headers/blah.h clean: rm -rf ../headers rm -f some_binary .phony make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 标签 ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 make clean 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n.PHONY clean clean: rm -f *.o .delete_on_error 当规则执行失败，.delete_on_error 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise. SRCS := $(shell find $(SRC_DIRS) -name \u0026#39;*.cpp\u0026#39; -or -name \u0026#39;*.c\u0026#39; -or -name \u0026#39;*.s\u0026#39;) # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u0026lt; -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u0026lt; -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # Include the .d makefiles. The - at the front suppresses the errors of missing # Makefiles. Initially, all the .d files will be missing, and we don\u0026#39;t want those # errors to show up. -include $(DEPS) ","permalink":"https://kingtuo123.com/posts/makefile-basic/","summary":"Makefile 的基本语法，规则及命令。","title":"Makefile基础"},{"content":"docker镜像 拉取镜像 docker image pull \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 查看镜像 docker image ls -a docker images 删除镜像 docker image rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; docker image rm \u0026lt;image id\u0026gt; id不用补全，比如 ba6acccedd29 ，只需输入 ba ，只要id前几位没和其他镜像重复。\n当镜像已有创建的容器时，无法删除。可以使用-f参数强制删除。\n提交镜像 首先你在基础镜像生成的容器中做了修改后，使用 commit 命令可以生成一个新的镜像，这个镜像相较于基础镜像多了一层Layer（你在容器内做的所有修改都打包成了Layer）\ndocker commit -m \u0026#34;some info\u0026#34; 生成的镜像可以用 image 命令查看到，commit 之后你可以使用 push 命令推送到远端仓库\ndocker容器 创建容器 以下命令会自动创建一个容器并运行bash，也可以用 create 命令创建容器。\ndocker container run --name \u0026lt;name\u0026gt; -it --rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; bash run 常用参数：\n--name：指定容器名称 -i：开启标准输入 -t：分配伪终端 --rm：退出容器后自动删除容器，多用于一次性测试 -v：挂载路径，格式 -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; -p：指定端口映射，格式 -p \u0026lt;host port\u0026gt;:\u0026lt;container port\u0026gt; -P：随机端口映射，docker会随机映射一个端口到内部容器的网络端口 -d：后台运行容器，并返回容器ID，类似命令后加\u0026amp; -e：设置环境变量，格式 -e \u0026lt;variables1\u0026gt;=\u0026lt;variables2\u0026gt; --privileged：扩大容器权限，在容器内可以看到host的更多设备、可mount挂载设备 --network：连接指定网络，系统预定义的有bridge(默认)、host、container、none四种 网络 说明 bridge 虚拟网卡、网桥，独立IP与端口 host 使用宿主机网卡、IP与端口 container 与指定容器共享IP与端口 none 关闭网络功能 启动容器 docker container start \u0026lt;name|container id\u0026gt; start 后面可跟多个 id\n进入容器 docker container attach \u0026lt;name|container id\u0026gt; docker container exec -it \u0026lt;name|container id\u0026gt; bash attach 在退出容器后会停止容器，exec 不会\nattach 相当于进入当前终端，exec 相当于新开了一个终端\n停止容器 docker container stop \u0026lt;name|container id\u0026gt; docker container kill \u0026lt;name|container id\u0026gt; stop 先发送SIGTERM信号，容器内程序可以做退出前的准备工作，一段时间之后再发送SIGKILL信号。\nkill 发送SIGKILL信号，应用程序直接退出。\n查看容器 列出所有容器\ndocker container ls -a 删除容器 docker container rm \u0026lt;name|container id\u0026gt; 使用 prune 可以删除所有已停止的容器\ndocker container prune 文件拷贝 拷贝无需容器运行，只要该容器存在即可，以下命令从容器拷贝至主机\ndocker container cp \u0026lt;container id|name\u0026gt;:\u0026lt;container path\u0026gt; \u0026lt;host path\u0026gt; ","permalink":"https://kingtuo123.com/posts/docker-base-cmd/","summary":"Docker 镜像/容器常用的一些命令及说明","title":"Docker基本命令"},{"content":"安装配置Mysql emerge -av dev-db/mysql 首次安装需配置root密码\nemerge --config dev-db/mysql 修改配置文件,编辑/etc/mysql/my.cnf\n[client] socket=/var/run/mysqld/mysqld.sock [mysqld] #禁用远程访问，只使用本地socket连接 skip-networking #默认套接字路径 socket=/var/run/mysqld/mysqld.sock #数据库默认存放路径 datadir=/var/lib/mysql/ 启动mysql\nrc-service mysql start 登陆mysql\nmysql -u root -p 查看端口\nmysql\u0026gt; show variables like \u0026#39;port\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | port | 0 | +---------------+-------+ 1 row in set (0.01 sec) port为0,远程连接关闭\n查看其他设置\nmysql\u0026gt; show variables like \u0026#39;socket\u0026#39;; +---------------+-----------------------------+ | Variable_name | Value | +---------------+-----------------------------+ | socket | /var/run/mysqld/mysqld.sock | +---------------+-----------------------------+ 1 row in set (0.01 sec) mysql\u0026gt; show variables like \u0026#39;datadir\u0026#39;; +---------------+-----------------+ | Variable_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.00 sec) 安装配置php 修改USE，编辑文件/etc/portage/package.use/package.use，添加如下\ndev-lang/php fpm mysql mysqli gd 按需添加，查看各项USE标记含义，执行equery u dev-lang/php\nfpm : Enable the FastCGI Process Manager SAPI mysql : Add mySQL Database support mysqli : Add support for the improved mySQL libraries gd : Adds support for gd (bundled with PHP) 安装dev-lang/php，默认会安装最新的php7\nemerge -av dev-lang/php 查看版本，执行eselect php list cli或者执行php -v\n[1] php7.3 * php默认配置文件路径/etc/php/\n修改/etc/php/fpm-php7.3/fpm.d/www.conf文件\nuser = nginx group = nginx ;默认是开9000端口用TCP连接，没有必要，注释掉改为本地socket连接 ;listen = 127.0.0.1:9000 listen = /var/run/php-fpm/php-fpm.sock listen.owner = nginx listen.group = nginx listen.mode = 0660 修改/etc/php/fpm-php7.3/php.ini,修改下面内容\n;去掉下面这行注释并在末尾添加.html，支持解析html security.limit_extensions = .php .php4 .php5 .php7 .html cgi.fix_pathinfo=0 百度了下cgi.fix_pathinfo，如果PHP的配置里 cgi.fix_pathinfo=1，会导致安全问题，这个问题只存在于 Nginx 服务器中，Apache和IIS都不会有这个问题\n安装配置nginx 执行equery u nginx检查USE标记nginx_modules_http_fastcgi是否默认添加\nemerge -av www-servers/nginx 默认配置文件路径/etc/nginx/,修改nginx.conf\nserver { listen 80 default_server; listen [::]:80 default_server; server_name localhost; include /etc/nginx/default.d/*.conf; root /home/test/www; #网站主目录 location / { root /home/test/www; index index.php index.html index.htm; } location ~ .*\\.(php|html)$ { #添加php，html解析 try_files $uri =404; fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/test/www$fastcgi_script_name; include fastcgi_params; } } 添加nginx到test用户组\nusermod -a -G test nginx 查看用户组\nroot# groups nginx test nginx 最后，确保网站主目录的group有r和x权限。\n测试 启动nginx，执行rc-service nginx start，同样再启动php-fpm和mysql。\n可以添加开机运行，执行rc-update add \u0026lt;服务名称\u0026gt; default\n在网站主目录下新建index.html,写入以下内容\n\u0026lt;?php $con=mysqli_connect(null,\u0026#34;root\u0026#34;,\u0026#34;密码\u0026#34;,null,null,\u0026#34;/var/run/mysqld/mysqld.sock\u0026#34;); if ($con){ echo \u0026#34;连接成功\u0026#34;; } ?\u0026gt; 打开浏览器输入127.0.0.1，看到连接成功，配置成功。\n","permalink":"https://kingtuo123.com/posts/gentoo-lnmp-deploy/","summary":"安装配置Mysql emerge -av dev-db/mysql 首次安装需配置root密码\nemerge --config dev-db/mysql 修改配置文件,编辑/etc/mysql/my.cnf\n[client] socket=/var/run/mysqld/mysqld.sock [mysqld] #禁用远程访问，只使用本地socket连接 skip-networking #默认套接字路径 socket=/var/run/mysqld/mysqld.sock #数据库默认存放路径 datadir=/var/lib/mysql/ 启动mysql\nrc-service mysql start 登陆mysql\nmysql -u root -p 查看端口\nmysql\u0026gt; show variables like \u0026#39;port\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | port | 0 | +---------------+-------+ 1 row in set (0.01 sec) port为0,远程连接关闭\n查看其他设置\nmysql\u0026gt; show variables like \u0026#39;socket\u0026#39;; +---------------+-----------------------------+ | Variable_name | Value | +---------------+-----------------------------+ | socket | /var/run/mysqld/mysqld.sock | +---------------+-----------------------------+ 1 row in set (0.","title":"Gentoo 搭建 lnmp 环境"},{"content":" 参考文章：Gentoo Wiki/Arduino 启用内核选项 Device Drivers ---\u0026gt; [*] USB support ---\u0026gt; \u0026lt;*\u0026gt; USB Serial Converter support ---\u0026gt; \u0026lt;*\u0026gt; USB Winchiphead CH341 Single Port Serial Driver 串口设备一般是 /dev/ttyUSB0\n非 ROOT 用户访问权限 添加用户到 dialout 组：\n# gpasswd -a \u0026lt;username\u0026gt; dialout ","permalink":"https://kingtuo123.com/posts/gentoo-ch340-driver/","summary":"内核驱动及权限配置","title":"Gentoo CH340 串口驱动"},{"content":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接图片：\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;1.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.jpg\u0026#34; style=\u0026#34;max-height:980px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n列表内容 列表内容 列表内容 有序列表 数字加点\n1. 列表内容 2. 列表内容 3. 列表内容 列表嵌套 二级列表前加三个空格\n- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 表格 表头|表头2222222|表头33333333 ---|:--:|--: 内容|内容|内容 内容|内容|内容 :--: 表示居中\n--: 靠右\n:-- 靠左\n显示如下\n表头 表头2222222 表头33333333 内容 内容 内容 内容 内容 内容 代码 ​```java 代码... 代码... 代码... ​``` ","permalink":"https://kingtuo123.com/posts/markdown-syntax/","summary":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接图片：\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;1.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.jpg\u0026#34; style=\u0026#34;max-height:980px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下","title":"Markdown语法"},{"content":" 参考 CurlFtpFS 内核选项 File systems ---\u0026gt; \u0026lt;*\u0026gt; FUSE (Filesystem in Userspace) support 安装 emerge -av net-fs/curlftpfs 以普通用户挂载 首先，创建挂载点\nmkdir ./ftp 挂载\ncurlftpfs ftp://server/catalog/ ./ftp/ -o user=username:password,utf8,ssl ssl ：使用 SSL/TLS 传输数据\nutf8 ： 使用 utf8 编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","permalink":"https://kingtuo123.com/posts/curlftpfs-mount-local/","summary":" 参考 CurlFtpFS 内核选项 File systems ---\u0026gt; \u0026lt;*\u0026gt; FUSE (Filesystem in Userspace) support 安装 emerge -av net-fs/curlftpfs 以普通用户挂载 首先，创建挂载点\nmkdir ./ftp 挂载\ncurlftpfs ftp://server/catalog/ ./ftp/ -o user=username:password,utf8,ssl ssl ：使用 SSL/TLS 传输数据\nutf8 ： 使用 utf8 编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","title":"Curlftpfs挂载ftp到本地"},{"content":"创建 SSH Key 运行下列命令创建 SSH Key，使用 github 帐号的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@email.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n配置 git ssh 默认私钥 ssh 默认使用的私钥文件定义在 /etc/ssh/ssh_config 或 ~/.ssh/config，如下：\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 为 github.com 指定密钥，修改 ~/.ssh/config：\nHost github.com IdentityFile /home/user/.ssh/id_rsa_gh 建议给 id_rsa 重命名，以免和其他密钥搞混\nGithub 添加 SSH Key 查看公钥的内容，执行：\ncat ~/.ssh/id_rsa.pub 打开 github 主页右上角头像，在 Settings -\u0026gt; SSH and GPG keys 中添加 SSH Key，将上面的输出复制进去。\n验证 # 使用默认路径的密钥 ssh -T git@github.com # 也可以指定密钥路径 ssh -i \u0026lt;rsa_path\u0026gt; -T git@github.com 返回如下信息则配置成功\nYou\u0026#39;ve successfully authenticated, but GitHub does not provide shell access 使用 SSH Key 推送 使用以上的链接\n","permalink":"https://kingtuo123.com/posts/github-set-sshkey/","summary":"通过 ssh 来操作 github 仓库","title":"Github 设置 SSH Key"},{"content":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.gitignore\u0026#39; - \u0026#39;.gitmodules\u0026#39; pull_request: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 推送至仓库 git push -u origin master 查看Action中的信息，如上则配置正确。\n设置GitHub Pages Source 在Pages设置中，修改Source分支为gh-pages\n等待gh-pages自动部署完成后，即可打开站点。\n网站加速 国内访问 github.io 较慢，部署至阿里云 OSS 并使用 DCDN 加速。\n也可以直接使用DCDN加速github.io，但使用中发现缓存刷新较慢，导致页面显示异常等。\nBucket设置 设置Bucket读写权限权限为 公共读\n设置静态页面如下\n创建Accesskey 打开阿里云控制台右上角 头像 -\u0026gt; Accesskey管理\n选择 子用户Accesskey\nAccesskey创建成功后会生成 ID 和 SECRET，记得复制否则要重新创建。\n最后给当前子用户添加 AliyunOSSFullAccess 权限。\n添加Repository secrets 打开仓库主页(是仓库的setting不是个人)，Setting -\u0026gt; Secrets -\u0026gt; Actions，添加Accesskey的内容。\n配置GitHub action 在 gh-pages.yml 里追加以下内容\n- name: Setup AliyunOSS uses: manyuanrong/setup-ossutil@v2.0 with: # 地域节点在Bucket概览里查看 endpoint: \u0026#34;oss-cn-hangzhou.aliyuncs.com\u0026#34; access-key-id: ${{ secrets.ID }} access-key-secret: ${{ secrets.SECRET }} - name: Deploy To OSS # 将public下的页面拷贝至Bucket run: ossutil cp -rf ./public oss://kingtuo123/ 最后 git push 一下即可。\n全站加速配置 需要已备案的域名。\n再配置全站加速，域名管理 -\u0026gt; 添加域名 ，等待生成 CNAME 记录。\n最后在 DNS解析 中添加域名 CNAME 记录。\n","permalink":"https://kingtuo123.com/posts/hugo-deploy/","summary":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.","title":"Hugo deploy"}]