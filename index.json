[{"content":" 翻译自 Demystifying Firmware Linker Scripts，水平有限仅供参考。\n上一篇文章 ，我们谈到了在调用我们的主函数之前，在 MCU 上引导 C 环境。我们认为理所当然的一件事是函数和数据都被存储在二进制文件中的正确位置。今天，我们将通过学习内存区域和链接器脚本来深入了解这是如何发生的。\n你可能还记得以下自动发生的事情：\n我们使用了 \u0026amp;_ebss 、\u0026amp;_sdata 等变量，知道了每个部分在 flash 中的位置，并定义一些变量在 RAM 中的位置。 MCU 在地址 0x00000004 找到了指向我们的 ResetHandler 的指针地址。 你会发现一些 MCU 有不同的内存映射，一些启动脚本以不同的方式命名这些变量，而一些程序有或多或少的段。 由于它们不是标准化的，因此需要在我们工程的某个地方指定这些内容。在工程使用类似 Unix-ld 工具链接的情况下，我们就需要链接器脚本。\n链接简介 链接是编译程序的最后一个阶段。它需要许多已编译的目标文件并将它们合并到一个程序中，并填写地址，以便一切都在正确的位置。\n下面的例子中，让我们来看看 main 函数发生了什么，先用编译器生成目标文件：\n$ arm-none-eabi-gcc -c -o build/objs/a/b/c/minimal.o minimal.c \u0026lt;CFLAGS\u0026gt; 把符号 dump 出来：\n$ arm-none-eabi-nm build/objs/a/b/c/minimal.o ... 00000000 T main ... 正如预期的那样，它还没有地址。然后，我们将链接所有内容：\n$ arm-none-eabi-gcc \u0026lt;LDFLAGS\u0026gt; build/objs/a/b/c/minimal.o \u0026lt;other object files\u0026gt; -o build/minimal.elf 我们再把 elf 文件的符号 dump 出来：\n$ arm-none-eabi-nm build/minimal.elf ... 00000294 T main ... 链接器已经完成了它的工作，我们的主函数已经被分配了一个地址。\n链接器的作用通常不止于此。例如，它可以生成调试信息、垃圾收集未使用的代码部分或运行整个程序优化（也称为链接时间优化或 LTO）。 有关链接器的更多信息，请参阅 Stack Overflow 上的一个很棒的帖子。\n链接器脚本解析 链接描述文件包含四个内容：\nMemory layout：什么内存在哪里可用 Section definitions：程序的哪个部分应该放在哪里 Options：用于指定架构、入口点等的命令。如果需要的话 Symbols：在链接时注入程序的变量 Memory Layout 为了分配程序空间，链接器需要知道有多少内存可用，以及该内存所在的地址。这就是链接描述文件中的 MEMORY 定义的用途。\nMEMORY 的语法在 binutils 文档中定义，如下所示：\nMEMORY { name [(attr)] : ORIGIN = origin, LENGTH = len ... } name 是用于这个区域的名称，名称没有意义，可任意命名。 attr 是可选属性，例如这个区域是可读（r），可写（w），可执行（x）。flash 一般是（rx），ram 是（rwx）。将区域标记为不可写并不会使其写保护，这些属性旨在描述内存的属性，而不是设置它。 origin 是内存区域的起始地址。 len 是内存区域的大小，以字节为单位。 SAMD21G18 芯片的内存映射表如下：\n内存 起始地址 大小 内部 Flash 0x00000000 256 Kbytes 内部 SRAM 0x20000000 32 Kbytes 写成 MEMORY 定义，如下：\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } Section Definitions code 和 data 都被打包进 sections，它在内存中是一块连续的地址。没有硬性规定应该有多少 sections 或存放哪些 symbols。以下两种情况通常会把 symbols 放到同一 section 中：\n它们应该在同一个内存区域 它们需要一起初始化 在上一篇文章中，我们了解了两种批量初始化的符号：\n必须从 flash 复制的初始化静态变量 必须归零的未初始化静态变量 我们的链接器脚本涉及到的另外两样东西：\n代码和常量数据，可以存在于只读存储器（例如flash） RAM 的保留部分，如栈或堆 按照惯例，我们将这些部分命名如下：\n.text 代码和常量 .bss 未初始化的数据 .stack 栈 .data 已初始化的数据 elf spec 有完整的变量列表。你可以给它们起别的名字，即使固件能正常运行但不能保证某些工具在使用到这个固件时不会出现奇怪的错误。唯一不能用作命名的是 /DISCARD/ ，这是一个保留的关键字。\n首先，让我们看看如果我们不在链接描述文件中定义任何这些部分，我们的符号会发生什么。\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } SECTIONS { /* empty! */ } 使用 objdump 查看生成的 elf 文件，我们看到以下内容：\n$ arm-none-eabi-objdump -h build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: no symbols 没有符号！虽然链接器能在几乎没有信息的情况下链接，但它至少需要知道入口点应该是什么，或者在 text section 中放置什么符号。\n.text Section 让我们从添加 .text section 开始。我们想让这个 section 在 ROM 中。下面是语法：\nSECTIONS { .text : { } \u0026gt; rom } 上面定义了一个名为 .text 的 section，并将其添加到 ROM。然后我们需要告诉连链接器需要在 section 中添加什么。\n为了找出我们目标文件中有哪些 section。我们再 objdump 一次：\n$ arm-none-eabi-objdump -h build/objs/a/b/c/minimal.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000000 00000000 00000000 00000034 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000000 00000000 00000000 00000034 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000034 2**0 ALLOC 3 .bss.cpu_irq_critical_section_counter 00000004 00000000 00000000 00000034 2**2 ALLOC 4 .bss.cpu_irq_prev_interrupt_state 00000001 00000000 00000000 00000034 2**0 ALLOC 5 .text.system_pinmux_get_group_from_gpio_pin 0000005c 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 6 .text.port_get_group_from_gpio_pin 00000020 00000000 00000000 00000090 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 7 .text.port_get_config_defaults 00000022 00000000 00000000 000000b0 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 8 .text.port_pin_set_output_level 0000004e 00000000 00000000 000000d2 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 9 .text.port_pin_toggle_output_level 00000038 00000000 00000000 00000120 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.set_output 00000040 00000000 00000000 00000158 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.main 0000002c 00000000 00000000 00000198 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 我们看到每一个符号都有一个 section。这是因为我们在编译时指定了 -ffucntion-sections 和 -fdata-sections 标志。如果我们没有包含这些标志，编译器可以将多个函数包含进一个 section 中去。\n在我们的链接器脚本中要将所有函数都放到 .text 中，我们可以按以下语法：\n\u0026lt;filename\u0026gt;(\u0026lt;section\u0026gt;) filename 是包含我们所需符号的输入文件的名称，section 就是该文件中包含的 section 的名称。如果我们想要取一个文件中所有的 .text section，我们可以使用 * 通配符：\n.text : { KEEP(*(.vector*)) *(.text*) } \u0026gt; rom 这里注意 .vector section，它是入口函数 Reset_Handler 所在的 section，我们需要把它放在最前面。\nKEEP( ) 函数告诉链接器不要把 .vector section 当作垃圾回收。因为 Reset_Handler 是入口函数，我们没有在程序的任何地方调用它，链接器会把没有被调用的函数当作垃圾处理以减少最后生成文件的体积。\n编译后，我们 dump 下 elf 文件，可以看到如下：\n$ arm-none-eabi-objdump -t build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: 00000000 l d .text 00000000 .text ... 00000000 l df *ABS* 00000000 minimal.c 00000000 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 0000005c l F .text 00000020 port_get_group_from_gpio_pin 0000007c l F .text 00000022 port_get_config_defaults 0000009e l F .text 0000004e port_pin_set_output_level 000000ec l F .text 00000038 port_pin_toggle_output_level 00000124 l F .text 00000040 set_output 00000000 l df *ABS* 00000000 port.c 00000190 l F .text 00000028 system_pinmux_get_config_defaults 00000000 l df *ABS* 00000000 pinmux.c 00000208 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 00000264 l F .text 00000110 _system_pinmux_config 00000164 g F .text 0000002c main 000001b8 g F .text 0000004e port_pin_set_config 00000374 g F .text 00000040 system_pinmux_pin_set_config ... .bss Section .bss 段存放的是未初始化的变量，如下：\nSECTION { ... .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u0026gt; ram } 注意 *(COMMON) ，这是一个特殊的段名，用来表示未初始化的全局变量。例如 int foo 就会在这个段中，static int foo 则不会。如果它们具有相同的名称，这允许链接器将多个定义合并到一个符号中。\n这里还使用了 NOLOAD 属性标记该段不可加载，这样当程序运行时它就不会被加载到内存中。\n在符号表中，未初始化的局部静态变量，初始化为0的全局变量及局部静态变量都wei会被表示在bss段。但是未初始化的全局变量会表示为COMMON，也相当于在bss段，但COMMON有特殊含义。未初始化的局部静态变量由于是仅编译单元内可见，不需要导出符号。所以不用置为COMMON，直接标识为bss段。\n.stack Section .stack 同样不用加载到内存中，由于堆栈不包含符号，我们需要显示的指示其大小为其保留空间。我们还必须按照 ARM 过程调用标准 AAPCS 在8字节边界上对齐堆栈。\n为了实现这些目标，我们使用一个特殊的变量 .，也称为“位置计数器”。位置计数器表示当前所在位置的地址。随着段的添加，位置计数器也会相应增加。你可以通过向前设置位置计数器来强制对齐或间隙。\nSTACK_SIZE = 0x2000; /* 8 kB */ SECTION { ... .stack (NOLOAD) : { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u0026gt; ram ... } .data Section .data 部分包含在启动时具有初始值的静态变量。您会记得我们之前的文章中，由于断电时 RAM 不会保持不变，因此需要从 flash 加载这些部分。在启动时，Reset_Handler 在调用 main 函数之前将数据从 flash 复制到 RAM。\n为了实现这一点，我们的链接脚本中的每个部分都有两个地址，加载地址 (LMA) 和虚拟地址 (VMA)。LMA 是在ROM 中的地址，VMA 是在 RAM 中的地址。我们生成的 bin 烧录文件，它的数据顺序就是我们在链接脚本中定义的这些 sections 的顺序，bin 文件烧录到 flash 中后的顺序也是一样的，当程序运行时，我们需要把数据从 flash 拷贝到栈中，栈所在的地址就是 VMA，flash 中的地址就是 LMA。\n使用 AT 指定加载地址：\n.data : { *(.data*); } \u0026gt; ram AT \u0026gt; rom /* \u0026#34;\u0026gt; ram\u0026#34; is the VMA, \u0026#34;\u0026gt; rom\u0026#34; is the LMA */ 还可以显式指定一个地址，如下：\n.data 0x2000 : AT(0x4000) { . = ALIGN(4); _sdata = .; *(.data*); . = ALIGN(4); _edata = .; } 通常情况下从 Flash 执行的程序，text 段 VMA 和 LMA 是一样的。data 段的VMA会放在 RAM 中，LMA 会放在 flash 中，所以 data 段的 VMA 和 LMA 通常不一样。\n完整的链接器脚本 MEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } STACK_SIZE = 0x2000; /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) } \u0026gt; rom /* .bss section which is used for uninitialized data */ .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u0026gt; ram .data : { *(.data*); } \u0026gt; ram AT \u0026gt;rom /* stack section */ .stack (NOLOAD): { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u0026gt; ram _end = . ; } 你可以在这里找到链接器脚本的详细语法 ld manual。\n变量 在上一篇文章中，我们依靠变量获取每个 section 的地址。\n为了能在程序中调用这些变量，链接器会生成符号并将他们添加进程序中。你可以在 linker documentation 找到相关的语法。类似C语言的变量定义：symbol = expression\n本例中，我们需要：\n_etext ： .text 段结束地址 _sdata ： .data 段起始地址 _edata ： .data 段结束地址 _sbss ： .bss 段起始地址 _ebss ： .bss 段结束地址 我们可以在每个 section 的开头和结尾使用位置计数器 . 定义变量：\n.text : { KEEP(*(.vectors .vectors.*)) *(.text.*) *(.rodata.*) _etext = .; } \u0026gt; rom .bss (NOLOAD) : { _sbss = . ; *(.bss .bss.*) *(COMMON) _ebss = . ; } \u0026gt; ram .data : { _sdata = .; *(.data*); _edata = .; } \u0026gt; ram AT \u0026gt;rom 在程序中必须使用对这些变量的引用，而不是变量本身。例如，以下代码为我们提供了一个指向 .data 部分开头的指针：\nuint8_t *data_byte = \u0026amp;_sdata; 你可以在这里了解更多细节 binutils docs 。\n","permalink":"https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/","summary":"简述链接器做了哪些工作、链接器脚本的语法及如何编写","title":"Demystifying Firmware Linker Scripts"},{"content":" 翻译自 From Zero to main(): Bare metal C，水平有限仅供参考。\n嵌入式开发遵循下列原则：\n程序的入口点应命名为 “main”。 你应该初始化静态变量，否则机器会将它们设置为零。 你应该实现中断。其中主要有 HardFault_Handler，还有 SysTick_Handler。 准备平台 本文介绍的大多数概念和代码都适用于所有 Cortex-M 系列 MCU，但我们的示例针对的是 Atmel 的 SAMD21G18 处理器，这是一款 Cortex-M0+ 芯片。\n本文使用到以下工具：\nAdafruit’s Metro M0 Express 开发板 一个 CMSIS-DAP 仿真器 用于编程的 OpenOCD ( Arduino fork) 我们将实现一个简单的 LED 闪烁程序，下面是代码：\n#include \u0026lt;samd21g18a.h\u0026gt; #include \u0026lt;port.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define LED_0_PIN PIN_PA17 static void set_output(const uint8_t pin) { struct port_config config_port_pin; port_get_config_defaults(\u0026amp;config_port_pin); config_port_pin.direction = PORT_PIN_DIR_OUTPUT; port_pin_set_config(pin, \u0026amp;config_port_pin); port_pin_set_output_level(pin, false); } int main() { set_output(LED_0_PIN); while (true) { port_pin_toggle_output_level(LED_0_PIN); for (volatile int i = 0; i \u0026lt; 100000; ++i) {} } } 上电 我们是如何进入 main 的？从观察中我们可以看出我们给板子上电后程序开始执行。所以芯片肯定有一套固定的流程来定义代码的执行方式。\n确实有！深入研究 ARMv6-M 技术参考手册，这是 Cortex-M0+ 的底层架构手册，我们可以找到一些描述复位行为的伪代码：\n// B1.5.5 TakeReset() // ============ TakeReset() VTOR = Zeros(32); for i = 0 to 12 R[i] = bits(32) UNKNOWN; bits(32) vectortable = VTOR; CurrentMode = Mode_Thread; LR = bits(32) UNKNOWN; // Value must be initialised by software APSR = bits(32) UNKNOWN; // Flags UNPREDICTABLE from reset IPSR\u0026lt;5:0\u0026gt; = Zeros(6); // Exception number cleared at reset PRIMASK.PM = \u0026#39;0\u0026#39;; // Priority mask cleared at reset CONTROL.SPSEL = \u0026#39;0\u0026#39;; // Current stack is Main CONTROL.nPRIV = \u0026#39;0\u0026#39;; // Thread is privileged ResetSCSRegs(); // Catch-all function for System Control Space reset for i = 0 to 511 // All exceptions Inactive ExceptionActive[i] = \u0026#39;0\u0026#39;; ClearEventRegister(); // See WFE instruction for more information SP_main = MemA[vectortable,4] AND 0xFFFFFFFC\u0026lt;31:0\u0026gt;; SP_process = ((bits(30) UNKNOWN):\u0026#39;00\u0026#39;); start = MemA[vectortable+4,4]; // Load address of reset routine BLXWritePC(start); // Start execution of reset routine 简而言之，芯片做了以下工作：\n将向量表地址重置为 0x00000000 禁用所有中断 从 0x00000000 读取堆栈指针（SP）的地址 从 0x00000004 读取程序计数器（PC）的地址 谜团解开了，看来我们的 main 函数必须在地址 0x00000004 处。\nSP 指向栈顶，0x00000000 存的是栈顶的地址。\nPC 指向下一条指令的地址，0x00000004 存的是程序初始入口地址。\n我们把 bin 文件 dump 出来，看看在地址 0x0000000 和 0x00000004 有什么内容：\nfrancois-mba:zero-to-main francois$ xxd build/minimal/minimal.bin | head 00000000: 0020 0020 c100 0000 b500 0000 bb00 0000 . . ............ 00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 从上面来看，我们的初始堆栈地址是 0x20002000 ，程序初始入口地址是 0x000000c1\n我们再把符号表 dump 出来，看在地址 0x000000c1 上是什么：\nfrancois-mba:minimal francois$ arm-none-eabi-objdump -t build/minimal.elf | sort ... 000000b4 g F .text 00000006 NMI_Handler 000000ba g F .text 00000006 HardFault_Handler 000000c0 g F .text 00000088 Reset_Handler 00000148 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 000001a4 l F .text 00000020 port_get_group_from_gpio_pin 000001c4 l F .text 00000022 port_get_config_defaults 000001e6 l F .text 0000004e port_pin_set_output_level 00000234 l F .text 00000038 port_pin_toggle_output_level 0000026c l F .text 00000040 set_output 000002ac g F .text 0000002c main ... 这很奇怪，我们的 main 函数在地址 0x000002ac 处。并没有符号对应地址 0x000000c1 ，但是 0x000000c0 处有一个 Reset_Handler。\n其实，PC 的最低位用来表示 thumb2 指令，它是 ARM 处理器支持的两个指令集之一，所以 Reset_Handler 就是我们要找的入口函数。\n有些ARM处理器即能使用ARM指令，又能兼容Thumb指令，同一个应用程序中可能同时存在ARM指令和Thumb指令，这两者的处理方式肯定是大不相同的，所以为了切换ARM状态和Thumb状态，在跳转到Thumb指令编写的代码块的时候，将程序地址的最低位置1（因为不管是ARM指令还是Thumb指令，都至少是2字节对齐的，所以最低位一定是0，所以最低位可以拿来用于区分ARM状态和Thumb状态），这样处理器识别到最低位为1的话就会切换到Thumb状态，否则则是ARM状态。Thumb2指令集也是为了兼容以前的ARM状态和Thumb状态这样做的。\n编写一个 Reset_Handler 不幸的是，Reset_Handler 通常是一堆混乱的汇编代码，看这个例子 nRF52 SDK startup 。与其逐行浏览这个文件，不如看看我们是否可以根据第一原则编写一个最小的 Reset_Handler。\n在这里，ARM 的技术参考手册也很有用。 Cortex-M3 TRM 第 5.9.2 包含下面的表格:\n动作 描述 初始化变量 任何全局/静态变量都需要被设置。包括初始化 BSS 变量为0，以及将非常量变量的初始化值从 ROM 拷贝到 RAM。 设置堆栈 如果用了多个堆栈，那么这些堆栈的 SP 也要初始化。The current SP can also be changed to Process from Main。 初始化运行时 可以选择调用 C/C++ 运行时初始化代码以启用堆、浮点或其他功能。这通常由 C/C++ 库中的 __main 完成。 因此，我们的 ResetHandler 负责初始化静态和全局变量，并启动我们的程序。这反映了 C 标准告诉我们的内容：\n所有具有静态存储持续时间的对象都应在程序启动之前进行初始化（设置为其初始值）。这种初始化的方式和时间是未指定的。\n在实践中，这意味着给定以下代码段：\nstatic uint32_t foo; static uint32_t bar = 2; 我们的 Reset_Handler 需要确保 \u0026amp;foo 处的内存为 0x00000000，\u0026amp;bar 处的内存为 0x00000002。\n我们不能一个一个地初始化每个变量。相反，我们依靠编译器（技术上来讲，是链接器）将所有这些变量放在同一个地方，这样我们就可以一次初始化它们。\n对于必须归零的静态变量，链接器为我们提供 _sbss 和 _ebss 作为开始和结束地址。因此我们可以这样做：\n/* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } 对于具有初始值的静态变量，链接器为我们提供：\n_etext 作为存储初始值的地址（ROM） _sdata 作为静态变量所在的起始地址（RAM） _edata 作为静态变量所在的结束地址（RAM） 然后我们可以这样做：\nuint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } 把它们放在一起，可以编写我们的 Reset_Handler：\nvoid Reset_Handler(void) { /* Copy init values from text to data */ uint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } /* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } } 我们还需要启动我们的主程序！可以通过简单的调用 main() 来实现。\nvoid Reset_Handler(void) { /* Copy init values from text to data */ uint32_t *init_values_ptr = \u0026amp;_etext; uint32_t *data_ptr = \u0026amp;_sdata; if (init_values_ptr != data_ptr) { for (; data_ptr \u0026lt; \u0026amp;_edata;) { *data_ptr++ = *init_values_ptr++; } } /* Clear the zero segment */ for (uint32_t *bss_ptr = \u0026amp;_sbss; bss_ptr \u0026lt; \u0026amp;_ebss;) { *bss_ptr++ = 0; } /* 译者注：这应该是这个芯片的Bug */ /* 覆盖 NVMCTRL.CTRLB.MANW 位的默认值（勘误参考 13134）*/ NVMCTRL-\u0026gt;CTRLB.bit.MANW = 1; /* 切换到主函数 */ main(); /* 死循环 */ while (1); } 你会注意到我们加了两样东西：\nmain() 后面有一个死循环，这样一来 main 函数返回的话就不会导致程序跑飞出现意料之外的情况。 处理芯片 bug 的最好方法是在我们的主程序启动之前解决它。有时这些方法被包含在一个 SystemInit 函数中，该函数在 main 之前由 Reset_Handler 调用。这是 Nordic 采用的方法。 结束 本文的所有代码都可以在这里找到 Github。\n更复杂的程序通常需要更复杂的 Reset_Handler。例如：\n可重定位代码必须要复制过来 如果我们的程序依赖于 libc，我们必须初始化它 更复杂的内存布局可以添加一些 拷贝/归零 的循环 我们将在以后的文章中介绍所有这些。但在此之前，我们将在下一篇文章中讨论神奇的内存区域变量是如何产生的，我们的 Reset_Handler 的地址为什么是 0x00000004 ，以及如何编写链接器脚本文件！\n","permalink":"https://kingtuo123.com/posts/bare-metal-c/","summary":"简述了裸机程序从上电开始，是如何进入主程序的","title":"Bare metal C"},{"content":"stm32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 厂家的 BootLoader 已提供了串口下载的功能，所以我们只要进入 BootLoader 即可。\n即在单片机启动时将BOOT0置高电平，BOOT1置低电平。\n一键下载电路 本文以野火霸道V2.0开发板为例\n要进入bootloader，有以下流程:\nBOOT1 跳线接 GND DTR 置高电平，RTS 置低电平 Q3 被导通，NRST 被拉低，单片机复位 Q5 被导通，BOOT0 被拉高 DTR 置低电平，释放复位 启动进入 BootLoader 这里注意CH340G 芯片，DTR 和 RTS 输出电平是反向的（芯片图DTR上方有一横线）。所以实际是， DTR 低电平复位，RTS 高电平进入BootLoader。\nWindows ISP 下载 如上图所示：DTR 低电平复位，RTS 高电平进入BootLoader。\nLinux ISP 下载 Linux 下使用 stm32flash 下载。下载解压后文件夹内有 stm32flash_linux 。\n该命令有以下参数\nUsage: stm32flash_linux [-bvngfhc] [-[rw] filename] [tty_device|i2c_device] -a bus_address # 总线地址 -b rate # 波特率 -m mode # 串口模式 -r filename # 读取flash到文件（或者使用 - 符号， 表示标准输出） -w filename # 写入文件到flash（或者使用 - 符号， 表示标准输出） -C # 计算flash crc校验码 -u # 禁用flash写保护 -j # 启用flash读保护 -k # 禁用flash读保护 -o # 仅擦除 -e n # 写入flash前仅擦除n页，默认全擦 -v # 写入后校验 -n count # 写入失败重试次数，默认10 -g address # 指定程序开始执行的地址 -S address[:length] # 指定读取/写入的起始地址和长度（可选） -F RX_length[:TX_length] # 指定接收/发送帧的最大长度 -s start_page # 在指定的页面写入 -f # 强制二进制解析 -h # 显示帮助信息 -c # 恢复连接 -R # 退出时复位设备 -i GPIO_string # 设置进入/退出BootLoader时信号输出的顺序 # GPIO_string=[entry_seq][:[exit_seq]] # sequence=[[-]signal]\u0026amp;|,[sequence] GPIO sequence: # 使用‘dtr’，‘rts’，‘brk’表示串口输出信号 # ‘,’表示在在两个信号之间加100ms延时 # ‘\u0026amp;’表示两个信号之间不加延时 # 在信号前加‘-’表示低电平，不加表示高电平 读取芯片信息，执行以下命令（root）：\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; /dev/ttyUSB0 参数说明：\n-b 115200 ，指定115200波特率 -dtr\u0026amp;rts,dtr -dtr\u0026amp; 拉低复位 rts, 拉高 BOOT0，延时100ms dtr 释放复位，进入 BootLoader -dtr\u0026amp;-rts,dtr -dtr\u0026amp; 拉低复位 -rts, 拉低 BOOT0，延时100ms dtr 释放复位，flash启动进入用户程序 /dev/ttyUSB0，设备串口 上述命令执行成功输出以下信息：\nInterface serial_posix: 115200 8E1 GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 1... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end Version : 0x22 Option 1 : 0x00 Option 2 : 0x00 Devive ID : 0x0414 (STM32F10XX High-density) - RAM : Up to 64KiB (512b reserved by bootloader) - Flash : Up to 512Kib (size first sector: 2x2048) - Option RAM : 16b - System RAm : 2KiB GPIO sequence start setting port signal dtr to 0... ok setting port signal rts to 0... ok delay 100000 us setting port signal dtr to 1... ok GPIO sequence end 下载程序，执行以下命令\nstm32flash_linux -b 115200 -i \u0026#39;-dtr\u0026amp;rts,dtr:-dtr\u0026amp;-rts,dtr\u0026#39; -v -w test.bin /dev/ttyUSB0 ","permalink":"https://kingtuo123.com/posts/stm32-isp-flash/","summary":"ISP 一键下载原理，windows 和 linux 平台 ISP 下载方法","title":"STM32 ISP 一键下载"},{"content":" 翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\nMakefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command targets 是文件名，以空格分隔。通常一个规则只有一个目标。\ncommand 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\nprerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\nmake 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的C程序。 blah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c # 第一个运行 下面这个 makefile 有一个目标 some_file 。默认目标是第一个目标，所以将执行 some_file 下的 echo 命令。\nsome_file: echo \u0026#34;This line will always print\u0026#34; 下面这个 makefile 第一次运行会生成 some_file 。第二次运行由于 some_file 已存在，会提示 make: 'some_file' is up to date 。\nsome_file: echo \u0026#34;This line will only print once\u0026#34; touch some_file 下面这个 makefile 中 some_file 依赖 other_file 。当第一次执行 make ，默认目标是 some_file ，它首先会查找依赖文件 other_file ，只要依赖文件比目标文件 some_file 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。\nsome_file: other_file echo \u0026#34;This will run second, because it depends on other_file\u0026#34; touch some_file other_file: echo \u0026#34;This will run first\u0026#34; touch other_file 下面这个 makefile 始终会执行默认目标的命令，因为它的依赖始终无法满足。\nsome_file: other_file touch some_file other_file: echo \u0026#34;nothing\u0026#34; clean 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file 变量 变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。\n使用 $( ) 调用或 ${ }。\nobj = a.o b.o c.o\rtest: $(obj)\rgcc -o test $(obj) 变量赋值一般有如下符号：\n符号 作用 = 变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。 := 变量赋值，与普通的编程语言中的赋值一样。 += 变量追加赋值 ?= 变量为空则给它赋值 = 与 := 的区别：\n# 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: echo $(one) echo $(two) := 允许你追加变量，但会导致死循环，如下。\none = hello # one gets defined as a simply expanded variable (:=) and thus can handle appending one := ${one} there all: echo $(one) ?= 仅设置尚未设置的变量\none = hello one ?= will not be set two ?= will be set all: echo $(one) # 打印 hello echo $(two) # 打印 will be set 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\n以下 makefile 使用 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 通配符 通配符 作用 * 匹配零或多个字符 % 匹配一个或多个字符 ? 匹配单个字符 * 和 % 在 makefile 中都是通配符，但它们的含义完全不同。\n* 会搜索你的文件系统来匹配文件名。个人建议调用 wildcard 函数来使用 * 。\n# 打印出当前路径下所有以.c结尾的文件的信息 print: $(wildcard *.c) ls -la $? 危险：不要在变量定义中使用 * 。\n危险：当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\nthing_wrong := *.o # 不要这样做，\u0026#39;*\u0026#39; 不会被展开，会被视作 \u0026#34;*.o\u0026#34; 字符串 thing_right := $(wildcard *.o) # 正确做法 all: one two three four # 这里会出错，因为 $(thing_wrong) 是字符串 \u0026#34;*.o\u0026#34; one: $(thing_wrong) # 如果没有文件以 \u0026#34;.o\u0026#34; 结尾，匹配不到文件时也会被视作字符串 \u0026#34;*.o\u0026#34; two: *.o # 正确运行 three: $(thing_right) # 同规则 \u0026#34;three\u0026#34; four: $(wildcard *.o) 自动化变量 符号 描述 $@ 当前目标名 $^ 所有依赖名，去重 $\u0026lt; 第一个依赖名 $+ 所有依赖名，不去重 $? 比目标新的依赖名 $* 目标中%匹配的部分 hey: one two # 输出 \u0026#34;hey\u0026#34; echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two 规则 隐式规则 隐式规则会让东西变得混乱，不推荐使用，但是要了解。\n编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的 隐式规则常用的几个变量：\nCC ：C 程序编译器，默认 cc 。 CXX ：C++ 程序编译器，默认 g++ 。 CFLAGS ：提供给 C 编译器的参数。 CXXFLAGS ：提供给 C++ 编译器的参数。 CPPFLAGS ：提供给 C 预处理器的参数。 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数。 下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; blah.c clean: rm -f blah* 静态模式规则 下面是语法：\ntargets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \u0026#34;int main() { return 0; }\u0026#34; \u0026gt; all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 函数搭配使用，如下\nobj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \u0026#34;target: $@ prereq: $\u0026lt;\u0026#34; %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u0026lt; -o $@ 模式规则在目标中包含一个 % 。这个 % 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 % 代表与目标中的 % 匹配的相同词干。\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # $@ 表示目标文件 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。\nall: blah blah:: echo \u0026#34;hello\u0026#34; blah:: echo \u0026#34;hello again\u0026#34; 命令 不打印命令 在命令前加 @ ，在运行时这条命令不会被打印出来。在 make 时加上 -s 参数有同样的效果。\nall: @echo \u0026#34;This make line will not be printed\u0026#34;\recho \u0026#34;But this will\u0026#34; 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\ echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \u0026#34;Hello from bash\u0026#34; 错误处理 在运行 make 时添加 -k 参数（\u0026ndash;keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （\u0026ndash;ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n嵌套执行 make 要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。\n# 双引号中的内容等同于 # hello: # touch inside_file new_contents = \u0026#34;hello:\\n\\ttouch inside_file\u0026#34; all: mkdir -p subdir printf $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile #去掉第一行的空格并写入subdir/makefile cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 使用 export 嵌套 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：\nnew_contents = \u0026#34;hello:\\n\\\\techo \\$$(cooly)\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) # 注意输出的信息，可以看到 export 全局声明起到了作用 cooly = \u0026#34;The subdirectory can see me!\u0026#34; export cooly # 取消全局: unexport cooly clean: rm -rf subdir 你也可以在 shell 中使用全局变量\none=this will only work locally export two=we can run subcommands with this all: @echo $(one) # $$ 的意思是使用真实的 $ 符号 # 即 echo $one，由于one未声明全局环境变量，所以这条打印为空 @echo $$one @echo $(two) @echo $$two 也可以使用 .EXPORT_ALL_VARIABLES 将所用的变量都声明为全局的。\n.EXPORT_ALL_VARIABLES: new_contents = \u0026#34;hello:\\n\\techo \\$$(cooly)\u0026#34; cooly = \u0026#34;The subdirectory can see me!\u0026#34; all: mkdir -p subdir echo $(new_contents) | sed -e \u0026#39;s/^ //\u0026#39; \u0026gt; subdir/makefile @echo \u0026#34;---MAKEFILE CONTENTS---\u0026#34; @cd subdir \u0026amp;\u0026amp; cat makefile @echo \u0026#34;---END MAKEFILE CONTENTS---\u0026#34; cd subdir \u0026amp;\u0026amp; $(MAKE) clean: rm -rf subdir 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量。在这里，我们使用 make option_one=hi 运行 make\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: echo $(option_one) echo $(option_two) define函数定义 one = export blah=\u0026#34;I was set!\u0026#34;; echo $$blah define two export blah=set echo $$blah endef # One 和 two 是不一样的 all: @echo \u0026#34;这条会打印 \u0026#39;I was set\u0026#39;\u0026#34; @$(one) @echo \u0026#34;这条不会打印 \u0026#39;I was set\u0026#39; 因为每条命令运行在不同的shell中\u0026#34; @$(two) 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 if/else foo = ok all: ifeq ($(foo), ok) echo \u0026#34;foo equals ok\u0026#34; else echo \u0026#34;nope\u0026#34; endif 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格 all: ifeq ($(strip $(foo)),) echo \u0026#34;foo is empty after being stripped\u0026#34; endif ifeq ($(nullstring),) echo \u0026#34;nullstring doesn\u0026#39;t even have spaces\u0026#34; endif 检查变量是否定义 bar = foo = $(bar) all: ifdef foo echo \u0026#34;foo is defined\u0026#34; endif ifdef bar echo \u0026#34;but bar is not\u0026#34; endif 命令行参数 $(MAKEFLAGS) bar = foo = $(bar) all: # 查找 \u0026#34;-i\u0026#34; 参数。 ifneq (,$(findstring i, $(MAKEFLAGS))) echo \u0026#34;i was passed to MAKEFLAGS\u0026#34; endif 函数 函数主要只是用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\n# 字符串替换，这里 totally 替换 not bar := ${subst not, totally, \u0026#34;I am not superman\u0026#34;} all: @echo $(bar) 如果要替换空格或逗号，请使用变量\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \u0026#34;a,b,c\u0026#34; @echo $(bar) 不要在第一个参数之后包含空格。这将被视为字符串的一部分。\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 后面有一个空格 all: # 输出是 \u0026#34;, a , b , c\u0026#34;，注意空格 @echo $(bar) 字符串替换 $(patsubst pattern,replacement,text) 执行以下操作：\n使用 pattern 匹配 text 中的文件名，使用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 $(foreach var,list,text) ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\n这会在每个单词后附加一个感叹号：\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \u0026#34;who! are! you!\u0026#34; @echo $(bar) if 函数 if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 Make 支持创建基本函数。语法是 $(call variable,param,param)\n$(0) 是变量名，$(1) 、$(2) 等是参数。\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \u0026#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\u0026#34; @echo $(call sweet_new_fn, go, tigers) shell 函数 这会调用 shell，但它用空格替换了换行符。\nall: # 非常难看，因为换行符不见了 @echo $(shell ls -la) 其他特性 应用外部makefile include 的语法是\ninclude filenames vpath 指令 语法 vpath \u0026lt;pattern\u0026gt; \u0026lt;directories\u0026gt; ，\u0026lt;pattern\u0026gt; 会匹配 \u0026lt;directories\u0026gt; 中的文件名，多个目录使用 空格 或 冒号 分隔。\nvpath %.h ../headers ../other-directory\rsome_binary: ../headers blah.h\rtouch some_binary\r../headers:\rmkdir ../headers\rblah.h:\rtouch ../headers/blah.h\rclean:\rrm -rf ../headers\rrm -f some_binary .phony make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 标签 ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 make clean 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n.PHONY clean clean: rm -f *.o .delete_on_error 当规则执行失败，.delete_on_error 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise. SRCS := $(shell find $(SRC_DIRS) -name \u0026#39;*.cpp\u0026#39; -or -name \u0026#39;*.c\u0026#39; -or -name \u0026#39;*.s\u0026#39;) # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u0026lt; -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u0026lt; -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # Include the .d makefiles. The - at the front suppresses the errors of missing # Makefiles. Initially, all the .d files will be missing, and we don\u0026#39;t want those # errors to show up. -include $(DEPS) ","permalink":"https://kingtuo123.com/posts/makefile-basic/","summary":"Makefile 的基本语法，规则及命令。","title":"Makefile基础"},{"content":"docker镜像 拉取镜像 docker image pull \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; 查看镜像 docker image ls -a docker images 删除镜像 docker image rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; docker image rm \u0026lt;image id\u0026gt; id不用补全，比如 ba6acccedd29 ，只需输入 ba ，只要id前几位没和其他镜像重复。\n当镜像已有创建的容器时，无法删除。可以使用-f参数强制删除。\n提交镜像 首先你在基础镜像生成的容器中做了修改后，使用 commit 命令可以生成一个新的镜像，这个镜像相较于基础镜像多了一层Layer（你在容器内做的所有修改都打包成了Layer）\ndocker commit -m \u0026#34;some info\u0026#34; 生成的镜像可以用 image 命令查看到，commit 之后你可以使用 push 命令推送到远端仓库\ndocker容器 创建容器 以下命令会自动创建一个容器并运行bash，也可以用 create 命令创建容器。\ndocker container run --name \u0026lt;name\u0026gt; -it --rm \u0026lt;repository\u0026gt;:\u0026lt;tag\u0026gt; bash run 常用参数：\n--name：指定容器名称 -i：开启标准输入 -t：分配伪终端 --rm：退出容器后自动删除容器，多用于一次性测试 -v：挂载路径，格式 -v \u0026lt;host path\u0026gt;:\u0026lt;container path\u0026gt; -p：指定端口映射，格式 -p \u0026lt;host port\u0026gt;:\u0026lt;container port\u0026gt; -P：随机端口映射，docker会随机映射一个端口到内部容器的网络端口 -d：后台运行容器，并返回容器ID，类似命令后加\u0026amp; -e：设置环境变量，格式 -e \u0026lt;variables1\u0026gt;=\u0026lt;variables2\u0026gt; --network：连接指定网络，系统预定义的有bridge、host、null三种，默认bridge（桥接） --privileged：扩大容器权限，在容器内可以看到host的更多设备、可mount挂载设备 启动容器 docker container start \u0026lt;name|container id\u0026gt; start 后面可跟多个 id\n进入容器 docker container attach \u0026lt;name|container id\u0026gt; docker container exec -it \u0026lt;name|container id\u0026gt; bash attach 在退出容器后会停止容器，exec 不会\nattach 相当于进入当前终端，exec 相当于新开了一个终端\n停止容器 docker container stop \u0026lt;name|container id\u0026gt; docker container kill \u0026lt;name|container id\u0026gt; stop 先发送SIGTERM信号，容器内程序可以做退出前的准备工作，一段时间之后再发送SIGKILL信号。\nkill 发送SIGKILL信号，应用程序直接退出。\n查看容器 列出所有容器\ndocker container ls -a 删除容器 docker container rm \u0026lt;name|container id\u0026gt; 使用 prune 可以删除所有已停止的容器\ndocker container prune 文件拷贝 拷贝无需容器运行，只要该容器存在即可，以下命令从容器拷贝至主机\ndocker container cp \u0026lt;container id|name\u0026gt;:\u0026lt;container path\u0026gt; \u0026lt;host path\u0026gt; ","permalink":"https://kingtuo123.com/posts/docker-base-cmd/","summary":"Docker 镜像/容器常用的一些命令及说明","title":"Docker基本命令"},{"content":" 参考 Gentoo Wiki/Arduino\n启用内核选项 Device Drivers ---\u0026gt; [*] USB support ---\u0026gt; \u0026lt;*\u0026gt; USB Serial Converter support ---\u0026gt; \u0026lt;*\u0026gt; USB Winchiphead CH341 Single Port Serial Driver 重新编译内核。\n重启后连接设备，设备名为 /dev/ttyUSB0\n非ROOT用户访问权限 添加用户到 dialout 组\ngpasswd -a larry dialout ","permalink":"https://kingtuo123.com/posts/gentoo-ch340-driver/","summary":" 参考 Gentoo Wiki/Arduino\n启用内核选项 Device Drivers ---\u0026gt; [*] USB support ---\u0026gt; \u0026lt;*\u0026gt; USB Serial Converter support ---\u0026gt; \u0026lt;*\u0026gt; USB Winchiphead CH341 Single Port Serial Driver 重新编译内核。\n重启后连接设备，设备名为 /dev/ttyUSB0\n非ROOT用户访问权限 添加用户到 dialout 组\ngpasswd -a larry dialout ","title":"Gentoo ch340 驱动"},{"content":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n列表内容 列表内容 列表内容 有序列表 数字加点\n1. 列表内容 2. 列表内容 3. 列表内容 列表嵌套 二级列表前加三个空格\n- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 表格 表头|表头2222222|表头33333333 ---|:--:|--: 内容|内容|内容 内容|内容|内容 :--: 表示居中\n--: 靠右\n:-- 靠左\n显示如下\n表头 表头2222222 表头33333333 内容 内容 内容 内容 内容 内容 代码 ​```java 代码... 代码... 代码... ​``` ","permalink":"https://kingtuo123.com/posts/markdown-syntax/","summary":"标题 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 最后一个#号后面加空格\n字体样式 **这是加粗的文字** *这是倾斜的文字* ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 引用 \u0026gt; 这是引用的内容 \u0026gt;\u0026gt; 这是引用的内容 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 这是引用的内容 ##　分割线\n三个或者三个以上的 - 或者 * 都可以。\n--- ---- *** ***** 图片 ![图片alt](图片链接 \u0026#34;图片title\u0026#34;) 若要指定图片大小/位置，使用HTML\n\u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;1.png\u0026#34; style=\u0026#34;max-height:180px\u0026#34;\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; 超链接 [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) 列表 无序列表 - 和+ 和* 三个符号都可以\n- 列表内容 + 列表内容 * 列表内容 显示如下\n列表内容 列表内容 列表内容 有序列表 数字加点\n1. 列表内容 2.","title":"Markdown语法"},{"content":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","permalink":"https://kingtuo123.com/posts/curlftpfs-mount-local/","summary":"安装 emerge -av curlftpfs 需要内核启用 fuse\n以root挂载 创建挂载点\nmkdir /mnt/ftp 挂载，若没有用户名密码就省去 -o 及后面参数\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password 想让普通用户有访问权限，添加 allow_other 选项，以逗号分隔\ncurlftpfs ftp.example.com /mnt/ftp/ -o user=username:password,allow_other 以普通用户挂载 mkdir ~/example curlftpfs -o ssl,utf8 ftp://example.com/ ~/example ssl ：使用SSL/TLS传输数据\nutf8 ： 使用utf8编码\n卸载 fusermount -u ~/example 或者\numount ~/example ","title":"Curlftpfs挂载ftp到本地"},{"content":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。\n验证 ssh -T git@github.com 返回如下信息则配置成功\nYou\u0026#39;ve successfully authenticated, but GitHub does not provide shell access 使用SSH Key推送 使用以上的链接。\n","permalink":"https://kingtuo123.com/posts/github-set-sshkey/","summary":"创建SSH Key 运行下列命令创建SSH Key，邮箱使用github创建时用的邮箱。\nssh-keygen -t rsa -C \u0026#34;kingtuo123@foxmail.com\u0026#34; 输出如下，一路回车\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/king/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 以上会在 ～/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）文件。\n如果你没有使用默认的路径，记得修改 /etc/ssh/ssh_config 或 ~/.ssh/config\n# 这里是默认身份文件路径 # IdentityFile ~/.ssh/id_rsa # IdentityFile ~/.ssh/id_dsa # IdentityFile ~/.ssh/id_ecdsa # IdentityFile ~/.ssh/id_ed25519 添加公钥 查看公钥的内容\ncat ~/.ssh/id_rsa.pub 打开github在 setting -\u0026gt; SSH and GPG keys 中添加SSH Key，将上面的输出复制进去。","title":"Github设置SSH Key"},{"content":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.gitignore\u0026#39; - \u0026#39;.gitmodules\u0026#39; pull_request: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 推送至仓库 git push -u origin master 查看Action中的信息，如上则配置正确。\n设置GitHub Pages Source 在Pages设置中，修改Source分支为gh-pages\n等待gh-pages自动部署完成后，即可打开站点。\n网站加速 国内访问 github.io 较慢，部署至阿里云 OSS 并使用 DCDN 加速。\n也可以直接使用DCDN加速github.io，但使用中发现缓存刷新较慢，导致页面显示异常等。\nBucket设置 设置Bucket读写权限权限为 公共读\n设置静态页面如下\n创建Accesskey 打开阿里云控制台右上角 头像 -\u0026gt; Accesskey管理\n选择 子用户Accesskey\nAccesskey创建成功后会生成 ID 和 SECRET，记得复制否则要重新创建。\n最后给当前子用户添加 AliyunOSSFullAccess 权限。\n添加Repository secrets 打开仓库主页，Setting -\u0026gt; Secrets -\u0026gt; Actions，添加Accesskey的内容。\n配置GitHub action 在 gh-pages.yml 里追加以下内容\n- name: Setup AliyunOSS uses: manyuanrong/setup-ossutil@v2.0 with: # 地域节点在Bucket概览里查看 endpoint: \u0026#34;oss-cn-hangzhou.aliyuncs.com\u0026#34; access-key-id: ${{ secrets.ID }} access-key-secret: ${{ secrets.SECRET }} - name: Deploy To OSS # 将public下的页面拷贝至Bucket run: ossutil cp -rf ./public oss://kingtuo123/ 最后 git push 一下即可。\n全站加速配置 需要已备案的域名。\n再配置全站加速，域名管理 -\u0026gt; 添加域名 ，等待生成 CNAME 记录。\n最后在 DNS解析 中添加域名 CNAME 记录。\n","permalink":"https://kingtuo123.com/posts/hugo-deploy/","summary":"初始化 mkdir blog cd blog git init git remote add origin git@github.com:kingtuo123/kingtuo123.github.io.git echo resources/ \u0026gt;\u0026gt; .gitignore echo public/ \u0026gt;\u0026gt; .gitignore 添加主题\u0026amp;相关文件 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 拷贝主题SCSS文件至根目录 # 后面修改主题就改assets/scss下的文件，它比主题下的文件有更高的优先级 cp themes/hugo-theme-stack/assets/ . -r # 一些文章模板 cp themes/hugo-theme-stack/exampleSite/content/ . -r # 配置文件 cp themes/hugo-theme-stack/exampleSite/config.yaml . 修改config.yaml 按需修改，参考 配置主题\n配置GitHub Action mkdir -p .github/workflows/ touch .github/workflows/gh-pages.yml 编辑 gh-pages.yml，参考 peaceiris/actions-gh-pages name: github pages on: push: branches: - master paths-ignore: - \u0026#39;README.md\u0026#39; - \u0026#39;.","title":"Hugo deploy"}]