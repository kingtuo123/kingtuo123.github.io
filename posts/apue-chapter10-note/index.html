<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>APUE 第10章 信号 | Notes</title><meta name=keywords content="apue"><meta name=description content="apue 第10章 学习笔记"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/apue-chapter10-note/><link crossorigin=anonymous href=/assets/css/stylesheet.e3fd28a689eab557dc57ec445ca6884a24e47e2b11d97e7120aaf56a15d8c48b.css integrity="sha256-4/0oponqtVfcV+xEXKaISiTkfisR2X5xIKr1ahXYxIs=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="APUE 第10章 信号"><meta property="og:description" content="apue 第10章 学习笔记"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/apue-chapter10-note/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="APUE 第10章 信号"><meta name=twitter:description content="apue 第10章 学习笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"APUE 第10章 信号","item":"https://kingtuo123.com/posts/apue-chapter10-note/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"APUE 第10章 信号","name":"APUE 第10章 信号","description":"apue 第10章 学习笔记","keywords":["apue"],"articleBody":"10.1 引言 信号是软中断。信号提供了一种处理异步事件的方法。\n10.2 信号概念 信号名字都以3个字符 SIG 开头。\n在头文件 中，信号名都被定义为正整数常量（信号编号）。\n不存在编号为0的信号。\n信号的处理：\n忽略此信号。SIGKILL 和 SIGSTOP 不能被忽略，原因：它们向内核和超级用户提供了使进程终止或停止的可靠方法。 捕捉信号。不能捕捉 SIGKILL 和 SIGSTOP 信号。 执行系统默认动作。见图10-1 kill 命令默认发送 SIGTERM 终止信号。查看所有信号：\n$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM ... 使用 kill 命令给进程发送指定信号：\n$ kill -9 pid $ kill -SIGKILL pid 10.3 函数 signal #include typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); /* signal() returns the previous value of the signal handler. * On failure, it returns SIG_ERR, and errno is set to indicate the error. */ sighandler_t 是函数指针类型，该函数有一个 int 型的参数，返回值为空。\nsignum 参数是图10-1中的信号名。handler 的值是常量 SIG_IGN，SIG_DFL 或接受到此信号后要调用的函数的地址。\nsignal() 返回值类型和第二参数的类型都是 sighandler_t，若成功则返回上一个 handler，失败返回 SIG_ERR。\n可能会有以下形式的声明，大多数 UNIX 系统使用以下的值：\n#define SIG_ERR (void (*)())-1 #define SIG_DFL (void (*)())0 #define SIG_IGN (void (*)())1 以下是 signal 函数简单的示例：\n#include \"apue.h\" static void sig_usr(int); /* one handler for both signals */ int main(void) { if (signal(SIGUSR1, sig_usr) == SIG_ERR) err_sys(\"can't catch SIGUSR1\"); if (signal(SIGUSR2, sig_usr) == SIG_ERR) err_sys(\"can't catch SIGUSR2\"); for ( ; ; ) pause(); } static void sig_usr(int signo) /* argument is signal number */ { if (signo == SIGUSR1) printf(\"received SIGUSR1\\n\"); else if (signo == SIGUSR2) printf(\"received SIGUSR2\\n\"); else err_dump(\"received signal %d\\n\", signo); } $ ./a.out \u0026 [1] 27897 $ kill -SIGUSR1 27897 received SIGUSR1 $ kill -SIGUSR2 27897 received SIGUSR2 $ kill -SIGTERM 27897 [1]+ Terminated ./a.out 1. 程序启动\n当你在终端执行：\n$ cc main.c \u0026 shell 自动将进程 cc 对中断信号（SIGINT）和退出信号（SIGQUIT）的处理方式设置为忽略（SIG_IGN）。于是，当按下中断字符（ctrl+c）时就不会影响到后台进程。\n很多捕捉这两个信号的交互程序有以下形式的代码：\nvoid sig_int(void), sig_quit(void); if (signal(SIGINT, SIG_IGN) != SIG_IGN) signal(SIGINT,sig_int); if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) signal(SIGQUIT,sig_quit); 这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。\n2. 进程创建\n当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。\n10.4 不可靠信号 略\n10.5 中断的系统调用 早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。\n假设一个读操作被中断，我们希望重新启动它：\nagain: if ((n = read(fd, buf, BUFFSIZE)) \u003c 0) if (errno == EINTR) goto again; /* handle other errors*/ 为了帮助程序不必处理中断的系统调用，4.2BSD 引进了某些自动重启的系统调用 (ioctl, read, readv, write, writev, wait, waitpid)。\nPOSIX.1 要求只有中断信号的 SA_RESTART 标志有效时，实现才重启系统调用。sigaction 函数使用这个标志允许应用程序重启被中断的系统调用。\nFreeBSD8.0、Linux3.2.0、Mac OS X10.6.8中，当信号处理程序是用 signal 函数时，被中断的系统调用会重启动。\n10.6 可重入函数 信号是异步的，它会在程序的任何地方发生。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号 而插入执行该信号处理程序，其中又调用 malloc，这时可能会对进程造成破坏。\n可重入函数是在信号处理程序中保证调用安全的函数，被称为异步信号安全的（async-signal safe）。如图10-4\n在信号处理程序中调用一个非可重入函数，其结果是不可预知的。\n10.7 SIGCLD 语义 说说SIGCLD和SIGCHLD\n10.8 可靠信号术语和语义 略\n10.9 函数 kill 和 raise kill 函数将信号发送给进程或进程组。raise 函数则允许进程向自身发送信号。\n#include int kill(pid_t pid, int signo); int raise(int signo); raise(signo) 与 kill(getpid(), signo) 等价。\nkill 的 pid 参数有以下4种情况：\npid \u003e 0 : 将信号发送给进程 ID 为 pid 的进程 pid == 0 : 将信号发送给与发送进程属于同一进程组的所有进程 pid \u003c 0 : 将信号发送给进程组 id 为 pid 绝对值的所有进程 pid == -1 : 将信号发送给发送进程有权限向它们发送信号的所有进程 10.10 函数 alarm 和 pause #include // 返回值：0或以前设置的闹钟时间的余留秒数 unsigned int alarm(unsigned int seconds); // 返回值：-1，errno 设置为 EINTR int pause(void); 每个进程只能有一个闹钟时间，重复调用 alarm 会覆盖之前的闹钟时间，alarm(0) 会取消计时。闹钟时间到后会发送 SIGALRM 信号。\npause 函数使调用进程挂起直至捕捉到一个信号。且只有执行了一个信号处理程序并从其返回时，pause 才返回。\n10.11 信号集 信号集（signal set）：能表示多个信号的数据类型。POSIX.1 定义数据类型 sigset_t 以包含一个信号集。\n信号集处理函数：\n#include // 初始化由set指向的信号集，清除其中所有信号。 int sigemptyset(sigset_t *set); // 初始化由set指向的信号集，使其包括所有信号。 int sigfillset(sigset_t *set); // 添加一个信号至信号集。 int sigaddset(sigset_t *set, int signum); // 从信号集删除一个信号。 int sigdelset(sigset_t *set, int signum); // 测试信号是否属于信号集。 int sigismember(const sigset_t *set, int signum); 使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。\n10.12 函数 sigprocmask 每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。\n#include // 成功返回0，出错-1 int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oldset); 若 oldset 是非空指针，则 oldset 用于保存当前的信号屏蔽字。\n若 set 是非空指针，则参数 how 指示如何修改当前信号屏蔽字。\nhow 说明 SIG_BLOCK set 包含了希望阻塞的附加信号 SIG_UNBLOCK set 包含了希望解除阻塞的信号 SIG_SETMASK 该进程新的信号屏蔽是 set 指向的值 如果 set 是空指针，则不改变信号屏蔽字，how 的值也无意义。可以用 sigprocmask(0, NULL, \u0026oldset) \u003c 0 测试当前进程是否设置了屏蔽字。\n在调用 sigprocmask 后，如果有任何未决的（pending）、不再阻塞的信号，则在 sigprocmask 返回之前，会至少将其中之一递送给该进程。\n10.13 函数 sigpending 通过 set 参数返回未决的（未递送）信号集。\n#include // 成功返回0，出错-1 int sigpending(sigset_t *set); 如果程序阻塞期间产生多个同一信号，解除阻塞后信号只递交一次（类似位图的机制，只有0|1）。\n10.14 函数 sigaction sigaction 函数的功能是检查或修改与指定信号相关联的处理动作。\n#include // 成功返回0，出错-1 int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oldact); signo，信号编号。act，结构体指针，如下：\nstruct sigaction { // 信号处理函数的地址，SIG_IGN，SIG_DFL void (*sa_handler)(int); // 调用信号处理程序时，需要阻塞的信号 sigset_t sa_mask; // 信号处理选项，见下图 int sa_flags; // 一个替代的信号处理程序，需在 sa_flags 中启用 SA_SIGINFO void (*sa_sigaction)(int, siginfo_t *, void *); }; 通常，按下列方式调用信号处理程序：\nvoid handler(int signo); 但是，如果设置了 SA_SIGINFO 标志，那么按下列方式调用信号处理程序：\nvoid handler(int signo, siginfo_t *info, void *context); info 结构体指针包含了信号产生原因的有关信息。\ncontext 是无类型指针，可强制转换为　ucontext_t 结构类型，包含信号传递时进程上下文内容。\n10.15 函数 sigsetjmp 和 siglongjmp #include // 返回值：直接调用返回0；若从 siglongjmp 调用返回，则返回非0 （val）。 int sigsetjmp(sigjmp_buf env, int savemask); void siglongjmp(sigjmp_buf env, int val); 这两个函数类似 setjmp 和 longjmp，只多了一个 savemask 参数。若 savemask 非0，则调用 sigsetjmp 时会保存当前信号屏蔽字至 env，在调用 siglongjmp 后恢复保存的屏蔽字。\n当调用一个信号处理程序时，被捕捉到的信号会添加到信号屏蔽字中（执行信号处理程序时屏蔽该信号），返回时恢复原来的屏蔽字。相关：10.14 节 SA_NODEFER 选项\n10.16 函数 sigsuspend #include // 返回值：只返回-1，并设置 errno（通常是 EINTR） int sigsuspend(const sigset_t *sigmask); 调用时挂起进程，信号屏蔽字设置为 sigmask 指向的值，捕捉到信号后返回，并恢复调用前的屏蔽字。\n10.17 函数 abort 此函数将 SIGABRT 信号发送给调用进程，使程序异常终止。\n#include void abort(void); SIGABRT 信号默认动作是 终止+core\nSIGABRT 信号不能被忽略，即使用了信号屏蔽字。因为 abort 函数内部的实现已确保该信号不可被忽略和屏蔽。\nSIGABRT 信号如果被注册了一个信号处理函数例如 handler_abrt ，当调用 abort 函数，进程捕获到 SIGABRT 信号后，先执行 handler_abrt 函数，若 handler_abrt 没有终止自己，返回 abort 函数后，abort 函数内部将 SIGABRT 改为默认动作，然后重新发送 SIGABRT 信号，进程终止。\n10.18 函数 system system 在第8章有提到不再赘述，书中这里讲的是 system 函数 POSIX.1 的实现。\n10.19 函数 sleep、nanosleep 和 clock_nanosleep #include // 返回值：0 或 未休眠完的秒数 unsigned int sleep(unsigned int seconds); 注意：sleep 计时并不精准，会被信号处理程序打断(直接返回了)。\nnanosleep 提供了纳秒级的精度。clock_nanosleep 相对于特定时钟的延迟。\n#include // 返回值：若休眠到要求时间，返回0；若出错，返回-1 int nanosleep(const struct timespec *req, struct timespec *_Nullable rem); // 返回值：若休眠到要求时间，返回0；若出错，返回错误码 int clock_nanosleep(clockid_t clockid, int flags, const struct timespec *request, struct timespec *_Nullable remain); 10.20 函数 sigqueue 转自csdn：sigqueue 函数\n10.21 作业控制信号 POSIX.1 认为有以下6中信号与作业控制有关：\nSIGCHLD 子进程已停止或终止 SIGCONT 如果进程已停止，则使其继续运行 SIGSTOP 停止信号（不能被捕捉或忽略） SIGTSTP 交互式停止信号（Ctrl+z） SIGTTIN 后台进程组成员读控制终端 SIGTTOU 后台进程组成员写控制终端 ","wordCount":"778","inLanguage":"en","datePublished":"2023-05-06T00:00:00Z","dateModified":"2023-05-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/apue-chapter10-note/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>APUE 第10章 信号</h1><div class=post-meta><span title='2023-05-06 00:00:00 +0000 UTC'>May 6, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#101-%e5%bc%95%e8%a8%80 aria-label="10.1 引言">10.1 引言</a></li><li><a href=#102-%e4%bf%a1%e5%8f%b7%e6%a6%82%e5%bf%b5 aria-label="10.2 信号概念">10.2 信号概念</a></li><li><a href=#103-%e5%87%bd%e6%95%b0-signal aria-label="10.3 函数 signal">10.3 函数 signal</a></li><li><a href=#104-%e4%b8%8d%e5%8f%af%e9%9d%a0%e4%bf%a1%e5%8f%b7 aria-label="10.4 不可靠信号">10.4 不可靠信号</a></li><li><a href=#105-%e4%b8%ad%e6%96%ad%e7%9a%84%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label="10.5 中断的系统调用">10.5 中断的系统调用</a></li><li><a href=#106-%e5%8f%af%e9%87%8d%e5%85%a5%e5%87%bd%e6%95%b0 aria-label="10.6 可重入函数">10.6 可重入函数</a></li><li><a href=#107-sigcld-%e8%af%ad%e4%b9%89 aria-label="10.7 SIGCLD 语义">10.7 SIGCLD 语义</a></li><li><a href=#108-%e5%8f%af%e9%9d%a0%e4%bf%a1%e5%8f%b7%e6%9c%af%e8%af%ad%e5%92%8c%e8%af%ad%e4%b9%89 aria-label="10.8 可靠信号术语和语义">10.8 可靠信号术语和语义</a></li><li><a href=#109-%e5%87%bd%e6%95%b0-kill-%e5%92%8c-raise aria-label="10.9 函数 kill 和 raise">10.9 函数 kill 和 raise</a></li><li><a href=#1010-%e5%87%bd%e6%95%b0-alarm-%e5%92%8c-pause aria-label="10.10 函数 alarm 和 pause">10.10 函数 alarm 和 pause</a></li><li><a href=#1011-%e4%bf%a1%e5%8f%b7%e9%9b%86 aria-label="10.11 信号集">10.11 信号集</a></li><li><a href=#1012-%e5%87%bd%e6%95%b0-sigprocmask aria-label="10.12 函数 sigprocmask">10.12 函数 sigprocmask</a></li><li><a href=#1013-%e5%87%bd%e6%95%b0-sigpending aria-label="10.13 函数 sigpending">10.13 函数 sigpending</a></li><li><a href=#1014-%e5%87%bd%e6%95%b0-sigaction aria-label="10.14 函数 sigaction">10.14 函数 sigaction</a></li><li><a href=#1015-%e5%87%bd%e6%95%b0-sigsetjmp-%e5%92%8c-siglongjmp aria-label="10.15 函数 sigsetjmp 和 siglongjmp">10.15 函数 sigsetjmp 和 siglongjmp</a></li><li><a href=#1016-%e5%87%bd%e6%95%b0-sigsuspend aria-label="10.16 函数 sigsuspend">10.16 函数 sigsuspend</a></li><li><a href=#1017-%e5%87%bd%e6%95%b0-abort aria-label="10.17 函数 abort">10.17 函数 abort</a></li><li><a href=#1018-%e5%87%bd%e6%95%b0-system aria-label="10.18 函数 system">10.18 函数 system</a></li><li><a href=#1019-%e5%87%bd%e6%95%b0-sleepnanosleep-%e5%92%8c-clock_nanosleep aria-label="10.19 函数 sleep、nanosleep 和 clock_nanosleep">10.19 函数 sleep、nanosleep 和 clock_nanosleep</a></li><li><a href=#1020-%e5%87%bd%e6%95%b0-sigqueue aria-label="10.20 函数 sigqueue">10.20 函数 sigqueue</a></li><li><a href=#1021-%e4%bd%9c%e4%b8%9a%e6%8e%a7%e5%88%b6%e4%bf%a1%e5%8f%b7 aria-label="10.21 作业控制信号">10.21 作业控制信号</a></li></ul></div></details></div><div class=post-content><h2 id=101-引言>10.1 引言<a hidden class=anchor aria-hidden=true href=#101-引言>#</a></h2><p>信号是软中断。信号提供了一种处理异步事件的方法。</p><h2 id=102-信号概念>10.2 信号概念<a hidden class=anchor aria-hidden=true href=#102-信号概念>#</a></h2><ul><li><p>信号名字都以3个字符 <code>SIG</code> 开头。</p></li><li><p>在头文件 <code>&lt;signal.h></code> 中，信号名都被定义为<strong>正整数常量（信号编号）</strong>。</p></li><li><p>不存在编号为0的信号。</p></li><li><p>信号的处理：</p><ol><li>忽略此信号。SIGKILL 和 SIGSTOP 不能被忽略，原因：它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li><li>捕捉信号。不能捕捉 SIGKILL 和 SIGSTOP 信号。</li><li>执行系统默认动作。<a href=10-1.jpg>见图10-1</a></li></ol></li></ul><blockquote><p>kill 命令默认发送 SIGTERM 终止信号。查看所有信号：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -l
</span></span><span class=line><span class=cl> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
</span></span><span class=line><span class=cl> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
</span></span><span class=line><span class=cl>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>使用 kill 命令给进程发送指定信号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -9 pid
</span></span><span class=line><span class=cl>$ kill -SIGKILL pid
</span></span></code></pre></div><h2 id=103-函数-signal>10.3 函数 signal<a hidden class=anchor aria-hidden=true href=#103-函数-signal>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=kt>sighandler_t</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>sighandler_t</span> <span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=kt>sighandler_t</span> <span class=n>handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* signal() returns the previous value of the signal handler.  
</span></span></span><span class=line><span class=cl><span class=cm> * On failure, it returns SIG_ERR, and errno is set to indicate the error.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p>sighandler_t 是函数指针类型，该函数有一个 int 型的参数，返回值为空。</p><p>signum 参数是图10-1中的信号名。handler 的值是常量 SIG_IGN，SIG_DFL 或接受到此信号后要调用的函数的地址。</p><p>signal() 返回值类型和第二参数的类型都是 sighandler_t，若成功则返回上一个 handler，失败返回 SIG_ERR。</p><p><code>&lt;signal.h></code> 可能会有以下形式的声明，大多数 UNIX 系统使用以下的值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define SIG_ERR (void (*)())-1
</span></span></span><span class=line><span class=cl><span class=cp>#define SIG_DFL (void (*)())0
</span></span></span><span class=line><span class=cl><span class=cp>#define SIG_IGN (void (*)())1
</span></span></span></code></pre></div><p>以下是 signal 函数简单的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;apue.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>   <span class=cm>/* one handler for both signals */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGUSR1</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_sys</span><span class=p>(</span><span class=s>&#34;can&#39;t catch SIGUSR1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGUSR2</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_sys</span><span class=p>(</span><span class=s>&#34;can&#39;t catch SIGUSR2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=p>;</span> <span class=p>;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>  <span class=cm>/* argument is signal number */</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGUSR1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;received SIGUSR1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGUSR2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;received SIGUSR2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_dump</span><span class=p>(</span><span class=s>&#34;received signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ./a.out &amp;
</span></span><span class=line><span class=cl>[1] 27897
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGUSR1 27897
</span></span><span class=line><span class=cl>received SIGUSR1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGUSR2 27897
</span></span><span class=line><span class=cl>received SIGUSR2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGTERM 27897
</span></span><span class=line><span class=cl>[1]+  Terminated    ./a.out
</span></span></code></pre></div><p><strong>1. 程序启动</strong></p><p>当你在终端执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cc main.c &amp;
</span></span></code></pre></div><p>shell 自动将进程 cc 对中断信号（SIGINT）和退出信号（SIGQUIT）的处理方式设置为忽略（SIG_IGN）。于是，当按下中断字符（ctrl+c）时就不会影响到后台进程。</p><p>很多捕捉这两个信号的交互程序有以下形式的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sig_int</span><span class=p>(</span><span class=kt>void</span><span class=p>),</span> <span class=nf>sig_quit</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>SIG_IGN</span><span class=p>)</span> <span class=o>!=</span> <span class=n>SIG_IGN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span><span class=n>sig_int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span> <span class=n>SIG_IGN</span><span class=p>)</span> <span class=o>!=</span> <span class=n>SIG_IGN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span><span class=n>sig_quit</span><span class=p>);</span>
</span></span></code></pre></div><p>这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。</p><p><strong>2. 进程创建</strong></p><p>当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。</p><h2 id=104-不可靠信号>10.4 不可靠信号<a hidden class=anchor aria-hidden=true href=#104-不可靠信号>#</a></h2><p>略</p><h2 id=105-中断的系统调用>10.5 中断的系统调用<a hidden class=anchor aria-hidden=true href=#105-中断的系统调用>#</a></h2><p>早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。</p><p>假设一个读操作被中断，我们希望重新启动它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>again</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUFFSIZE</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>again</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* handle other errors*/</span>
</span></span></code></pre></div><p>为了帮助程序不必处理中断的系统调用，4.2BSD 引进了某些自动重启的系统调用 (ioctl, read, readv, write, writev, wait, waitpid)。</p><blockquote><p>POSIX.1 要求只有中断信号的 SA_RESTART 标志有效时，实现才重启系统调用。sigaction 函数使用这个标志允许应用程序重启被中断的系统调用。</p></blockquote><blockquote><p>FreeBSD8.0、Linux3.2.0、Mac OS X10.6.8中，当信号处理程序是用 signal 函数时，被中断的系统调用会重启动。</p></blockquote><h2 id=106-可重入函数>10.6 可重入函数<a hidden class=anchor aria-hidden=true href=#106-可重入函数>#</a></h2><p>信号是异步的，它会在程序的任何地方发生。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号
而插入执行该信号处理程序，其中又调用 malloc，这时可能会对进程造成破坏。</p><p>可重入函数是在信号处理程序中保证调用安全的函数，被称为<strong>异步信号安全的（async-signal safe）</strong>。<a href=10-4.jpg>如图10-4</a></p><blockquote><p><strong>在信号处理程序中调用一个非可重入函数，其结果是不可预知的。</strong></p></blockquote><h2 id=107-sigcld-语义>10.7 SIGCLD 语义<a hidden class=anchor aria-hidden=true href=#107-sigcld-语义>#</a></h2><p><a href=https://blog.csdn.net/csxiaoshui/article/details/120234865>说说SIGCLD和SIGCHLD</a></p><h2 id=108-可靠信号术语和语义>10.8 可靠信号术语和语义<a hidden class=anchor aria-hidden=true href=#108-可靠信号术语和语义>#</a></h2><p>略</p><h2 id=109-函数-kill-和-raise>10.9 函数 kill 和 raise<a hidden class=anchor aria-hidden=true href=#109-函数-kill-和-raise>#</a></h2><p>kill 函数将信号发送给进程或进程组。raise 函数则允许进程向自身发送信号。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>raise</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span></code></pre></div><p><code>raise(signo)</code> 与 <code>kill(getpid(), signo)</code> 等价。</p><p>kill 的 pid 参数有以下4种情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pid &gt;   0 : 将信号发送给进程 ID 为 pid 的进程
</span></span><span class=line><span class=cl>pid ==  0 : 将信号发送给与发送进程属于同一进程组的所有进程
</span></span><span class=line><span class=cl>pid &lt;   0 : 将信号发送给进程组 id 为 pid 绝对值的所有进程
</span></span><span class=line><span class=cl>pid == -1 : 将信号发送给发送进程有权限向它们发送信号的所有进程
</span></span></code></pre></div><h2 id=1010-函数-alarm-和-pause>10.10 函数 alarm 和 pause<a hidden class=anchor aria-hidden=true href=#1010-函数-alarm-和-pause>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 返回值：0或以前设置的闹钟时间的余留秒数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>alarm</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：-1，errno 设置为 EINTR
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>pause</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>每个进程只能有一个闹钟时间，重复调用 alarm 会覆盖之前的闹钟时间，alarm(0) 会取消计时。闹钟时间到后会发送 SIGALRM 信号。</p><p>pause 函数使调用进程挂起直至捕捉到一个信号。且只有执行了一个信号处理程序并从其返回时，pause 才返回。</p><h2 id=1011-信号集>10.11 信号集<a hidden class=anchor aria-hidden=true href=#1011-信号集>#</a></h2><p>信号集（signal set）：能表示多个信号的数据类型。POSIX.1 定义数据类型 <code>sigset_t</code> 以包含一个信号集。</p><p>信号集处理函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 初始化由set指向的信号集，清除其中所有信号。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigemptyset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 初始化由set指向的信号集，使其包括所有信号。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigfillset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 添加一个信号至信号集。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigaddset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 从信号集删除一个信号。 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigdelset</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 测试信号是否属于信号集。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigismember</span><span class=p>(</span><span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signum</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。</p></blockquote><h2 id=1012-函数-sigprocmask>10.12 函数 sigprocmask<a hidden class=anchor aria-hidden=true href=#1012-函数-sigprocmask>#</a></h2><p>每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 成功返回0，出错-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigprocmask</span><span class=p>(</span><span class=kt>int</span> <span class=n>how</span><span class=p>,</span> <span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>set</span><span class=p>,</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>oldset</span><span class=p>);</span>
</span></span></code></pre></div><p>若 oldset 是非空指针，则 oldset 用于保存当前的信号屏蔽字。</p><p>若 set 是非空指针，则参数 how 指示如何修改当前信号屏蔽字。</p><table><thead><tr><th style=text-align:left>how</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>SIG_BLOCK</td><td style=text-align:left>set 包含了希望阻塞的附加信号</td></tr><tr><td style=text-align:left>SIG_UNBLOCK</td><td style=text-align:left>set 包含了希望解除阻塞的信号</td></tr><tr><td style=text-align:left>SIG_SETMASK</td><td style=text-align:left>该进程新的信号屏蔽是 set 指向的值</td></tr></tbody></table><p>如果 set 是空指针，则不改变信号屏蔽字，how 的值也无意义。可以用 <code>sigprocmask(0, NULL, &oldset) &lt; 0</code> 测试当前进程是否设置了屏蔽字。</p><p>在调用 sigprocmask 后，如果有任何未决的（pending）、不再阻塞的信号，则在 sigprocmask 返回之前，会至少将其中之一递送给该进程。</p><h2 id=1013-函数-sigpending>10.13 函数 sigpending<a hidden class=anchor aria-hidden=true href=#1013-函数-sigpending>#</a></h2><p>通过 set 参数返回未决的（未递送）信号集。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 成功返回0，出错-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigpending</span><span class=p>(</span><span class=kt>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>如果程序阻塞期间产生多个同一信号，解除阻塞后信号只递交一次（类似位图的机制，只有0|1）。</p></blockquote><h2 id=1014-函数-sigaction>10.14 函数 sigaction<a hidden class=anchor aria-hidden=true href=#1014-函数-sigaction>#</a></h2><p>sigaction 函数的功能是检查或修改与指定信号相关联的处理动作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 成功返回0，出错-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigaction</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>act</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                               <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>oldact</span><span class=p>);</span>
</span></span></code></pre></div><p>signo，信号编号。act，结构体指针，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sigaction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 信号处理函数的地址，SIG_IGN，SIG_DFL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_handler</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用信号处理程序时，需要阻塞的信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>sigset_t</span> <span class=n>sa_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 信号处理选项，见下图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>sa_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 一个替代的信号处理程序，需在 sa_flags 中启用 SA_SIGINFO
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_sigaction</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>siginfo_t</span> <span class=o>*</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div align=center><img src=10-16.jpg style=max-height:600px></img></div><p>通常，按下列方式调用信号处理程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span></code></pre></div><p>但是，如果设置了 SA_SIGINFO 标志，那么按下列方式调用信号处理程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=kt>siginfo_t</span> <span class=o>*</span><span class=n>info</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>context</span><span class=p>);</span>
</span></span></code></pre></div><p>info 结构体指针包含了信号产生原因的有关信息。</p><p>context 是无类型指针，可强制转换为　ucontext_t 结构类型，包含信号传递时进程上下文内容。</p><h2 id=1015-函数-sigsetjmp-和-siglongjmp>10.15 函数 sigsetjmp 和 siglongjmp<a hidden class=anchor aria-hidden=true href=#1015-函数-sigsetjmp-和-siglongjmp>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;setjmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：直接调用返回0；若从 siglongjmp 调用返回，则返回非0 （val）。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigsetjmp</span><span class=p>(</span><span class=n>sigjmp_buf</span> <span class=n>env</span><span class=p>,</span> <span class=kt>int</span> <span class=n>savemask</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>siglongjmp</span><span class=p>(</span><span class=n>sigjmp_buf</span> <span class=n>env</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>);</span>
</span></span></code></pre></div><p>这两个函数类似 <code>setjmp</code> 和 <code>longjmp</code>，只多了一个 <code>savemask</code> 参数。若 <code>savemask</code> 非0，则调用 <code>sigsetjmp</code> 时会保存当前信号屏蔽字至 <code>env</code>，在调用 <code>siglongjmp</code> 后恢复保存的屏蔽字。</p><blockquote><p>当调用一个信号处理程序时，被捕捉到的信号会添加到信号屏蔽字中（执行信号处理程序时屏蔽该信号），返回时恢复原来的屏蔽字。相关：10.14 节 SA_NODEFER 选项</p></blockquote><h2 id=1016-函数-sigsuspend>10.16 函数 sigsuspend<a hidden class=anchor aria-hidden=true href=#1016-函数-sigsuspend>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：只返回-1，并设置 errno（通常是 EINTR）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigsuspend</span><span class=p>(</span><span class=k>const</span> <span class=kt>sigset_t</span> <span class=o>*</span><span class=n>sigmask</span><span class=p>);</span>
</span></span></code></pre></div><p>调用时挂起进程，信号屏蔽字设置为 sigmask 指向的值，捕捉到信号后返回，并恢复调用前的屏蔽字。</p><h2 id=1017-函数-abort>10.17 函数 abort<a hidden class=anchor aria-hidden=true href=#1017-函数-abort>#</a></h2><p>此函数将 SIGABRT 信号发送给调用进程，使程序异常终止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>abort</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>SIGABRT 信号默认动作是 <code>终止+core</code></p><p>SIGABRT 信号不能被忽略，即使用了信号屏蔽字。因为 abort 函数内部的实现已确保该信号不可被忽略和屏蔽。</p><p>SIGABRT 信号如果被注册了一个信号处理函数例如 handler_abrt ，当调用 abort 函数，进程捕获到 SIGABRT 信号后，先执行 handler_abrt 函数，若 handler_abrt 没有终止自己，返回 abort 函数后，abort 函数内部将 SIGABRT 改为默认动作，然后重新发送 SIGABRT 信号，进程终止。</p><h2 id=1018-函数-system>10.18 函数 system<a hidden class=anchor aria-hidden=true href=#1018-函数-system>#</a></h2><p>system 在第8章有提到不再赘述，书中这里讲的是 system 函数 POSIX.1 的实现。</p><h2 id=1019-函数-sleepnanosleep-和-clock_nanosleep>10.19 函数 sleep、nanosleep 和 clock_nanosleep<a hidden class=anchor aria-hidden=true href=#1019-函数-sleepnanosleep-和-clock_nanosleep>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 返回值：0 或 未休眠完的秒数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>);</span>
</span></span></code></pre></div><p>注意：sleep 计时并不精准，会被信号处理程序打断(直接返回了)。</p><p>nanosleep 提供了纳秒级的精度。clock_nanosleep 相对于特定时钟的延迟。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 返回值：若休眠到要求时间，返回0；若出错，返回-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>nanosleep</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>req</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>_Nullable</span> <span class=n>rem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：若休眠到要求时间，返回0；若出错，返回错误码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>clock_nanosleep</span><span class=p>(</span><span class=kt>clockid_t</span> <span class=n>clockid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>request</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>_Nullable</span> <span class=n>remain</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=1020-函数-sigqueue>10.20 函数 sigqueue<a hidden class=anchor aria-hidden=true href=#1020-函数-sigqueue>#</a></h2><p><a href=https://blog.csdn.net/Scroll_C/article/details/123671969>转自csdn：sigqueue 函数</a></p><h2 id=1021-作业控制信号>10.21 作业控制信号<a hidden class=anchor aria-hidden=true href=#1021-作业控制信号>#</a></h2><p>POSIX.1 认为有以下6中信号与作业控制有关：</p><ul><li>SIGCHLD 子进程已停止或终止</li><li>SIGCONT 如果进程已停止，则使其继续运行</li><li>SIGSTOP 停止信号（不能被捕捉或忽略）</li><li>SIGTSTP 交互式停止信号（Ctrl+z）</li><li>SIGTTIN 后台进程组成员读控制终端</li><li>SIGTTOU 后台进程组成员写控制终端</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/apue/>apue</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>