<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>APUE 第10章 信号 | Notes</title><meta name=keywords content="apue"><meta name=description content="apue 第10章 学习笔记"><meta name=author content="kingtuo123"><link rel=canonical href=https://kingtuo123.com/posts/apue-chapter10-note/><link crossorigin=anonymous href=/assets/css/stylesheet.1b5446f740bb6871915d4adc115699d5a22c24bc7fa8660e3bfbb6e025fb2c4d.css integrity="sha256-G1RG90C7aHGRXUrcEVaZ1aIsJLx/qGYOO/u24CX7LE0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="APUE 第10章 信号"><meta property="og:description" content="apue 第10章 学习笔记"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/apue-chapter10-note/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="APUE 第10章 信号"><meta name=twitter:description content="apue 第10章 学习笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"APUE 第10章 信号","item":"https://kingtuo123.com/posts/apue-chapter10-note/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"APUE 第10章 信号","name":"APUE 第10章 信号","description":"apue 第10章 学习笔记","keywords":["apue"],"articleBody":"10.1 引言 信号是软中断。信号提供了一种处理异步事件的方法。\n10.2 信号概念 信号名字都以3个字符 SIG 开头。\n在头文件 中，信号名都被定义为正整数常量（信号编号）。\n不存在编号为0的信号。\n信号的处理：\n忽略此信号。SIGKILL 和 SIGSTOP 不能被忽略，原因：它们向内核和超级用户提供了使进程终止或停止的可靠方法。 捕捉信号。不能捕捉 SIGKILL 和 SIGSTOP 信号。 执行系统默认动作。见图10-1 kill 命令默认发送 SIGTERM 终止信号。查看所有信号：\n$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM ... 使用 kill 命令给进程发送指定信号：\n$ kill -9 pid $ kill -SIGKILL pid 10.3 函数 signal #include typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); /* signal() returns the previous value of the signal handler. * On failure, it returns SIG_ERR, and errno is set to indicate the error. */ sighandler_t 是函数指针类型，该函数有一个 int 型的参数，返回值为空。\nsignum 参数是图10-1中的信号名。handler 的值是常量 SIG_IGN，SIG_DFL 或接受到此信号后要调用的函数的地址。\nsignal() 返回值类型和第二参数的类型都是 sighandler_t，若成功则返回上一个 handler，失败返回 SIG_ERR。\n可能会有以下形式的声明，大多数 UNIX 系统使用以下的值：\n#define SIG_ERR (void (*)())-1 #define SIG_DFL (void (*)())0 #define SIG_IGN (void (*)())1 以下是 signal 函数简单的示例：\n#include \"apue.h\" static void sig_usr(int); /* one handler for both signals */ int main(void) { if (signal(SIGUSR1, sig_usr) == SIG_ERR) err_sys(\"can't catch SIGUSR1\"); if (signal(SIGUSR2, sig_usr) == SIG_ERR) err_sys(\"can't catch SIGUSR2\"); for ( ; ; ) pause(); } static void sig_usr(int signo) /* argument is signal number */ { if (signo == SIGUSR1) printf(\"received SIGUSR1\\n\"); else if (signo == SIGUSR2) printf(\"received SIGUSR2\\n\"); else err_dump(\"received signal %d\\n\", signo); } $ ./a.out \u0026 [1] 27897 $ kill -SIGUSR1 27897 received SIGUSR1 $ kill -SIGUSR2 27897 received SIGUSR2 $ kill -SIGTERM 27897 [1]+ Terminated ./a.out 1. 程序启动\n当你在终端执行：\n$ cc main.c \u0026 shell 自动将进程 cc 对中断信号（SIGINT）和退出信号（SIGQUIT）的处理方式设置为忽略（SIG_IGN）。于是，当按下中断字符（ctrl+c）时就不会影响到后台进程。\n很多捕捉这两个信号的交互程序有以下形式的代码：\nvoid sig_int(void), sig_quit(void); if (signal(SIGINT, SIG_IGN) != SIG_IGN) signal(SIGINT,sig_int); if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) signal(SIGQUIT,sig_quit); 这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。\n2. 进程创建\n当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。\n10.4 不可靠信号 略\n10.5 中断的系统调用 早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。\n假设一个读操作被中断，我们希望重新启动它：\nagain: if ((n = read(fd, buf, BUFFSIZE)) \u003c 0) if (errno == EINTR) goto again; /* handle other errors*/ 为了帮助程序不必处理中断的系统调用，4.2BSD 引进了某些自动重启的系统调用 (ioctl, read, readv, write, writev, wait, waitpid)。\nPOSIX.1 要求只有中断信号的 SA_RESTART 标志有效时，实现才重启系统调用。sigaction 函数使用这个标志允许应用程序重启被中断的系统调用。\nFreeBSD8.0、Linux3.2.0、Mac OS X10.6.8中，当信号处理程序是用 signal 函数时，被中断的系统调用会重启动。\n10.6 可重入函数 信号是异步的，它会在程序的任何地方发生。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号 而插入执行该信号处理程序，其中又调用 malloc，这时可能会对进程造成破坏。\n可重入函数是在信号处理程序中保证调用安全的函数，被称为异步信号安全的（async-signal safe）。如图10-4\n在信号处理程序中调用一个非可重入函数，其结果是不可预知的。\n10.7 SIGCLD 语义 说说SIGCLD和SIGCHLD\n10.8 可靠信号术语和语义 略\n10.9 函数 kill 和 raise kill 函数将信号发送给进程或进程组。raise 函数则允许进程向自身发送信号。\n#include int kill(pid_t pid, int signo); int raise(int signo); raise(signo) 与 kill(getpid(), signo) 等价。\nkill 的 pid 参数有以下4种情况：\npid \u003e 0 : 将信号发送给进程 ID 为 pid 的进程 pid == 0 : 将信号发送给与发送进程属于同一进程组的所有进程 pid \u003c 0 : 将信号发送给进程组 id 为 pid 绝对值的所有进程 pid == -1 : 将信号发送给发送进程有权限向它们发送信号的所有进程 10.10 函数 alarm 和 pause #include // 返回值：0或以前设置的闹钟时间的余留秒数 unsigned int alarm(unsigned int seconds); // 返回值：-1，errno 设置为 EINTR int pause(void); 每个进程只能有一个闹钟时间，重复调用 alarm() 会覆盖之前的闹钟时间。闹钟时间到后会发送 SIGALRM 信号。\npause 函数使调用进程挂起直至捕捉到一个信号。且只有执行了一个信号处理程序并从其返回时，pause 才返回。\n10.11 信号集 ","wordCount":"423","inLanguage":"en","datePublished":"2023-05-06T00:00:00Z","dateModified":"2023-05-06T00:00:00Z","author":{"@type":"Person","name":"kingtuo123"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/apue-chapter10-note/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>APUE 第10章 信号</h1><div class=post-meta><span title='2023-05-06 00:00:00 +0000 UTC'>May 6, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#101-%e5%bc%95%e8%a8%80 aria-label="10.1 引言">10.1 引言</a></li><li><a href=#102-%e4%bf%a1%e5%8f%b7%e6%a6%82%e5%bf%b5 aria-label="10.2 信号概念">10.2 信号概念</a></li><li><a href=#103-%e5%87%bd%e6%95%b0-signal aria-label="10.3 函数 signal">10.3 函数 signal</a></li><li><a href=#104-%e4%b8%8d%e5%8f%af%e9%9d%a0%e4%bf%a1%e5%8f%b7 aria-label="10.4 不可靠信号">10.4 不可靠信号</a></li><li><a href=#105-%e4%b8%ad%e6%96%ad%e7%9a%84%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label="10.5 中断的系统调用">10.5 中断的系统调用</a></li><li><a href=#106-%e5%8f%af%e9%87%8d%e5%85%a5%e5%87%bd%e6%95%b0 aria-label="10.6 可重入函数">10.6 可重入函数</a></li><li><a href=#107-sigcld-%e8%af%ad%e4%b9%89 aria-label="10.7 SIGCLD 语义">10.7 SIGCLD 语义</a></li><li><a href=#108-%e5%8f%af%e9%9d%a0%e4%bf%a1%e5%8f%b7%e6%9c%af%e8%af%ad%e5%92%8c%e8%af%ad%e4%b9%89 aria-label="10.8 可靠信号术语和语义">10.8 可靠信号术语和语义</a></li><li><a href=#109-%e5%87%bd%e6%95%b0-kill-%e5%92%8c-raise aria-label="10.9 函数 kill 和 raise">10.9 函数 kill 和 raise</a></li><li><a href=#1010-%e5%87%bd%e6%95%b0-alarm-%e5%92%8c-pause aria-label="10.10 函数 alarm 和 pause">10.10 函数 alarm 和 pause</a></li><li><a href=#1011-%e4%bf%a1%e5%8f%b7%e9%9b%86 aria-label="10.11 信号集">10.11 信号集</a></li></ul></div></details></div><div class=post-content><h2 id=101-引言>10.1 引言<a hidden class=anchor aria-hidden=true href=#101-引言>#</a></h2><p>信号是软中断。信号提供了一种处理异步事件的方法。</p><h2 id=102-信号概念>10.2 信号概念<a hidden class=anchor aria-hidden=true href=#102-信号概念>#</a></h2><ul><li><p>信号名字都以3个字符 <code>SIG</code> 开头。</p></li><li><p>在头文件 <code>&lt;signal.h></code> 中，信号名都被定义为<strong>正整数常量（信号编号）</strong>。</p></li><li><p>不存在编号为0的信号。</p></li><li><p>信号的处理：</p><ol><li>忽略此信号。SIGKILL 和 SIGSTOP 不能被忽略，原因：它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li><li>捕捉信号。不能捕捉 SIGKILL 和 SIGSTOP 信号。</li><li>执行系统默认动作。<a href=10-1.jpg>见图10-1</a></li></ol></li></ul><blockquote><p>kill 命令默认发送 SIGTERM 终止信号。查看所有信号：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -l
</span></span><span class=line><span class=cl> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
</span></span><span class=line><span class=cl> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
</span></span><span class=line><span class=cl>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>使用 kill 命令给进程发送指定信号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -9 pid
</span></span><span class=line><span class=cl>$ kill -SIGKILL pid
</span></span></code></pre></div><h2 id=103-函数-signal>10.3 函数 signal<a hidden class=anchor aria-hidden=true href=#103-函数-signal>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=kt>sighandler_t</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>sighandler_t</span> <span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=kt>sighandler_t</span> <span class=n>handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* signal() returns the previous value of the signal handler.  
</span></span></span><span class=line><span class=cl><span class=cm> * On failure, it returns SIG_ERR, and errno is set to indicate the error.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p>sighandler_t 是函数指针类型，该函数有一个 int 型的参数，返回值为空。</p><p>signum 参数是图10-1中的信号名。handler 的值是常量 SIG_IGN，SIG_DFL 或接受到此信号后要调用的函数的地址。</p><p>signal() 返回值类型和第二参数的类型都是 sighandler_t，若成功则返回上一个 handler，失败返回 SIG_ERR。</p><p><code>&lt;signal.h></code> 可能会有以下形式的声明，大多数 UNIX 系统使用以下的值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define SIG_ERR (void (*)())-1
</span></span></span><span class=line><span class=cl><span class=cp>#define SIG_DFL (void (*)())0
</span></span></span><span class=line><span class=cl><span class=cp>#define SIG_IGN (void (*)())1
</span></span></span></code></pre></div><p>以下是 signal 函数简单的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;apue.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>   <span class=cm>/* one handler for both signals */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGUSR1</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_sys</span><span class=p>(</span><span class=s>&#34;can&#39;t catch SIGUSR1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGUSR2</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_sys</span><span class=p>(</span><span class=s>&#34;can&#39;t catch SIGUSR2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span> <span class=p>;</span> <span class=p>;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>  <span class=cm>/* argument is signal number */</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGUSR1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;received SIGUSR1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>signo</span> <span class=o>==</span> <span class=n>SIGUSR2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;received SIGUSR2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nf>err_dump</span><span class=p>(</span><span class=s>&#34;received signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ./a.out &amp;
</span></span><span class=line><span class=cl>[1] 27897
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGUSR1 27897
</span></span><span class=line><span class=cl>received SIGUSR1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGUSR2 27897
</span></span><span class=line><span class=cl>received SIGUSR2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ kill -SIGTERM 27897
</span></span><span class=line><span class=cl>[1]+  Terminated    ./a.out
</span></span></code></pre></div><p><strong>1. 程序启动</strong></p><p>当你在终端执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cc main.c &amp;
</span></span></code></pre></div><p>shell 自动将进程 cc 对中断信号（SIGINT）和退出信号（SIGQUIT）的处理方式设置为忽略（SIG_IGN）。于是，当按下中断字符（ctrl+c）时就不会影响到后台进程。</p><p>很多捕捉这两个信号的交互程序有以下形式的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sig_int</span><span class=p>(</span><span class=kt>void</span><span class=p>),</span> <span class=nf>sig_quit</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>SIG_IGN</span><span class=p>)</span> <span class=o>!=</span> <span class=n>SIG_IGN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span><span class=n>sig_int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span> <span class=n>SIG_IGN</span><span class=p>)</span> <span class=o>!=</span> <span class=n>SIG_IGN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGQUIT</span><span class=p>,</span><span class=n>sig_quit</span><span class=p>);</span>
</span></span></code></pre></div><p>这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。</p><p><strong>2. 进程创建</strong></p><p>当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。</p><h2 id=104-不可靠信号>10.4 不可靠信号<a hidden class=anchor aria-hidden=true href=#104-不可靠信号>#</a></h2><p>略</p><h2 id=105-中断的系统调用>10.5 中断的系统调用<a hidden class=anchor aria-hidden=true href=#105-中断的系统调用>#</a></h2><p>早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。</p><p>假设一个读操作被中断，我们希望重新启动它：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>again</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>n</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUFFSIZE</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINTR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>again</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* handle other errors*/</span>
</span></span></code></pre></div><p>为了帮助程序不必处理中断的系统调用，4.2BSD 引进了某些自动重启的系统调用 (ioctl, read, readv, write, writev, wait, waitpid)。</p><blockquote><p>POSIX.1 要求只有中断信号的 SA_RESTART 标志有效时，实现才重启系统调用。sigaction 函数使用这个标志允许应用程序重启被中断的系统调用。</p></blockquote><blockquote><p>FreeBSD8.0、Linux3.2.0、Mac OS X10.6.8中，当信号处理程序是用 signal 函数时，被中断的系统调用会重启动。</p></blockquote><h2 id=106-可重入函数>10.6 可重入函数<a hidden class=anchor aria-hidden=true href=#106-可重入函数>#</a></h2><p>信号是异步的，它会在程序的任何地方发生。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号
而插入执行该信号处理程序，其中又调用 malloc，这时可能会对进程造成破坏。</p><p>可重入函数是在信号处理程序中保证调用安全的函数，被称为<strong>异步信号安全的（async-signal safe）</strong>。<a href=10-4.jpg>如图10-4</a></p><blockquote><p><strong>在信号处理程序中调用一个非可重入函数，其结果是不可预知的。</strong></p></blockquote><h2 id=107-sigcld-语义>10.7 SIGCLD 语义<a hidden class=anchor aria-hidden=true href=#107-sigcld-语义>#</a></h2><p><a href=https://blog.csdn.net/csxiaoshui/article/details/120234865>说说SIGCLD和SIGCHLD</a></p><h2 id=108-可靠信号术语和语义>10.8 可靠信号术语和语义<a hidden class=anchor aria-hidden=true href=#108-可靠信号术语和语义>#</a></h2><p>略</p><h2 id=109-函数-kill-和-raise>10.9 函数 kill 和 raise<a hidden class=anchor aria-hidden=true href=#109-函数-kill-和-raise>#</a></h2><p>kill 函数将信号发送给进程或进程组。raise 函数则允许进程向自身发送信号。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>raise</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span></code></pre></div><p>raise(signo) 与 kill(getpid(), signo) 等价。</p><p>kill 的 pid 参数有以下4种情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pid &gt;   0 : 将信号发送给进程 ID 为 pid 的进程
</span></span><span class=line><span class=cl>pid ==  0 : 将信号发送给与发送进程属于同一进程组的所有进程
</span></span><span class=line><span class=cl>pid &lt;   0 : 将信号发送给进程组 id 为 pid 绝对值的所有进程
</span></span><span class=line><span class=cl>pid == -1 : 将信号发送给发送进程有权限向它们发送信号的所有进程
</span></span></code></pre></div><h2 id=1010-函数-alarm-和-pause>10.10 函数 alarm 和 pause<a hidden class=anchor aria-hidden=true href=#1010-函数-alarm-和-pause>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 返回值：0或以前设置的闹钟时间的余留秒数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>alarm</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回值：-1，errno 设置为 EINTR
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>pause</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span></code></pre></div><p>每个进程只能有一个闹钟时间，重复调用 alarm() 会覆盖之前的闹钟时间。闹钟时间到后会发送 SIGALRM 信号。</p><p>pause 函数使调用进程挂起直至捕捉到一个信号。且只有执行了一个信号处理程序并从其返回时，pause 才返回。</p><h2 id=1011-信号集>10.11 信号集<a hidden class=anchor aria-hidden=true href=#1011-信号集>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/apue/>apue</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号-1</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>