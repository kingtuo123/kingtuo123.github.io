<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Makefile基础 | Notes</title>
<meta name=keywords content="makefile"><meta name=description content="Makefile 的基本语法，规则及命令。"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/makefile-basic/><link crossorigin=anonymous href=/assets/css/stylesheet.e3fd28a689eab557dc57ec445ca6884a24e47e2b11d97e7120aaf56a15d8c48b.css integrity="sha256-4/0oponqtVfcV+xEXKaISiTkfisR2X5xIKr1ahXYxIs=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Makefile基础"><meta property="og:description" content="Makefile 的基本语法，规则及命令。"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/makefile-basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Makefile基础"><meta name=twitter:description content="Makefile 的基本语法，规则及命令。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"Makefile基础","item":"https://kingtuo123.com/posts/makefile-basic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Makefile基础","name":"Makefile基础","description":"Makefile 的基本语法，规则及命令。","keywords":["makefile"],"articleBody":" 翻译自 Makefile Tutorial，部分有增删或修改，仅供参考。\nMakefile 语法 makefile 由一组规则组成。如下所示：\ntargets: prerequisites command command command targets 是文件名，以空格分隔。通常一个规则只有一个目标。\ncommand 通常是用于生成 targets 的一系列步骤。以 Tab 开头。\nprerequisites 也是文件名，以空格分隔。这些文件也称为 依赖 ，需要在执行 command 之前存在。\n示例 下面的 makefile 由三个单独的规则组成。当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\nmake 以 blah 作为目标，所以它首先搜索这个目标。 blah 需要 blah.o ，make 会搜索 blah.o 。 blah.o 需要 blah.c ，make会搜索 blah.c 。 blah.c 不需要依赖，所以会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的C程序。 blah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \"int main() { return 0; }\" \u003e blah.c # 第一个运行 下面这个 makefile 有一个目标 some_file 。默认目标是第一个目标，所以将执行 some_file 下的 echo 命令。\nsome_file: echo \"This line will always print\" 下面这个 makefile 第一次运行会生成 some_file 。第二次运行由于 some_file 已存在，会提示 make: 'some_file' is up to date 。\nsome_file: echo \"This line will only print once\" touch some_file 下面这个 makefile 中 some_file 依赖 other_file 。当第一次执行 make ，默认目标是 some_file ，它首先会查找依赖文件 other_file ，只要依赖文件比目标文件 some_file 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。\nsome_file: other_file echo \"This will run second, because it depends on other_file\" touch some_file other_file: echo \"This will run first\" touch other_file 下面这个 makefile 始终会执行默认目标的命令，因为它的依赖始终无法满足。\nsome_file: other_file touch some_file other_file: echo \"nothing\" clean 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file 变量 变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。\n使用 $( ) 调用或 ${ }。\nobj = a.o b.o c.o test: $(obj) gcc -o test $(obj) 变量赋值一般有如下符号：\n符号 作用 = 变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。 := 变量赋值，与普通的编程语言中的赋值一样。 += 变量追加赋值 ?= 变量为空则给它赋值 = 与 := 的区别：\n# 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: echo $(one) echo $(two) := 允许你追加变量，但会导致死循环，如下。\none = hello # one gets defined as a simply expanded variable (:=) and thus can handle appending one := ${one} there all: echo $(one) ?= 仅设置尚未设置的变量\none = hello one ?= will not be set two ?= will be set all: echo $(one) # 打印 hello echo $(two) # 打印 will be set 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\n以下 makefile 使用 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 通配符 通配符 作用 * 匹配零或多个字符 % 匹配一个或多个字符 ? 匹配单个字符 * 和 % 在 makefile 中都是通配符，但它们的含义完全不同。\n* 会搜索你的文件系统来匹配文件名。个人建议调用 wildcard 函数来使用 * 。\n# 打印出当前路径下所有以.c结尾的文件的信息 print: $(wildcard *.c) ls -la $? 危险：不要在变量定义中使用 * 。\n危险：当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\nthing_wrong := *.o # 不要这样做，'*' 不会被展开，会被视作 \"*.o\" 字符串 thing_right := $(wildcard *.o) # 正确做法 all: one two three four # 这里会出错，因为 $(thing_wrong) 是字符串 \"*.o\" one: $(thing_wrong) # 如果没有文件以 \".o\" 结尾，匹配不到文件时也会被视作字符串 \"*.o\" two: *.o # 正确运行 three: $(thing_right) # 同规则 \"three\" four: $(wildcard *.o) 自动化变量 符号 描述 $@ 当前目标名 $^ 所有依赖名，去重 $\u003c 第一个依赖名 $+ 所有依赖名，不去重 $? 比目标新的依赖名 $* 目标中%匹配的部分 hey: one two # 输出 \"hey\" echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two 规则 隐式规则 隐式规则会让东西变得混乱，不推荐使用，但是要了解。\n编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的 隐式规则常用的几个变量：\nCC ：C 程序编译器，默认 cc 。 CXX ：C++ 程序编译器，默认 g++ 。 CFLAGS ：提供给 C 编译器的参数。 CXXFLAGS ：提供给 C++ 编译器的参数。 CPPFLAGS ：提供给 C 预处理器的参数。 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数。 下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \"int main() { return 0; }\" \u003e blah.c clean: rm -f blah* 静态模式规则 下面是语法：\ntargets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \"int main() { return 0; }\" \u003e all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \"int main() { return 0; }\" \u003e all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 函数搭配使用，如下\nobj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \"target: $@ prereq: $\u003c\" # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \"target: $@ prereq: $\u003c\" %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u003c -o $@ 模式规则在目标中包含一个 % 。这个 % 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 % 代表与目标中的 % 匹配的相同词干。\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # $@ 表示目标文件 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。\nall: blah blah:: echo \"hello\" blah:: echo \"hello again\" 命令 不打印命令 在命令前加 @ ，在运行时这条命令不会被打印出来。在 make 时加上 -s 参数有同样的效果。\nall: @echo \"This make line will not be printed\" echo \"But this will\" 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\ echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \"Hello from bash\" 错误处理 在运行 make 时添加 -k 参数（–keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （–ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n嵌套执行 make 要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。\n# 双引号中的内容等同于 # hello: # touch inside_file new_contents = \"hello:\\n\\ttouch inside_file\" all: mkdir -p subdir printf $(new_contents) | sed -e 's/^ //' \u003e subdir/makefile #去掉第一行的空格并写入subdir/makefile cd subdir \u0026\u0026 $(MAKE) clean: rm -rf subdir 使用 export 嵌套 使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：\nnew_contents = \"hello:\\n\\\\techo \\$$(cooly)\" all: mkdir -p subdir echo $(new_contents) | sed -e 's/^ //' \u003e subdir/makefile @echo \"---MAKEFILE CONTENTS---\" @cd subdir \u0026\u0026 cat makefile @echo \"---END MAKEFILE CONTENTS---\" cd subdir \u0026\u0026 $(MAKE) # 注意输出的信息，可以看到 export 全局声明起到了作用 cooly = \"The subdirectory can see me!\" export cooly # 取消全局: unexport cooly clean: rm -rf subdir 你也可以在 shell 中使用全局变量\none=this will only work locally export two=we can run subcommands with this all: @echo $(one) # $$ 的意思是使用真实的 $ 符号 # 即 echo $one，由于one未声明全局环境变量，所以这条打印为空 @echo $$one @echo $(two) @echo $$two 也可以使用 .EXPORT_ALL_VARIABLES 将所用的变量都声明为全局的。\n.EXPORT_ALL_VARIABLES: new_contents = \"hello:\\n\\techo \\$$(cooly)\" cooly = \"The subdirectory can see me!\" all: mkdir -p subdir echo $(new_contents) | sed -e 's/^ //' \u003e subdir/makefile @echo \"---MAKEFILE CONTENTS---\" @cd subdir \u0026\u0026 cat makefile @echo \"---END MAKEFILE CONTENTS---\" cd subdir \u0026\u0026 $(MAKE) clean: rm -rf subdir 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量。在这里，我们使用 make option_one=hi 运行 make\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: echo $(option_one) echo $(option_two) define函数定义 one = export blah=\"I was set!\"; echo $$blah define two export blah=set echo $$blah endef # One 和 two 是不一样的 all: @echo \"这条会打印 'I was set'\" @$(one) @echo \"这条不会打印 'I was set' 因为每条命令运行在不同的shell中\" @$(two) 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 if/else foo = ok all: ifeq ($(foo), ok) echo \"foo equals ok\" else echo \"nope\" endif 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格 all: ifeq ($(strip $(foo)),) echo \"foo is empty after being stripped\" endif ifeq ($(nullstring),) echo \"nullstring doesn't even have spaces\" endif 检查变量是否定义 bar = foo = $(bar) all: ifdef foo echo \"foo is defined\" endif ifdef bar echo \"but bar is not\" endif 命令行参数 $(MAKEFLAGS) bar = foo = $(bar) all: # 查找 \"-i\" 参数。 ifneq (,$(findstring i, $(MAKEFLAGS))) echo \"i was passed to MAKEFLAGS\" endif 函数 函数主要只是用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\n# 字符串替换，这里 totally 替换 not bar := ${subst not, totally, \"I am not superman\"} all: @echo $(bar) 如果要替换空格或逗号，请使用变量\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \"a,b,c\" @echo $(bar) 不要在第一个参数之后包含空格。这将被视为字符串的一部分。\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 后面有一个空格 all: # 输出是 \", a , b , c\"，注意空格 @echo $(bar) 字符串替换 $(patsubst pattern,replacement,text) 执行以下操作：\n使用 pattern 匹配 text 中的文件名，使用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 $(foreach var,list,text) ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\n这会在每个单词后附加一个感叹号：\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \"who! are! you!\" @echo $(bar) if 函数 if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 Make 支持创建基本函数。语法是 $(call variable,param,param)\n$(0) 是变量名，$(1) 、$(2) 等是参数。\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \"Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\" @echo $(call sweet_new_fn, go, tigers) shell 函数 这会调用 shell，但它用空格替换了换行符。\nall: # 非常难看，因为换行符不见了 @echo $(shell ls -la) 其他特性 应用外部makefile include 的语法是\ninclude filenames vpath 指令 语法 vpath ， 会匹配 中的文件名，多个目录使用 空格 或 冒号 分隔。\nvpath %.h ../headers ../other-directory some_binary: ../headers blah.h touch some_binary ../headers: mkdir ../headers blah.h: touch ../headers/blah.h clean: rm -rf ../headers rm -f some_binary .phony make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 标签 ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 make clean 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n.PHONY clean clean: rm -f *.o .delete_on_error 当规则执行失败，.delete_on_error 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise. SRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s') # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u003c -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u003c -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # Include the .d makefiles. The - at the front suppresses the errors of missing # Makefiles. Initially, all the .d files will be missing, and we don't want those # errors to show up. -include $(DEPS) ","wordCount":"1813","inLanguage":"en","datePublished":"2022-05-01T00:00:00Z","dateModified":"2022-05-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/makefile-basic/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Makefile基础</h1><div class=post-meta><span title='2022-05-01 00:00:00 +0000 UTC'>May 1, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#makefile-%e8%af%ad%e6%b3%95 aria-label="Makefile 语法">Makefile 语法</a></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li><li><a href=#%e5%8f%98%e9%87%8f aria-label=变量>变量</a></li><li><a href=#%e7%9b%ae%e6%a0%87 aria-label=目标>目标</a></li><li><a href=#%e9%80%9a%e9%85%8d%e7%ac%a6 aria-label=通配符>通配符</a></li><li><a href=#%e8%87%aa%e5%8a%a8%e5%8c%96%e5%8f%98%e9%87%8f aria-label=自动化变量>自动化变量</a></li><li><a href=#%e8%a7%84%e5%88%99 aria-label=规则>规则</a><ul><li><a href=#%e9%9a%90%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=隐式规则>隐式规则</a></li><li><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=静态模式规则>静态模式规则</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=模式规则>模式规则</a></li><li><a href=#%e5%8f%8c%e5%86%92%e5%8f%b7%e8%a7%84%e5%88%99 aria-label=双冒号规则>双冒号规则</a></li></ul></li><li><a href=#%e5%91%bd%e4%bb%a4 aria-label=命令>命令</a><ul><li><a href=#%e4%b8%8d%e6%89%93%e5%8d%b0%e5%91%bd%e4%bb%a4 aria-label=不打印命令>不打印命令</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c aria-label=命令执行>命令执行</a></li><li><a href=#%e9%bb%98%e8%ae%a4-shell aria-label="默认 shell">默认 shell</a></li><li><a href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86 aria-label=错误处理>错误处理</a></li><li><a href=#%e4%b8%ad%e6%96%ad-make aria-label="中断 make">中断 make</a></li><li><a href=#%e5%b5%8c%e5%a5%97%e6%89%a7%e8%a1%8c-make aria-label="嵌套执行 make">嵌套执行 make</a></li><li><a href=#%e4%bd%bf%e7%94%a8-export-%e5%b5%8c%e5%a5%97 aria-label="使用 export 嵌套">使用 export 嵌套</a></li><li><a href=#%e8%a6%86%e7%9b%96%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0 aria-label=覆盖命令行参数>覆盖命令行参数</a></li><li><a href=#define%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89 aria-label=define函数定义>define函数定义</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e7%9b%ae%e6%a0%87%e5%8f%98%e9%87%8f aria-label=指定目标变量>指定目标变量</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e6%a8%a1%e5%bc%8f%e5%8f%98%e9%87%8f aria-label=指定模式变量>指定模式变量</a></li></ul></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad aria-label=条件判断>条件判断</a><ul><li><a href=#ifelse aria-label=if/else>if/else</a></li><li><a href=#%e5%88%a4%e6%96%ad%e5%8f%98%e9%87%8f%e4%b8%ba%e7%a9%ba aria-label=判断变量为空>判断变量为空</a></li><li><a href=#%e6%a3%80%e6%9f%a5%e5%8f%98%e9%87%8f%e6%98%af%e5%90%a6%e5%ae%9a%e4%b9%89 aria-label=检查变量是否定义>检查变量是否定义</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0-makeflags aria-label="命令行参数 $(MAKEFLAGS)">命令行参数 $(MAKEFLAGS)</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9b%bf%e6%8d%a2 aria-label=字符串替换>字符串替换</a></li><li><a href=#foreach-%e5%87%bd%e6%95%b0 aria-label="foreach 函数">foreach 函数</a></li><li><a href=#if-%e5%87%bd%e6%95%b0 aria-label="if 函数">if 函数</a></li><li><a href=#call-%e5%87%bd%e6%95%b0 aria-label="call 函数">call 函数</a></li><li><a href=#shell-%e5%87%bd%e6%95%b0 aria-label="shell 函数">shell 函数</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7 aria-label=其他特性>其他特性</a><ul><li><a href=#%e5%ba%94%e7%94%a8%e5%a4%96%e9%83%a8makefile aria-label=应用外部makefile>应用外部makefile</a></li><li><a href=#vpath-%e6%8c%87%e4%bb%a4 aria-label="vpath 指令">vpath 指令</a></li><li><a href=#phony aria-label=.phony>.phony</a></li><li><a href=#delete_on_error aria-label=.delete_on_error>.delete_on_error</a></li></ul></li><li><a href=#makefile-%e6%a8%a1%e6%9d%bf aria-label="makefile 模板">makefile 模板</a></li></ul></div></details></div><div class=post-content><blockquote><p>翻译自 <a href=https://makefiletutorial.com/#getting-started>Makefile Tutorial</a>，部分有增删或修改，仅供参考。</p></blockquote><h2 id=makefile-语法>Makefile 语法<a hidden class=anchor aria-hidden=true href=#makefile-语法>#</a></h2><p>makefile 由一组规则组成。如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>targets</span><span class=o>:</span> <span class=n>prerequisites</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span></code></pre></div><ul><li><p>targets 是文件名，以空格分隔。通常一个规则只有一个目标。</p></li><li><p>command 通常是用于生成 targets 的一系列步骤。以 Tab 开头。</p></li><li><p>prerequisites 也是文件名，以空格分隔。这些文件也称为 <strong>依赖</strong> ，需要在执行 command 之前存在。</p></li></ul><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><p>下面的 makefile 由三个单独的规则组成。当你在终端执行 <code>make blah</code> ，会以下面步骤运行并生成 <code>blan</code> 文件：</p><ul><li>make 以 <code>blah</code> 作为目标，所以它首先搜索这个目标。</li><li><code>blah</code> 需要 <code>blah.o</code> ，make 会搜索 <code>blah.o</code> 。</li><li><code>blah.o</code> 需要 <code>blah.c</code> ，make会搜索 <code>blah.c</code> 。</li><li><code>blah.c</code> 不需要依赖，所以会执行 <code>echo</code> 命令，生成 <code>blah.c</code> 。</li><li><code>blah.o</code> 的依赖满足，会执行 <code>cc -c</code> 命令，生成 <code>blah.o</code> 。</li><li><code>blah</code> 的依赖满足，会执行 <code>cc</code> 命令，生成 <code>blah</code> 。</li><li><code>blah</code> 即编译好的C程序。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>blah</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>    cc blah.o -o blah <span class=c1># 第三个运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.o</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>    cc -c blah.c -o blah.o <span class=c1># 第二个运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; blah.c <span class=c1># 第一个运行</span>
</span></span></code></pre></div><p>下面这个 makefile 有一个目标 <code>some_file</code> 。默认目标是第一个目标，所以将执行 <code>some_file</code> 下的 <code>echo</code> 命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This line will always print&#34;</span>
</span></span></code></pre></div><p>下面这个 makefile 第一次运行会生成 <code>some_file</code> 。第二次运行由于 <code>some_file</code> 已存在，会提示 <code>make: 'some_file' is up to date</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This line will only print once&#34;</span>
</span></span><span class=line><span class=cl>    touch some_file
</span></span></code></pre></div><p>下面这个 makefile 中 <code>some_file</code> 依赖 <code>other_file</code> 。当第一次执行 <code>make</code> ，默认目标是 <code>some_file</code> ，它首先会查找依赖文件 <code>other_file</code> ，只要依赖文件比目标文件 <code>some_file</code> 新，它就会执行这个依赖文件的规则，最后在执行自身的规则。所以当第二次执行时，两条规则下的命令都不会被执行，因为目标文件已存在。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span> <span class=n>other_file</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This will run second, because it depends on other_file&#34;</span>
</span></span><span class=line><span class=cl>    touch some_file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other_file</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This will run first&#34;</span>
</span></span><span class=line><span class=cl>    touch other_file
</span></span></code></pre></div><p>下面这个 <code>makefile</code> 始终会执行默认目标的命令，因为它的依赖始终无法满足。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span> <span class=n>other_file</span>
</span></span><span class=line><span class=cl>    touch some_file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other_file</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;nothing&#34;</span>
</span></span></code></pre></div><p><code>clean</code> 常被用来清理一些生成的文件，但它在 make 中并不是一个特殊的词。（一般都是约定俗成的，大家习惯用 clean 清理文件）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    touch some_file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f some_file
</span></span></code></pre></div><h2 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h2><p>变量只是字符串。类似C语言中的宏定义，运行make的时候会自动替换。</p><p>使用 <code>$( )</code> 调用或 <code>${ }</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>obj = a.o b.o c.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>test: $(obj)
</span></span><span class=line><span class=cl>    gcc -o test $(obj)
</span></span></code></pre></div><p>变量赋值一般有如下符号：</p><table><thead><tr><th style=text-align:center>符号</th><th>作用</th></tr></thead><tbody><tr><td style=text-align:center>=</td><td>变量赋值，仅在使用命令时查找变量并替换，而不是在定义时查找替换。</td></tr><tr><td style=text-align:center>:=</td><td>变量赋值，与普通的编程语言中的赋值一样。</td></tr><tr><td style=text-align:center>+=</td><td>变量追加赋值</td></tr><tr><td style=text-align:center>?=</td><td>变量为空则给它赋值</td></tr></tbody></table><p><code>=</code> 与 <code>:=</code> 的区别：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 这条会在下面打印出 later
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>one</span> <span class=o>=</span> one <span class=si>${</span><span class=nv>later_variable</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=c># 这条不会打印出 later
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>two</span> <span class=o>:=</span> two <span class=si>${</span><span class=nv>later_variable</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>later_variable</span> <span class=o>=</span> later
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>two<span class=k>)</span>
</span></span></code></pre></div><p><code>:=</code> 允许你追加变量，但会导致死循环，如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>one</span> <span class=o>=</span> hello
</span></span><span class=line><span class=cl><span class=c># one gets defined as a simply expanded variable (:=) and thus can handle appending
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>one</span> <span class=o>:=</span> <span class=si>${</span><span class=nv>one</span><span class=si>}</span> there
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>one<span class=k>)</span>
</span></span></code></pre></div><p><code>?=</code> 仅设置尚未设置的变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>one</span> <span class=o>=</span> hello
</span></span><span class=line><span class=cl><span class=nv>one</span> <span class=o>?=</span> will not be <span class=nb>set</span>
</span></span><span class=line><span class=cl><span class=nv>two</span> <span class=o>?=</span> will be <span class=nb>set</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 打印 hello</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>two<span class=k>)</span> <span class=c1># 打印 will be set</span>
</span></span></code></pre></div><h2 id=目标>目标<a hidden class=anchor aria-hidden=true href=#目标>#</a></h2><p>makefile 以第一个规则的目标为默认目标，通常只有一个。</p><p>以下 makefile 使用 <code>all</code> 可以生成多个目标。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span> <span class=n>three</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl><span class=nf>three</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch three
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f one two three
</span></span></code></pre></div><h2 id=通配符>通配符<a hidden class=anchor aria-hidden=true href=#通配符>#</a></h2><table><thead><tr><th style=text-align:center>通配符</th><th>作用</th></tr></thead><tbody><tr><td style=text-align:center>*</td><td>匹配零或多个字符</td></tr><tr><td style=text-align:center>%</td><td>匹配一个或多个字符</td></tr><tr><td style=text-align:center>?</td><td>匹配单个字符</td></tr></tbody></table><p><code>*</code> 和 <code>%</code> 在 makefile 中都是通配符，但它们的含义完全不同。</p><p><code>*</code> 会搜索你的文件系统来匹配文件名。个人建议调用 <code>wildcard</code> 函数来使用 <code>*</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 打印出当前路径下所有以.c结尾的文件的信息
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>print</span><span class=o>:</span> <span class=k>$(</span><span class=nv>wildcard</span> *.<span class=nv>c</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    ls -la  <span class=nv>$?</span>
</span></span></code></pre></div><blockquote><p>危险：不要在变量定义中使用 <code>*</code> 。</p><p>危险：当 <code>*</code> 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 <code>wildcard</code> 函数。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>thing_wrong</span> <span class=o>:=</span> *.o <span class=c1># 不要这样做，&#39;*&#39; 不会被展开，会被视作 &#34;*.o&#34; 字符串</span>
</span></span><span class=line><span class=cl><span class=nv>thing_right</span> <span class=o>:=</span> <span class=k>$(</span>wildcard *.o<span class=k>)</span> <span class=c1># 正确做法</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span> <span class=n>three</span> <span class=n>four</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这里会出错，因为 $(thing_wrong) 是字符串 &#34;*.o&#34;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>one</span><span class=o>:</span> <span class=k>$(</span><span class=nv>thing_wrong</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 如果没有文件以 &#34;.o&#34; 结尾，匹配不到文件时也会被视作字符串 &#34;*.o&#34;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>two</span><span class=o>:</span> *.<span class=n>o</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 正确运行
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>three</span><span class=o>:</span> <span class=k>$(</span><span class=nv>thing_right</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 同规则 &#34;three&#34;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>four</span><span class=o>:</span> <span class=k>$(</span><span class=nv>wildcard</span> *.<span class=nv>o</span><span class=k>)</span>
</span></span></code></pre></div><h2 id=自动化变量>自动化变量<a hidden class=anchor aria-hidden=true href=#自动化变量>#</a></h2><table><thead><tr><th style=text-align:center>符号</th><th>描述</th></tr></thead><tbody><tr><td style=text-align:center>$@</td><td>当前目标名</td></tr><tr><td style=text-align:center>$^</td><td>所有依赖名，去重</td></tr><tr><td style=text-align:center>$&lt;</td><td>第一个依赖名</td></tr><tr><td style=text-align:center>$+</td><td>所有依赖名，不去重</td></tr><tr><td style=text-align:center>$?</td><td>比目标新的依赖名</td></tr><tr><td style=text-align:center>$*</td><td>目标中%匹配的部分</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>hey</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出 &#34;hey&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 输出比目标新的依赖名</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 输出所有依赖名</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> $^
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    touch hey
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f hey one two
</span></span></code></pre></div><h2 id=规则>规则<a hidden class=anchor aria-hidden=true href=#规则>#</a></h2><h3 id=隐式规则>隐式规则<a hidden class=anchor aria-hidden=true href=#隐式规则>#</a></h3><p>隐式规则会让东西变得混乱，不推荐使用，但是要了解。</p><ul><li>编译 C 程序： <code>n.o</code> 由 <code>n.c</code> 自动生成，命令形式为 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li><li>编译 C++ 程序：<code>n.o</code> 由 <code>n.cc</code> 或 <code>n.cpp</code> 自动生成，命令形式为 <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code></li><li>链接单个目标文件： <code>n</code> 是通过运行命令 <code>$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</code> 从 <code>n.o</code> 自动生成的</li></ul><p>隐式规则常用的几个变量：</p><ul><li><code>CC</code> ：C 程序编译器，默认 <code>cc</code> 。</li><li><code>CXX</code> ：C++ 程序编译器，默认 <code>g++</code> 。</li><li><code>CFLAGS</code> ：提供给 C 编译器的参数。</li><li><code>CXXFLAGS</code> ：提供给 C++ 编译器的参数。</li><li><code>CPPFLAGS</code> ：提供给 C 预处理器的参数。</li><li><code>LDFLAGS</code> ：当编译器调用链接器时提供给编译器的额外参数。</li></ul><p>下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>CC</span> <span class=o>=</span> gcc <span class=c1># 隐式规则的默认编译器</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>=</span> -g <span class=c1># 编译器参数，-g 启用调试信息</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的
</span></span></span><span class=line><span class=cl><span class=c># 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>blah</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; blah.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f blah*
</span></span></code></pre></div><h3 id=静态模式规则>静态模式规则<a hidden class=anchor aria-hidden=true href=#静态模式规则>#</a></h3><p>下面是语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>targets...</span><span class=o>:</span> <span class=n>target</span>-<span class=n>pattern</span>: <span class=n>prereq</span>-<span class=n>patterns</span> ...
</span></span><span class=line><span class=cl>    commands
</span></span></code></pre></div><p><code>target-pattern</code> 会匹配 <code>targets</code> 中的文件名（通过 % 通配符），如 <code>%.o</code> 匹配 <code>foo.o</code> ，匹配到的词干为 <code>foo</code> ，然后将 <code>foo</code> 替换进 <code>prereq-patterns</code> 的 <code>%</code> 中。</p><p>下面的例子是手动编写规则生成目标文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>objects</span> <span class=o>=</span> foo.o bar.o all.o
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这些目标文件通过隐式规则编译
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>foo.o</span><span class=o>:</span> <span class=n>foo</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl><span class=nf>bar.o</span><span class=o>:</span> <span class=n>bar</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl><span class=nf>all.o</span><span class=o>:</span> <span class=n>all</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; all.c
</span></span><span class=line><span class=cl><span class=c># %.c 会匹配 foo.c 和 bar.c ，没有则创建
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.c *.o all
</span></span></code></pre></div><p>下面的例子是通过静态模式规则生成目标文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>objects</span> <span class=o>=</span> foo.o bar.o all.o
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o
</span></span></span><span class=line><span class=cl><span class=c># 取出匹配到的词干 foo bar all
</span></span></span><span class=line><span class=cl><span class=c># 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(objects)</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; all.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.c *.o all
</span></span></code></pre></div><p>静态模式规则和 filter 函数搭配使用，如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>obj_files</span> <span class=o>=</span> foo.result bar.o lose.o
</span></span><span class=line><span class=cl><span class=nv>src_files</span> <span class=o>=</span> foo.raw bar.c lose.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>all</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>obj_files</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># filter 函数会匹配 obj_files 中的 bar.o lose.o
</span></span></span><span class=line><span class=cl><span class=c># bar.o lose.o 由静态模式规则替换成 bar.c lose.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(filter %.o,$(obj_files))</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;target: </span><span class=nv>$@</span><span class=s2> prereq: </span>$<span class=s2>&lt;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># filter 函数会匹配 obj_files 中的 foo.result
</span></span></span><span class=line><span class=cl><span class=c># foo.result 由静态模式规则替换成 foo.raw
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(filter %.result,$(obj_files))</span><span class=o>:</span> %.<span class=n>result</span>: %.<span class=n>raw</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;target: </span><span class=nv>$@</span><span class=s2> prereq: </span>$<span class=s2>&lt;&#34;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.c %.raw</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f <span class=k>$(</span>src_files<span class=k>)</span>
</span></span></code></pre></div><h3 id=模式规则>模式规则<a hidden class=anchor aria-hidden=true href=#模式规则>#</a></h3><p>先看一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 这个模式规则将每个 .c 文件编译为 .o 文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.o </span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> -c <span class=k>$(</span>CFLAGS<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span></code></pre></div><p>模式规则在目标中包含一个 <code>%</code> 。这个 <code>%</code> 匹配任何非空字符串，其他字符匹配它们自己。模式规则的先决条件中的 <code>%</code> 代表与目标中的 <code>%</code> 匹配的相同词干。</p><p>再看另一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 定义一个没有先决条件的模式规则
</span></span></span><span class=line><span class=cl><span class=c># $@ 表示目标文件
</span></span></span><span class=line><span class=cl><span class=c># 当需要时会创建一个空的 .c 文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span></code></pre></div><h3 id=双冒号规则>双冒号规则<a hidden class=anchor aria-hidden=true href=#双冒号规则>#</a></h3><p>双冒号规则很少使用，但允许为同一个目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>blah</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah</span><span class=o>::</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah</span><span class=o>::</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;hello again&#34;</span>
</span></span></code></pre></div><h2 id=命令>命令<a hidden class=anchor aria-hidden=true href=#命令>#</a></h2><h3 id=不打印命令>不打印命令<a hidden class=anchor aria-hidden=true href=#不打印命令>#</a></h3><p>在命令前加 <code>@</code> ，在运行时这条命令不会被打印出来。在 <code>make</code> 时加上 <code>-s</code> 参数有同样的效果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>all: 
</span></span><span class=line><span class=cl>    @echo &#34;This make line will not be printed&#34;
</span></span><span class=line><span class=cl>    echo &#34;But this will&#34;
</span></span></code></pre></div><h3 id=命令执行>命令执行<a hidden class=anchor aria-hidden=true href=#命令执行>#</a></h3><p>每个命令都在一个新的 shell 中运行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..
</span></span><span class=line><span class=cl>    <span class=c1># cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..<span class=p>;</span><span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 同上，这里使用 \ 换行</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span></code></pre></div><h3 id=默认-shell>默认 shell<a hidden class=anchor aria-hidden=true href=#默认-shell>#</a></h3><p>默认的 shell 是 <code>/bin/sh</code> ，你可以通过 <code>SHELL</code> 变量修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>SHELL</span><span class=o>=</span>/bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>cool</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Hello from bash&#34;</span>
</span></span></code></pre></div><h3 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h3><p>在运行 make 时添加 <code>-k</code> 参数（&ndash;keep-going）以在遇到错误时继续运行（错误信息会被打印）。</p><p>在运行 make 时添加 <code>-i</code> 参数 （&ndash;ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。</p><p>在命令前添加 <code>-</code> 以忽略错误 ，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 这条错误信息不会被打印，make会继续执行下去</span>
</span></span><span class=line><span class=cl>    -false
</span></span><span class=line><span class=cl>    touch one
</span></span></code></pre></div><h3 id=中断-make>中断 make<a hidden class=anchor aria-hidden=true href=#中断-make>#</a></h3><p>使用 <code>ctrl+c</code> ，它会中断 make 并删除新生成的目标文件。</p><h3 id=嵌套执行-make>嵌套执行 make<a hidden class=anchor aria-hidden=true href=#嵌套执行-make>#</a></h3><p>要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它可以传递 make 的参数并且本身不会受到它们的影响。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 双引号中的内容等同于
</span></span></span><span class=line><span class=cl><span class=c># hello: 
</span></span></span><span class=line><span class=cl><span class=c># 		touch inside_file
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>new_contents</span> <span class=o>=</span> <span class=s2>&#34;hello:\n\ttouch inside_file&#34;</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    mkdir -p subdir
</span></span><span class=line><span class=cl>    <span class=nb>printf</span> <span class=k>$(</span>new_contents<span class=k>)</span> <span class=p>|</span> sed -e <span class=s1>&#39;s/^ //&#39;</span> &gt; subdir/makefile <span class=c1>#去掉第一行的空格并写入subdir/makefile</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> subdir <span class=o>&amp;&amp;</span> <span class=k>$(</span>MAKE<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -rf subdir
</span></span></code></pre></div><h3 id=使用-export-嵌套>使用 export 嵌套<a hidden class=anchor aria-hidden=true href=#使用-export-嵌套>#</a></h3><p>使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>new_contents</span> <span class=o>=</span> <span class=s2>&#34;hello:\n\\techo \$</span><span class=k>$(</span>cooly<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    mkdir -p subdir
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>new_contents<span class=k>)</span> <span class=p>|</span> sed -e <span class=s1>&#39;s/^ //&#39;</span> &gt; subdir/makefile
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;---MAKEFILE CONTENTS---&#34;</span>
</span></span><span class=line><span class=cl>    @cd subdir <span class=o>&amp;&amp;</span> cat makefile
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;---END MAKEFILE CONTENTS---&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> subdir <span class=o>&amp;&amp;</span> <span class=k>$(</span>MAKE<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 注意输出的信息，可以看到 export 全局声明起到了作用
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>cooly</span> <span class=o>=</span> <span class=s2>&#34;The subdirectory can see me!&#34;</span>
</span></span><span class=line><span class=cl><span class=k>export</span> <span class=nv>cooly</span>
</span></span><span class=line><span class=cl><span class=c># 取消全局: unexport cooly
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -rf subdir
</span></span></code></pre></div><p>你也可以在 shell 中使用全局变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>one</span><span class=o>=</span>this will only work locally
</span></span><span class=line><span class=cl><span class=k>export </span><span class=nv>two</span><span class=o>=</span>we can run subcommands with this
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># $$ 的意思是使用真实的 $ 符号</span>
</span></span><span class=line><span class=cl>    <span class=c1># 即 echo $one，由于one未声明全局环境变量，所以这条打印为空</span>
</span></span><span class=line><span class=cl>    @echo <span class=nv>$$</span>one
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>two<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=nv>$$</span>two
</span></span></code></pre></div><p>也可以使用 <code>.EXPORT_ALL_VARIABLES</code> 将所用的变量都声明为全局的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.EXPORT_ALL_VARIABLES</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=nv>new_contents</span> <span class=o>=</span> <span class=s2>&#34;hello:\n\techo \$</span><span class=k>$(</span>cooly<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>cooly</span> <span class=o>=</span> <span class=s2>&#34;The subdirectory can see me!&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    mkdir -p subdir
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>new_contents<span class=k>)</span> <span class=p>|</span> sed -e <span class=s1>&#39;s/^ //&#39;</span> &gt; subdir/makefile
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;---MAKEFILE CONTENTS---&#34;</span>
</span></span><span class=line><span class=cl>    @cd subdir <span class=o>&amp;&amp;</span> cat makefile
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;---END MAKEFILE CONTENTS---&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> subdir <span class=o>&amp;&amp;</span> <span class=k>$(</span>MAKE<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -rf subdir
</span></span></code></pre></div><h3 id=覆盖命令行参数>覆盖命令行参数<a hidden class=anchor aria-hidden=true href=#覆盖命令行参数>#</a></h3><p>你可以使用 <code>override</code> 覆盖来自命令行的变量。在这里，我们使用 <code>make option_one=hi</code> 运行 <code>make</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 覆盖命令行参数
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>override</span> <span class=nv>option_one</span> <span class=o>=</span> did_override
</span></span><span class=line><span class=cl><span class=c># 不会覆盖
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>option_two</span> <span class=o>=</span> not_override
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>option_one<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>option_two<span class=k>)</span>
</span></span></code></pre></div><h3 id=define函数定义>define函数定义<a hidden class=anchor aria-hidden=true href=#define函数定义>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>one</span> <span class=o>=</span> <span class=nb>export</span> <span class=nv>blah</span><span class=o>=</span><span class=s2>&#34;I was set!&#34;</span><span class=p>;</span> <span class=nb>echo</span> <span class=nv>$$</span>blah
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>define</span> <span class=err>two</span>
</span></span><span class=line><span class=cl><span class=k>export </span><span class=nv>blah</span><span class=o>=</span><span class=nb>set</span>
</span></span><span class=line><span class=cl><span class=err>echo</span> <span class=k>$$</span><span class=err>blah</span>
</span></span><span class=line><span class=cl><span class=err>endef</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># One 和 two 是不一样的
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;这条会打印 &#39;I was set&#39;&#34;</span>
</span></span><span class=line><span class=cl>    @<span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;这条不会打印 &#39;I was set&#39; 因为每条命令运行在不同的shell中&#34;</span>
</span></span><span class=line><span class=cl>    @<span class=k>$(</span>two<span class=k>)</span>
</span></span></code></pre></div><h3 id=指定目标变量>指定目标变量<a hidden class=anchor aria-hidden=true href=#指定目标变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 给目标 all 指定 one 变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> = <span class=n>cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is defined: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 打印 cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is nothing: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 不会打印 cool</span>
</span></span></code></pre></div><h3 id=指定模式变量>指定模式变量<a hidden class=anchor aria-hidden=true href=#指定模式变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 给匹配 %.c 这个模式的规则指定 one 变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span> <span class=n>one</span> = <span class=n>cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is defined: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 打印 cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is nothing: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 不会打印 cool</span>
</span></span></code></pre></div><h2 id=条件判断>条件判断<a hidden class=anchor aria-hidden=true href=#条件判断>#</a></h2><h3 id=ifelse>if/else<a hidden class=anchor aria-hidden=true href=#ifelse>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> ok
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>foo</span><span class=k>)</span><span class=err>,</span> <span class=err>ok)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo equals ok&#34;</span>
</span></span><span class=line><span class=cl><span class=err>else</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;nope&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=判断变量为空>判断变量为空<a hidden class=anchor aria-hidden=true href=#判断变量为空>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>nullstring</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> <span class=k>$(</span>nullstring<span class=k>)</span> <span class=c1># 末尾有一个空格</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>strip</span> <span class=k>$(</span><span class=nv>foo</span><span class=k>))</span><span class=err>,)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo is empty after being stripped&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>nullstring</span><span class=k>)</span><span class=err>,)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;nullstring doesn&#39;t even have spaces&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=检查变量是否定义>检查变量是否定义<a hidden class=anchor aria-hidden=true href=#检查变量是否定义>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>bar</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> <span class=k>$(</span>bar<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifdef</span> <span class=err>foo</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo is defined&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=err>ifdef</span> <span class=err>bar</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;but bar is not&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=命令行参数-makeflags>命令行参数 $(MAKEFLAGS)<a hidden class=anchor aria-hidden=true href=#命令行参数-makeflags>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>bar</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> <span class=k>$(</span>bar<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=c># 查找 &#34;-i&#34; 参数。
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>ifneq</span> <span class=err>(,</span><span class=k>$(</span><span class=nv>findstring</span> <span class=nv>i</span>, <span class=k>$(</span><span class=nv>MAKEFLAGS</span><span class=k>))</span><span class=err>)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;i was passed to MAKEFLAGS&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><p>函数主要只是用于文本处理。使用 <code>$(fn, arguments)</code> 或 <code>${fn, arguments}</code> 调用函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 字符串替换，这里 totally 替换 not
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>bar</span> <span class=o>:=</span> <span class=si>${</span><span class=nv>subst</span><span class=p> not, totally, </span><span class=s2>&#34;I am not superman&#34;</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><p>如果要替换空格或逗号，请使用变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>comma</span> <span class=o>:=</span> ,
</span></span><span class=line><span class=cl><span class=nv>empty</span><span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>space</span> <span class=o>:=</span> <span class=k>$(</span>empty<span class=k>)</span> <span class=k>$(</span>empty<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a b c
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>subst <span class=k>$(</span>space<span class=k>)</span>,<span class=k>$(</span>comma<span class=k>)</span>,<span class=k>$(</span>foo<span class=k>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;a,b,c&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><p>不要在第一个参数之后包含空格。这将被视为字符串的一部分。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>comma</span> <span class=o>:=</span> ,
</span></span><span class=line><span class=cl><span class=nv>empty</span><span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>space</span> <span class=o>:=</span> <span class=k>$(</span>empty<span class=k>)</span> <span class=k>$(</span>empty<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a b c
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>subst <span class=k>$(</span>space<span class=k>)</span>, <span class=k>$(</span>comma<span class=k>)</span> , <span class=k>$(</span>foo<span class=k>))</span> <span class=c1># $(comma) 后面有一个空格</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;, a , b , c&#34;，注意空格</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=字符串替换>字符串替换<a hidden class=anchor aria-hidden=true href=#字符串替换>#</a></h3><p><code>$(patsubst pattern,replacement,text)</code> 执行以下操作：</p><p>使用 <code>pattern</code> 匹配 <code>text</code> 中的文件名，使用 <code>replacement</code> 进行替换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a.o b.o l.a c.o
</span></span><span class=line><span class=cl><span class=nv>one</span> <span class=o>:=</span> <span class=k>$(</span>patsubst %.o,%.c,<span class=k>$(</span>foo<span class=k>))</span>
</span></span><span class=line><span class=cl><span class=c># 这是上面的简写
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>two</span> <span class=o>:=</span> <span class=k>$(</span>foo:%.o<span class=o>=</span>%.c<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 这是仅有后缀的简写，也等价于上述
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>three</span> <span class=o>:=</span> <span class=k>$(</span>foo:.o<span class=o>=</span>.c<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 输出 a.c b.c l.a c.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>two<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>three<span class=k>)</span>
</span></span></code></pre></div><h3 id=foreach-函数>foreach 函数<a hidden class=anchor aria-hidden=true href=#foreach-函数>#</a></h3><p><code>$(foreach var,list,text)</code> ，它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。</p><p>这会在每个单词后附加一个感叹号：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> who are you
</span></span><span class=line><span class=cl><span class=c># 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>foreach wrd,<span class=k>$(</span>foo<span class=k>)</span>,<span class=k>$(</span>wrd<span class=k>)</span>!<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;who! are! you!&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=if-函数>if 函数<a hidden class=anchor aria-hidden=true href=#if-函数>#</a></h3><p><code>if</code> 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>this-is-not-empty</span> <span class=o>:=</span> hey
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> <span class=k>$(if</span> this-is-not-empty,yes,no<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>empty</span> <span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(if</span> <span class=k>$(</span>empty<span class=k>)</span>,yes,no<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 输出：yes
</span></span></span><span class=line><span class=cl><span class=c>#       no
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>foo<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=call-函数>call 函数<a hidden class=anchor aria-hidden=true href=#call-函数>#</a></h3><p>Make 支持创建基本函数。语法是 <code>$(call variable,param,param)</code></p><p><code>$(0)</code> 是变量名，<code>$(1)</code> 、<code>$(2)</code> 等是参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>sweet_new_fn</span> <span class=o>=</span> Variable Name: <span class=k>$(</span>0<span class=k>)</span> First: <span class=k>$(</span>1<span class=k>)</span> Second: <span class=k>$(</span>2<span class=k>)</span> Empty Variable: <span class=k>$(</span>3<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出 &#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>call sweet_new_fn, go, tigers<span class=k>)</span>
</span></span></code></pre></div><h3 id=shell-函数>shell 函数<a hidden class=anchor aria-hidden=true href=#shell-函数>#</a></h3><p>这会调用 shell，但它用空格替换了换行符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 非常难看，因为换行符不见了</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>shell ls -la<span class=k>)</span> 
</span></span></code></pre></div><h2 id=其他特性>其他特性<a hidden class=anchor aria-hidden=true href=#其他特性>#</a></h2><h3 id=应用外部makefile>应用外部makefile<a hidden class=anchor aria-hidden=true href=#应用外部makefile>#</a></h3><p><code>include</code> 的语法是</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=err>include</span> <span class=err>filenames</span>
</span></span></code></pre></div><h3 id=vpath-指令>vpath 指令<a hidden class=anchor aria-hidden=true href=#vpath-指令>#</a></h3><p>语法 <code>vpath &lt;pattern> &lt;directories></code> ，<code>&lt;pattern></code> 会匹配 <code>&lt;directories></code> 中的文件名，多个目录使用 <code>空格</code> 或 <code>冒号</code> 分隔。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>vpath %.h ../headers ../other-directory
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>some_binary: ../headers blah.h
</span></span><span class=line><span class=cl>    touch some_binary
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>../headers:
</span></span><span class=line><span class=cl>    mkdir ../headers
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>blah.h:
</span></span><span class=line><span class=cl>    touch ../headers/blah.h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>clean:
</span></span><span class=line><span class=cl>    rm -rf ../headers
</span></span><span class=line><span class=cl>    rm -f some_binary
</span></span></code></pre></div><h3 id=phony>.phony<a hidden class=anchor aria-hidden=true href=#phony>#</a></h3><p>make 并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个 <code>标签</code> ，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效（通过 <code>make clean</code> 命令）。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=err>.PHONY</span> <span class=err>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.o
</span></span></code></pre></div><h3 id=delete_on_error>.delete_on_error<a hidden class=anchor aria-hidden=true href=#delete_on_error>#</a></h3><p>当规则执行失败，<code>.delete_on_error</code> 会删除规则已生成的所有目标文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.DELETE_ON_ERROR</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl>    <span class=nb>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl>    <span class=nb>false</span>
</span></span></code></pre></div><h2 id=makefile-模板>makefile 模板<a hidden class=anchor aria-hidden=true href=#makefile-模板>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 感谢 Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)
</span></span></span><span class=line><span class=cl><span class=c># 最终要生成的目标文件名
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>TARGET_EXEC</span> <span class=o>:=</span> final_program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译生成文件的目录
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>BUILD_DIR</span> <span class=o>:=</span> ./build
</span></span><span class=line><span class=cl><span class=c># 源文件所在的目录
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>SRC_DIRS</span> <span class=o>:=</span> ./src
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 找到所有需要编译的 C 和 C++ 文件
</span></span></span><span class=line><span class=cl><span class=c># 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。
</span></span></span><span class=line><span class=cl><span class=c># Note the single quotes around the * expressions. Make will incorrectly expand these otherwise.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>SRCS</span> <span class=o>:=</span> <span class=k>$(</span>shell find <span class=k>$(</span>SRC_DIRS<span class=k>)</span> -name <span class=s1>&#39;*.cpp&#39;</span> -or -name <span class=s1>&#39;*.c&#39;</span> -or -name <span class=s1>&#39;*.s&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 给每个 C/C++ 文件名加 .o 结尾
</span></span></span><span class=line><span class=cl><span class=c># 如 hello.cpp 转换为 ./build/hello.cpp.o
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>OBJS</span> <span class=o>:=</span> <span class=k>$(</span>SRCS:%<span class=o>=</span><span class=k>$(</span>BUILD_DIR<span class=k>)</span>/%.o<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># .o 结尾替换为 .d
</span></span></span><span class=line><span class=cl><span class=c># 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>DEPS</span> <span class=o>:=</span> <span class=k>$(</span>OBJS:.o<span class=o>=</span>.d<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>INC_DIRS</span> <span class=o>:=</span> <span class=k>$(</span>shell find <span class=k>$(</span>SRC_DIRS<span class=k>)</span> -type d<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>INC_FLAGS</span> <span class=o>:=</span> <span class=k>$(</span>addprefix -I,<span class=k>$(</span>INC_DIRS<span class=k>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系
</span></span></span><span class=line><span class=cl><span class=c># 保存到 .d 结尾的文件中
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>CPPFLAGS</span> <span class=o>:=</span> <span class=k>$(</span>INC_FLAGS<span class=k>)</span> -MMD -MP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 最终的编译步骤
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/$(TARGET_EXEC)</span><span class=o>:</span> <span class=k>$(</span><span class=nv>OBJS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>OBJS<span class=k>)</span> -o <span class=nv>$@</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译C源码
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/%.c.o</span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    mkdir -p <span class=k>$(</span>dir <span class=nv>$@</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译C++源码
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/%.cpp.o</span><span class=o>:</span> %.<span class=n>cpp</span>
</span></span><span class=line><span class=cl>    mkdir -p <span class=k>$(</span>dir <span class=nv>$@</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CXX<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> <span class=k>$(</span>CXXFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -r <span class=k>$(</span>BUILD_DIR<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># Include the .d makefiles. The - at the front suppresses the errors of missing
</span></span></span><span class=line><span class=cl><span class=c># Makefiles. Initially, all the .d files will be missing, and we don&#39;t want those
</span></span></span><span class=line><span class=cl><span class=c># errors to show up.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>-include</span> <span class=k>$(</span><span class=nv>DEPS</span><span class=k>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/makefile/>makefile</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>