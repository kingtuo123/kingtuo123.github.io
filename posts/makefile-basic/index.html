<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Makefile 入门 | King's Blog</title>
<meta name=keywords content="makefile"><meta name=description content="Makefile 的基本语法，规则及命令。"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/makefile-basic/><link crossorigin=anonymous href=/assets/css/stylesheet.3fb4ecf6a2a81497f9b20e665e86d11433da1313db1d8c2d46c26dd61e1a1d3a.css integrity="sha256-P7Ts9qKoFJf5sg5mXobRFDPaExPbHYwtRsJt1h4aHTo=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kingtuo123.com/posts/makefile-basic/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Makefile 入门"><meta property="og:description" content="Makefile 的基本语法，规则及命令。"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/makefile-basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Makefile 入门"><meta name=twitter:description content="Makefile 的基本语法，规则及命令。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"Makefile 入门","item":"https://kingtuo123.com/posts/makefile-basic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Makefile 入门","name":"Makefile 入门","description":"Makefile 的基本语法，规则及命令。","keywords":["makefile"],"articleBody":"参考文章\nMakefile Tutorial GNU make 语法 makefile 由多个规则组成。规则语法如下：\ntargets: prerequisites command command command targets 目标文件，以空格分隔。通常一个规则只有一个目标。 command 通常是用于生成 targets 的一系列步骤。以 Tab 开头。 prerequisites 依赖文件（先决条件），以空格分隔。需要在执行 command 之前存在。 示例一 下面的 makefile 由三个单独的规则组成\nblah: blah.o cc blah.o -o blah # 第三个运行 blah.o: blah.c cc -c blah.c -o blah.o # 第二个运行 blah.c: echo \"int main() { return 0; }\" \u003e blah.c # 第一个运行 当你在终端执行 make blah ，会以下面步骤运行并生成 blan 文件：\nmake 以 blah 作为目标，所以它首先搜索这个目标。 blah 依赖 blah.o ，make 会搜索 blah.o 。 blah.o 依赖 blah.c ，make 会搜索 blah.c 。 blah.c 无需依赖，会执行 echo 命令，生成 blah.c 。 blah.o 的依赖满足，会执行 cc -c 命令，生成 blah.o 。 blah 的依赖满足，会执行 cc 命令，生成 blah 。 blah 即编译好的 C 程序。 make 的默认目标是规则中的第一个目标，所以直接执行 make 亦可：\n$ make echo \"int main() { return 0; }\" \u003e blah.c cc -c blah.c -o blah.o cc blah.o -o blah 重复执行 make 会提示 up to date：\n$ make make: 'blah' is up to date. 当依赖文件的时间戳新于目标文件，目标文件才会按规则重新生成：\n$ touch blah.o \u0026\u0026 make cc blah.o -o blah $ touch blah.c \u0026\u0026 make cc -c blah.c -o blah.o cc blah.o -o blah $ rm -f blah.c \u0026\u0026 make echo \"int main() { return 0; }\" \u003e blah.c cc -c blah.c -o blah.o cc blah.o -o blah 示例二 some_file: other_file echo \"This will always run, and runs second\" touch some_file # 这里 other_file 不会生成 other_file: echo \"This will always run, and runs first\" 上面这个 makefile 始终会执行 touch some_file，因为 some_file 的依赖始终无法满足。\n疑问：这里可以看出 make 成功执行规则后，不会检查此规则的目标文件是否存在。为何？\nMake clean clean 常用来清理文件，但它在 make 中并不是关键词。（一般都是约定俗成的，大家都习惯用 clean 清理文件）\nsome_file: touch some_file clean: rm -f some_file clean 不是规则中的第一个目标，所以需要显式调用 make clean。\n如果碰巧有一个名为 clean 的文件，这个目标将不会被执行，后文 .PHONY 一节会有说明。\n变量 变量是 字符串\n引用 使用 $( ) 或 ${ } 。\nobj = a.o b.o c.o test: $(obj) gcc -o test $(obj) 赋值 符号 作用 = 变量赋值，在执行时查找替换 := 变量赋值，在定义时查找替换 += 变量追加赋值 ?= 变量为空则给它赋值 = 与 := 的区别 # 这条会在下面打印出 later one = one ${later_variable} # 这条不会打印出 later two := two ${later_variable} later_variable = later all: @echo $(one) @echo $(two) $ make one later two 单个空格变量 行尾的空格不会被去掉，但行首的空格会被去掉。 要使用单个空格制作变量，请使用 $(nullstring)\nwith_spaces = hello # with_spaces在 \"hello\" 之后有很多空格 after = $(with_spaces)there nullstring = space = $(nullstring) # 这里末尾有一个空格，即单个空格变量。 all: echo \"$(after)\" echo start\"$(space)\"end $ make hello there start end 目标 makefile 以第一个规则的目标为默认目标，通常只有一个。\nall 目标 以下 makefile 通过 all 可以生成多个目标。\nall: one two three one: touch one two: touch two three: touch three clean: rm -f one two three 多目标 当一个规则有多个目标时，将为每个目标运行命令。\nall: f1.o f2.o f1.o f2.o: echo $@ 相当于：\nall: f1.o f2.o f1.o: echo f1.o f2.o: echo f2.o 通配符 符号 作用 * 匹配零或多个字符 % 匹配一个或多个字符 ? 匹配单个字符 * 一般搭配 wildcard 函数使用，用于搜索文件系统匹配文件名。\n% 一般在规则中使用作为词干，用于匹配规则中的字符串，不能用于搜索文件系统。\n注意：在变量定义中直接使用的通配符会被视为字符串\n* 通配符 在变量定义中使用 * ，如下（匹配 .o 文件）：\nthing_wrong := *.o # 错误做法，* 不会被展开，会被视作 *.o 字符串 thing_right := $(wildcard *.o) # 正确做法 在规则中使用 *，如下（打印 .c 文件）：\n# 方式一：不推荐的用法 print_wrong: *.c ls -la $? # 方式二：推荐使用 wildcard print_right: $(wildcard *.c) ls -la $? 注意：第一种方式中当 * 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 wildcard 函数。\n% 通配符 下面的 makefile 中 %.c 会匹配所有 .c 文件的规则，就不用给每个 .c 文件单独写一条规则。\nall: f1.c f2.c f3.c @echo \"done\" %.c: @echo $@ $ make f1.c f2.c f3.c done 自动化变量 更多自动化变量参考：Automatic Variables\n符号 描述 $@ 当前目标名 $^ 所有依赖名，去重 $\u003c 第一个依赖名 $+ 所有依赖名，不去重 $? 比目标新的依赖名 $* 目标中%匹配的部分 hey: one two # 输出 \"hey\" echo $@ # 输出比目标新的依赖名 echo $? # 输出所有依赖名 echo $^ touch hey one: touch one two: touch two clean: rm -f hey one two $ make -s hey one two one two $ make make: 'hey' is up to date. $ touch one \u0026\u0026 make -s hey one one two 规则 隐式规则 隐式规则会让事情变得混乱，不推荐使用，但是要了解：\n编译 C 程序： n.o 由 n.c 自动生成，命令形式为 $(CC) -c $(CPPFLAGS) $(CFLAGS) 编译 C++ 程序：n.o 由 n.cc 或 n.cpp 自动生成，命令形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) 链接单个目标文件： n 是通过运行命令 $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS) 从 n.o 自动生成的 隐式规则常用的几个变量：\nCC ：C 程序编译器，默认 cc CXX ：C++ 程序编译器，默认 g++ CFLAGS ：提供给 C 编译器的参数 CXXFLAGS ：提供给 C++ 编译器的参数 CPPFLAGS ：提供给 C 预处理器的参数 LDFLAGS ：当编译器调用链接器时提供给编译器的额外参数 下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序：\nCC = gcc # 隐式规则的默认编译器 CFLAGS = -g # 编译器参数，-g 启用调试信息 # 隐式规则 #1：blah 是通过 C 链接器隐式规则构建的 # 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在 blah: blah.o blah.c: echo \"int main() { return 0; }\" \u003e blah.c clean: rm -f blah* 静态模式规则 targets...: target-pattern: prereq-patterns ... commands target-pattern 会匹配 targets 中的文件名（通过 % 通配符），如 %.o 匹配 foo.o ，匹配到的词干为 foo ，然后将 foo 替换进 prereq-patterns 的 % 中。\n下面的例子是手动编写规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这些目标文件通过隐式规则编译 foo.o: foo.c bar.o: bar.c all.o: all.c all.c: echo \"int main() { return 0; }\" \u003e all.c # %.c 会匹配 foo.c 和 bar.c ，没有则创建 %.c: touch $@ clean: rm -f *.c *.o all 下面的例子是通过静态模式规则生成目标文件：\nobjects = foo.o bar.o all.o all: $(objects) # 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o # 取出匹配到的词干 foo bar all # 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c $(objects): %.o: %.c all.c: echo \"int main() { return 0; }\" \u003e all.c %.c: touch $@ clean: rm -f *.c *.o all 静态模式规则和 filter 过滤器 obj_files = foo.result bar.o lose.o src_files = foo.raw bar.c lose.c .PHONY: all all: $(obj_files) # filter 函数会匹配 obj_files 中的 bar.o lose.o # bar.o lose.o 由静态模式规则替换成 bar.c lose.c $(filter %.o,$(obj_files)): %.o: %.c echo \"target: $@ prereq: $\u003c\" # filter 函数会匹配 obj_files 中的 foo.result # foo.result 由静态模式规则替换成 foo.raw $(filter %.result,$(obj_files)): %.result: %.raw echo \"target: $@ prereq: $\u003c\" %.c %.raw: touch $@ clean: rm -f $(src_files) 模式规则 先看一个例子：\n# 这个模式规则将每个 .c 文件编译为 .o 文件 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $\u003c -o $@ 规则目标中的 % 匹配任何非空字符，匹配的字符称为 词干，上述例子中 %.o 与 %.c 拥有相同的词干\n再看另一个例子：\n# 定义一个没有先决条件的模式规则 # 当需要时会创建一个空的 .c 文件 %.c: touch $@ 双冒号规则 双冒号允许为同一个目标定义多个规则。如果是单冒号，则会打印一条警告，并且只会运行第二组规则。\nall: blah blah:: echo \"hello\" blah:: echo \"hello again\" 命令 命令回显/静默 在命令前加 @ ，在运行时这条命令不会被打印出来。make -s 有同样的效果。\nall: @echo \"This make line will not be printed\" echo \"But this will\" 命令执行 每个命令都在一个新的 shell 中运行。\nall: cd .. # cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的 echo `pwd` # 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔 cd ..;echo `pwd` # 同上，这里使用 \\ 换行 cd ..; \\ echo `pwd` 默认 shell 默认的 shell 是 /bin/sh ，你可以通过 SHELL 变量修改。\nSHELL=/bin/bash cool: echo \"Hello from bash\" 错误处理 在运行 make 时添加 -k 参数（--keep-going）以在遇到错误时继续运行（错误信息会被打印）。\n在运行 make 时添加 -i 参数 （--ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。\n在命令前添加 - 以忽略错误 ，如下：\none: # 这条错误信息不会被打印，make会继续执行下去 -false touch one 中断 make 使用 ctrl+c ，它会中断 make 并删除新生成的目标文件。\n递归 make 在子目录执行 make，要使用 $(MAKE) 而不是 make\nsubsystem: cd subdir \u0026\u0026 $(MAKE) 参考此文：How the MAKE Variable Works\nexport 全局变量 export 将变量声明为全局变量，这样子目录的 make 就可以引用该变量。unexport 取消全局：\ncooly = \"The subdirectory can see me!\" export cooly all: cd subdir \u0026\u0026 $(MAKE) 使用 $$ 可以在 shell 中引用全局变量：\nall: echo $$one $ export one=\"hello\" \u0026\u0026 make echo $one hello 使用 .EXPORT_ALL_VARIABLES 将所有的变量都声明为全局的：\n.EXPORT_ALL_VARIABLES: one = \"hello\" two = \"world\" 覆盖命令行参数 你可以使用 override 覆盖来自命令行的变量：\n# 覆盖命令行参数 override option_one = did_override # 不会覆盖 option_two = not_override all: @echo $(option_one) @echo $(option_two) $ make option_one=hi did_override not_override $ make option_two=hi did_override hi define 命令列表 define 开头，endef 结尾：\ndefine say echo \"hello\" echo \"word\" endef all: @$(say) $ make hello word 指定目标变量 # 给目标 all 指定 one 变量 all: one = cool all: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 指定模式变量 # 给匹配 %.c 这个模式的规则指定 one 变量 %.c: one = cool blah.c: echo one is defined: $(one) # 打印 cool other: echo one is nothing: $(one) # 不会打印 cool 条件判断 关键字 说明 ifeq 是否相等 ifneq 是否不相等 ifdef 是否定义 ifndef 是否未定义 都以 endif 结尾\nifeq 判断变量相等 foo = ok all: ifeq ($(foo), ok) echo \"foo equals ok\" else echo \"nope\" endif ifeq 判断变量为空 nullstring = foo = $(nullstring) # 末尾有一个空格，单空格变量 all: ifeq ($(strip $(foo)),) echo \"foo is empty after being stripped\" endif ifeq ($(nullstring),) echo \"nullstring doesn't even have spaces\" endif ifdef 检查变量是否定义 ifdef 不展开变量引用，它只查看是否定义了某些内容\nbar = foo = $(bar) all: ifdef foo echo \"foo is defined\" endif ifdef bar echo \"but bar is not\" endif $(MAKEFLAGS) 命令行参数 all: # 搜索 -i 标志。MAKEFLAGS 只是一个单一字符的列表，每个参数一个字符。 ifneq ($(findstring i, $(MAKEFLAGS)),) @echo $(MAKEFLAGS) @echo \"i was passed to MAKEFLAGS\" endif $ make -s -i is i was passed to MAKEFLAGS 函数 更多函数：Functions for Transforming Text\n函数主要用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。\nsubst 字符串替换 格式：$(subst str,replacement,text)\n使用 str 匹配 text 中的字符，再用 replacement 进行替换。\n# 字符串替换，这里 totally 替换 not bar := ${subst not, totally, \"I am not superman\"} all: @echo $(bar) 如果要替换空格或逗号，使用变量：\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space),$(comma),$(foo)) all: # 输出是 \"a,b,c\" @echo $(bar) 不要在第 2、3 个参数前后包含空格，这将被视为字符串的一部分：\ncomma := , empty:= space := $(empty) $(empty) foo := a b c bar := $(subst $(space), $(comma) , $(foo)) # $(comma) 和 $(foo) 前后有一个空格 all: # 输出是 \", a , b , c\" @echo $(bar) patsubst 字符串替换 格式：$(patsubst pattern,replacement,text)\n使用 pattern 匹配 text 中的字符，再用 replacement 进行替换。\nfoo := a.o b.o l.a c.o one := $(patsubst %.o,%.c,$(foo)) # 这是上面的简写 two := $(foo:%.o=%.c) # 这是仅有后缀的简写，也等价于上述 three := $(foo:.o=.c) # 输出都是 a.c b.c l.a c.c all: echo $(one) echo $(two) echo $(three) foreach 函数 格式：$(foreach var,list,text)\n它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。\nfoo := who are you # 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号 bar := $(foreach wrd,$(foo),$(wrd)!) all: # 输出是 \"who! are! you!\" @echo $(bar) if 函数 格式：$(if var,yes,no)\nif 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。\nthis-is-not-empty := hey foo := $(if this-is-not-empty,yes,no) empty := bar := $(if $(empty),yes,no) # 输出：yes # no all: @echo $(foo) @echo $(bar) call 函数 格式：$(call variable,param,param)\nMake 支持创建基本函数，使用 call 调用用户创建的函数：\n# $(0) 是变量名，$(1) 、$(2) ... 等是参数。 sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all: # 输出 \"Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\" @echo $(call sweet_new_fn, go, tigers) shell 函数 格式：$(shell command)\n调用 shell 执行 command，command 输出内容中的换行符会被替换为空格，不便阅读。\nall: @echo $(shell ls -la) 其他特性 include 包含外部 makefile include filename1 filename2 ... vpath 指令 make 默认搜索当前目录来匹配依赖文件（不包含子目录），vpath 用于添加匹配文件的搜索路径\n语法： vpath 会匹配 中的文件名，多个目录使用 空格 或 冒号 分隔。\n# 添加 .c 文件搜索路径 dir1 dir2 vpath %.c dir1 dir2 vpath %.c dir1:dir2 VPATH 变量 作用同上，用法如下：\n# 添加所有文件的搜索路径 dir1 dir2 VPATH := dir1 dir2 VPATH := dir1:dir2 .PHONY 伪目标 伪目标只是一个标签，表示 make 不会生成该规则的目标文件。伪目标的取名不能和文件重名。\n.PHONY: clean clean: rm -f *.o .DELETE_ON_ERROR 当规则执行失败，.DELETE_ON_ERROR 会删除规则已生成的所有目标文件。\n.DELETE_ON_ERROR: all: one two one: touch one false two: touch two false makefile 模板 # 最终要生成的目标文件名 TARGET_EXEC := final_program # 编译生成文件的目录 BUILD_DIR := ./build # 源文件所在的目录 SRC_DIRS := ./src # 找到所有需要编译的 C 和 C++ 文件 # 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。 SRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s') # 给每个 C/C++ 文件名加 .o 结尾 # 如 hello.cpp 转换为 ./build/hello.cpp.o OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) # .o 结尾替换为 .d # 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d DEPS := $(OBJS:.o=.d) # ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件 INC_DIRS := $(shell find $(SRC_DIRS) -type d) # 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA INC_FLAGS := $(addprefix -I,$(INC_DIRS)) # -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系 # 保存到 .d 结尾的文件中 CPPFLAGS := $(INC_FLAGS) -MMD -MP # 最终的编译步骤 $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # 编译C源码 $(BUILD_DIR)/%.c.o: %.c mkdir -p $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $\u003c -o $@ # 编译C++源码 $(BUILD_DIR)/%.cpp.o: %.cpp mkdir -p $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $\u003c -o $@ .PHONY: clean clean: rm -r $(BUILD_DIR) # 包含编译器生成的 .d 文件 -include $(DEPS) ","wordCount":"1771","inLanguage":"en","datePublished":"2022-05-01T00:00:00Z","dateModified":"2022-05-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/makefile-basic/"},"publisher":{"@type":"Organization","name":"King's Blog","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox=".5 1 15 15" fill="none" stroke="currentcolor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect height="3.5" width="12.5" y="2.75" x="1.75"/><path d="m6.75 9.25h2.5m-6.5-2.5v7.5h10.5v-7.5"/></svg></span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox=".5 .5 23 23" fill="none" stroke="currentcolor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg></span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="1 0 15 15" fill="none" stroke="currentcolor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round" transform="matrix(-1,0,0,1,0,0)"><polygon points="7.25 14.25,1.75 8.75,8.75 1.75,14.25 1.75,14.25 7.25"/><circle cx="11" cy="5" r=".5" fill="#000"/></svg></span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-4.4857-4.4935M19 10.5c0 4.6944-3.8056 8.5-8.5 8.5C5.80558 19 2 15.1944 2 10.5 2 5.80558 5.80558 2 10.5 2 15.1944 2 19 5.80558 19 10.5z"/></svg></span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Makefile 入门</h1><div class=post-meta><span title='2022-05-01 00:00:00 +0000 UTC'>May 1, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%af%ad%e6%b3%95 aria-label=语法>语法</a></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%b8%80 aria-label=示例一>示例一</a></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%ba%8c aria-label=示例二>示例二</a></li><li><a href=#make-clean aria-label="Make clean">Make clean</a></li><li><a href=#%e5%8f%98%e9%87%8f aria-label=变量>变量</a><ul><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li><li><a href=#%e8%b5%8b%e5%80%bc aria-label=赋值>赋值</a></li><li><a href=#-%e4%b8%8e--%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="= 与 := 的区别">= 与 := 的区别</a></li><li><a href=#%e5%8d%95%e4%b8%aa%e7%a9%ba%e6%a0%bc%e5%8f%98%e9%87%8f aria-label=单个空格变量>单个空格变量</a></li></ul></li><li><a href=#%e7%9b%ae%e6%a0%87 aria-label=目标>目标</a><ul><li><a href=#all-%e7%9b%ae%e6%a0%87 aria-label="all 目标">all 目标</a></li><li><a href=#%e5%a4%9a%e7%9b%ae%e6%a0%87 aria-label=多目标>多目标</a></li></ul></li><li><a href=#%e9%80%9a%e9%85%8d%e7%ac%a6 aria-label=通配符>通配符</a><ul><li><a href=#-%e9%80%9a%e9%85%8d%e7%ac%a6 aria-label="* 通配符">* 通配符</a></li><li><a href=#-%e9%80%9a%e9%85%8d%e7%ac%a6-1 aria-label="% 通配符">% 通配符</a></li></ul></li><li><a href=#%e8%87%aa%e5%8a%a8%e5%8c%96%e5%8f%98%e9%87%8f aria-label=自动化变量>自动化变量</a></li><li><a href=#%e8%a7%84%e5%88%99 aria-label=规则>规则</a><ul><li><a href=#%e9%9a%90%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=隐式规则>隐式规则</a></li><li><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=静态模式规则>静态模式规则</a></li><li><a href=#%e9%9d%99%e6%80%81%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99%e5%92%8c-filter-%e8%bf%87%e6%bb%a4%e5%99%a8 aria-label="静态模式规则和 filter 过滤器">静态模式规则和 filter 过滤器</a></li><li><a href=#%e6%a8%a1%e5%bc%8f%e8%a7%84%e5%88%99 aria-label=模式规则>模式规则</a></li><li><a href=#%e5%8f%8c%e5%86%92%e5%8f%b7%e8%a7%84%e5%88%99 aria-label=双冒号规则>双冒号规则</a></li></ul></li><li><a href=#%e5%91%bd%e4%bb%a4 aria-label=命令>命令</a><ul><li><a href=#%e5%91%bd%e4%bb%a4%e5%9b%9e%e6%98%be%e9%9d%99%e9%bb%98 aria-label=命令回显/静默>命令回显/静默</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c aria-label=命令执行>命令执行</a></li><li><a href=#%e9%bb%98%e8%ae%a4-shell aria-label="默认 shell">默认 shell</a></li><li><a href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86 aria-label=错误处理>错误处理</a></li><li><a href=#%e4%b8%ad%e6%96%ad-make aria-label="中断 make">中断 make</a></li><li><a href=#%e9%80%92%e5%bd%92-make aria-label="递归 make">递归 make</a></li><li><a href=#export-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f aria-label="export 全局变量">export 全局变量</a></li><li><a href=#%e8%a6%86%e7%9b%96%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0 aria-label=覆盖命令行参数>覆盖命令行参数</a></li><li><a href=#define-%e5%91%bd%e4%bb%a4%e5%88%97%e8%a1%a8 aria-label="define 命令列表">define 命令列表</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e7%9b%ae%e6%a0%87%e5%8f%98%e9%87%8f aria-label=指定目标变量>指定目标变量</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e6%a8%a1%e5%bc%8f%e5%8f%98%e9%87%8f aria-label=指定模式变量>指定模式变量</a></li></ul></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad aria-label=条件判断>条件判断</a><ul><li><a href=#ifeq-%e5%88%a4%e6%96%ad%e5%8f%98%e9%87%8f%e7%9b%b8%e7%ad%89 aria-label="ifeq 判断变量相等">ifeq 判断变量相等</a></li><li><a href=#ifeq-%e5%88%a4%e6%96%ad%e5%8f%98%e9%87%8f%e4%b8%ba%e7%a9%ba aria-label="ifeq 判断变量为空">ifeq 判断变量为空</a></li><li><a href=#ifdef-%e6%a3%80%e6%9f%a5%e5%8f%98%e9%87%8f%e6%98%af%e5%90%a6%e5%ae%9a%e4%b9%89 aria-label="ifdef 检查变量是否定义">ifdef 检查变量是否定义</a></li><li><a href=#makeflags-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0 aria-label="$(MAKEFLAGS) 命令行参数">$(MAKEFLAGS) 命令行参数</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><li><a href=#subst-%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9b%bf%e6%8d%a2 aria-label="subst 字符串替换">subst 字符串替换</a></li><li><a href=#patsubst-%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9b%bf%e6%8d%a2 aria-label="patsubst 字符串替换">patsubst 字符串替换</a></li><li><a href=#foreach-%e5%87%bd%e6%95%b0 aria-label="foreach 函数">foreach 函数</a></li><li><a href=#if-%e5%87%bd%e6%95%b0 aria-label="if 函数">if 函数</a></li><li><a href=#call-%e5%87%bd%e6%95%b0 aria-label="call 函数">call 函数</a></li><li><a href=#shell-%e5%87%bd%e6%95%b0 aria-label="shell 函数">shell 函数</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7 aria-label=其他特性>其他特性</a><ul><li><a href=#include-%e5%8c%85%e5%90%ab%e5%a4%96%e9%83%a8-makefile aria-label="include 包含外部 makefile">include 包含外部 makefile</a></li><li><a href=#vpath-%e6%8c%87%e4%bb%a4 aria-label="vpath 指令">vpath 指令</a></li><li><a href=#vpath-%e5%8f%98%e9%87%8f aria-label="VPATH 变量">VPATH 变量</a></li><li><a href=#phony-%e4%bc%aa%e7%9b%ae%e6%a0%87 aria-label=".PHONY 伪目标">.PHONY 伪目标</a></li><li><a href=#delete_on_error aria-label=.DELETE_ON_ERROR>.DELETE_ON_ERROR</a></li></ul></li><li><a href=#makefile-%e6%a8%a1%e6%9d%bf aria-label="makefile 模板">makefile 模板</a></li></ul></div></details></div><div class=post-content><p>参考文章</p><ul><li><a href=https://makefiletutorial.com/#getting-started>Makefile Tutorial</a></li><li><a href=https://www.gnu.org/savannah-checkouts/gnu/make/manual/html_node/>GNU make</a></li></ul><h2 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h2><p>makefile 由多个规则组成。规则语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>targets</span><span class=o>:</span> <span class=n>prerequisites</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span><span class=line><span class=cl>    <span class=nb>command</span>
</span></span></code></pre></div><ul><li><code>targets</code> 目标文件，以空格分隔。通常一个规则只有一个目标。</li><li><code>command</code> 通常是用于生成 targets 的一系列步骤。以 Tab 开头。</li><li><code>prerequisites</code> 依赖文件（先决条件），以空格分隔。需要在执行 command 之前存在。</li></ul><h2 id=示例一>示例一<a hidden class=anchor aria-hidden=true href=#示例一>#</a></h2><p>下面的 makefile 由三个单独的规则组成</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>blah</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>    cc blah.o -o blah <span class=c1># 第三个运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.o</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>    cc -c blah.c -o blah.o <span class=c1># 第二个运行</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; blah.c <span class=c1># 第一个运行</span>
</span></span></code></pre></div><p>当你在终端执行 <code>make blah</code> ，会以下面步骤运行并生成 <code>blan</code> 文件：</p><ul><li>make 以 <code>blah</code> 作为目标，所以它首先搜索这个目标。</li><li><code>blah</code> 依赖 <code>blah.o</code> ，make 会搜索 <code>blah.o</code> 。</li><li><code>blah.o</code> 依赖 <code>blah.c</code> ，make 会搜索 <code>blah.c</code> 。</li><li><code>blah.c</code> 无需依赖，会执行 <code>echo</code> 命令，生成 <code>blah.c</code> 。</li><li><code>blah.o</code> 的依赖满足，会执行 <code>cc -c</code> 命令，生成 <code>blah.o</code> 。</li><li><code>blah</code> 的依赖满足，会执行 <code>cc</code> 命令，生成 <code>blah</code> 。</li><li><code>blah</code> 即编译好的 C 程序。</li></ul><p>make 的默认目标是规则中的第一个目标，所以直接执行 <code>make</code> 亦可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>echo &#34;int main() { return 0; }&#34; &gt; blah.c 
</span></span></span><span class=line><span class=cl><span class=go>cc -c blah.c -o blah.o 
</span></span></span><span class=line><span class=cl><span class=go>cc blah.o -o blah 
</span></span></span></code></pre></div><p>重复执行 <code>make</code> 会提示 <code>up to date</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>make: &#39;blah&#39; is up to date.
</span></span></span></code></pre></div><p>当依赖文件的时间戳新于目标文件，目标文件才会按规则重新生成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> touch blah.o <span class=o>&amp;&amp;</span> make
</span></span><span class=line><span class=cl><span class=go>cc blah.o -o blah 
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=gp>$</span> touch blah.c <span class=o>&amp;&amp;</span> make
</span></span><span class=line><span class=cl><span class=go>cc -c blah.c -o blah.o 
</span></span></span><span class=line><span class=cl><span class=go>cc blah.o -o blah 
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=gp>$</span> rm -f blah.c <span class=o>&amp;&amp;</span> make
</span></span><span class=line><span class=cl><span class=go>echo &#34;int main() { return 0; }&#34; &gt; blah.c 
</span></span></span><span class=line><span class=cl><span class=go>cc -c blah.c -o blah.o 
</span></span></span><span class=line><span class=cl><span class=go>cc blah.o -o blah 
</span></span></span></code></pre></div><h2 id=示例二>示例二<a hidden class=anchor aria-hidden=true href=#示例二>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span> <span class=n>other_file</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This will always run, and runs second&#34;</span>
</span></span><span class=line><span class=cl>    touch some_file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这里 other_file 不会生成
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>other_file</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;This will always run, and runs first&#34;</span>
</span></span></code></pre></div><p>上面这个 makefile 始终会执行 <code>touch some_file</code>，因为 <code>some_file</code> 的依赖始终无法满足。</p><blockquote><p>疑问：这里可以看出 make 成功执行规则后，不会检查此规则的目标文件是否存在。为何？</p></blockquote><h2 id=make-clean>Make clean<a hidden class=anchor aria-hidden=true href=#make-clean>#</a></h2><p>clean 常用来清理文件，但它在 make 中并不是关键词。（一般都是约定俗成的，大家都习惯用 clean 清理文件）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>some_file</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    touch some_file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f some_file
</span></span></code></pre></div><ul><li><p>clean 不是规则中的第一个目标，所以需要显式调用 <code>make clean</code>。</p></li><li><p>如果碰巧有一个名为 clean 的文件，这个目标将不会被执行，后文 <code>.PHONY</code> 一节会有说明。</p></li></ul><h2 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h2><p>变量是 <strong>字符串</strong></p><h3 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h3><p>使用 <code>$( )</code> 或 <code>${ }</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>obj</span> <span class=o>=</span> a.o b.o c.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>test</span><span class=o>:</span> <span class=k>$(</span><span class=nv>obj</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    gcc -o <span class=nb>test</span> <span class=k>$(</span>obj<span class=k>)</span>
</span></span></code></pre></div><h3 id=赋值>赋值<a hidden class=anchor aria-hidden=true href=#赋值>#</a></h3><table><thead><tr><th style=text-align:center>符号</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:center>=</td><td style=text-align:left>变量赋值，在执行时查找替换</td></tr><tr><td style=text-align:center>:=</td><td style=text-align:left>变量赋值，在定义时查找替换</td></tr><tr><td style=text-align:center>+=</td><td style=text-align:left>变量追加赋值</td></tr><tr><td style=text-align:center>?=</td><td style=text-align:left>变量为空则给它赋值</td></tr></tbody></table><h3 id=-与--的区别>= 与 := 的区别<a hidden class=anchor aria-hidden=true href=#-与--的区别>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 这条会在下面打印出 later
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>one</span> <span class=o>=</span> one <span class=si>${</span><span class=nv>later_variable</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=c># 这条不会打印出 later
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>two</span> <span class=o>:=</span> two <span class=si>${</span><span class=nv>later_variable</span><span class=si>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>later_variable</span> <span class=o>=</span> later
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>two<span class=k>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>one later
</span></span></span><span class=line><span class=cl><span class=go>two
</span></span></span></code></pre></div><h3 id=单个空格变量>单个空格变量<a hidden class=anchor aria-hidden=true href=#单个空格变量>#</a></h3><p>行尾的空格不会被去掉，但行首的空格会被去掉。 要使用单个空格制作变量，请使用 <code>$(nullstring)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>with_spaces</span> <span class=o>=</span>     hello     <span class=c1># with_spaces在 &#34;hello&#34; 之后有很多空格</span>
</span></span><span class=line><span class=cl><span class=nv>after</span> <span class=o>=</span> <span class=k>$(</span>with_spaces<span class=k>)</span>there
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>nullstring</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>space</span> <span class=o>=</span> <span class=k>$(</span>nullstring<span class=k>)</span> <span class=c1># 这里末尾有一个空格，即单个空格变量。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;</span><span class=k>$(</span>after<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> start<span class=s2>&#34;</span><span class=k>$(</span>space<span class=k>)</span><span class=s2>&#34;</span>end
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>hello     there
</span></span></span><span class=line><span class=cl><span class=go>start end
</span></span></span></code></pre></div><h2 id=目标>目标<a hidden class=anchor aria-hidden=true href=#目标>#</a></h2><p>makefile 以第一个规则的目标为默认目标，通常只有一个。</p><h3 id=all-目标>all 目标<a hidden class=anchor aria-hidden=true href=#all-目标>#</a></h3><p>以下 makefile 通过 all 可以生成多个目标。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span> <span class=n>three</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl><span class=nf>three</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch three
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f one two three
</span></span></code></pre></div><h3 id=多目标>多目标<a hidden class=anchor aria-hidden=true href=#多目标>#</a></h3><p>当一个规则有多个目标时，将为每个目标运行命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>f</span>1.<span class=n>o</span> <span class=n>f</span>2.<span class=n>o</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>f1.o f2.o</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$@</span>
</span></span></code></pre></div><p>相当于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>f</span>1.<span class=n>o</span> <span class=n>f</span>2.<span class=n>o</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>f1.o</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> f1.o
</span></span><span class=line><span class=cl><span class=nf>f2.o</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> f2.o
</span></span></code></pre></div><h2 id=通配符>通配符<a hidden class=anchor aria-hidden=true href=#通配符>#</a></h2><table><thead><tr><th style=text-align:center>符号</th><th>作用</th></tr></thead><tbody><tr><td style=text-align:center>*</td><td>匹配零或多个字符</td></tr><tr><td style=text-align:center>%</td><td>匹配一个或多个字符</td></tr><tr><td style=text-align:center>?</td><td>匹配单个字符</td></tr></tbody></table><p><code>*</code> 一般搭配 <code>wildcard</code> 函数使用，用于搜索文件系统匹配文件名。</p><p><code>%</code> 一般在规则中使用作为词干，用于匹配规则中的字符串，不能用于搜索文件系统。</p><blockquote><p>注意：在变量定义中直接使用的通配符会被视为字符串</p></blockquote><h3 id=-通配符>* 通配符<a hidden class=anchor aria-hidden=true href=#-通配符>#</a></h3><p>在变量定义中使用 <code>*</code> ，如下（匹配 .o 文件）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>thing_wrong</span> <span class=o>:=</span> *.o             <span class=c1># 错误做法，* 不会被展开，会被视作 *.o 字符串</span>
</span></span><span class=line><span class=cl><span class=nv>thing_right</span> <span class=o>:=</span> <span class=k>$(</span>wildcard *.o<span class=k>)</span> <span class=c1># 正确做法</span>
</span></span></code></pre></div><p>在规则中使用 <code>*</code>，如下（打印 .c 文件）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 方式一：不推荐的用法
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>print_wrong</span><span class=o>:</span> *.<span class=n>c</span>
</span></span><span class=line><span class=cl>    ls -la  <span class=nv>$?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 方式二：推荐使用 wildcard
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>print_right</span><span class=o>:</span> <span class=k>$(</span><span class=nv>wildcard</span> *.<span class=nv>c</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    ls -la  <span class=nv>$?</span>
</span></span></code></pre></div><blockquote><p>注意：第一种方式中当 <code>*</code> 没有匹配到文件时，它会保持原样（作为一个字符串）除非使用 <code>wildcard</code> 函数。</p></blockquote><h3 id=-通配符-1>% 通配符<a hidden class=anchor aria-hidden=true href=#-通配符-1>#</a></h3><p>下面的 makefile 中 <code>%.c</code> 会匹配所有 <code>.c</code> 文件的规则，就不用给每个 <code>.c</code> 文件单独写一条规则。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>f</span>1.<span class=n>c</span> <span class=n>f</span>2.<span class=n>c</span> <span class=n>f</span>3.<span class=n>c</span>
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;done&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=nv>$@</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>f1.c
</span></span></span><span class=line><span class=cl><span class=go>f2.c
</span></span></span><span class=line><span class=cl><span class=go>f3.c
</span></span></span><span class=line><span class=cl><span class=go>done
</span></span></span></code></pre></div><h2 id=自动化变量>自动化变量<a hidden class=anchor aria-hidden=true href=#自动化变量>#</a></h2><blockquote><p>更多自动化变量参考：<a href=https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html>Automatic Variables</a></p></blockquote><table><thead><tr><th style=text-align:center>符号</th><th>描述</th></tr></thead><tbody><tr><td style=text-align:center>$@</td><td>当前目标名</td></tr><tr><td style=text-align:center>$^</td><td>所有依赖名，去重</td></tr><tr><td style=text-align:center>$&lt;</td><td>第一个依赖名</td></tr><tr><td style=text-align:center>$+</td><td>所有依赖名，不去重</td></tr><tr><td style=text-align:center>$?</td><td>比目标新的依赖名</td></tr><tr><td style=text-align:center>$*</td><td>目标中%匹配的部分</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>hey</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出 &#34;hey&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 输出比目标新的依赖名</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$?</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 输出所有依赖名</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> $^
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    touch hey
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f hey one two
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make -s
</span></span><span class=line><span class=cl><span class=go>hey
</span></span></span><span class=line><span class=cl><span class=go>one two
</span></span></span><span class=line><span class=cl><span class=go>one two
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>make: &#39;hey&#39; is up to date.
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> touch one <span class=o>&amp;&amp;</span> make -s
</span></span><span class=line><span class=cl><span class=go>hey
</span></span></span><span class=line><span class=cl><span class=go>one
</span></span></span><span class=line><span class=cl><span class=go>one two
</span></span></span></code></pre></div><h2 id=规则>规则<a hidden class=anchor aria-hidden=true href=#规则>#</a></h2><h3 id=隐式规则>隐式规则<a hidden class=anchor aria-hidden=true href=#隐式规则>#</a></h3><p>隐式规则会让事情变得混乱，不推荐使用，但是要了解：</p><ul><li>编译 C 程序： <code>n.o</code> 由 <code>n.c</code> 自动生成，命令形式为 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li><li>编译 C++ 程序：<code>n.o</code> 由 <code>n.cc</code> 或 <code>n.cpp</code> 自动生成，命令形式为 <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code></li><li>链接单个目标文件： <code>n</code> 是通过运行命令 <code>$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</code> 从 <code>n.o</code> 自动生成的</li></ul><p>隐式规则常用的几个变量：</p><ul><li><code>CC</code> ：C 程序编译器，默认 <code>cc</code></li><li><code>CXX</code> ：C++ 程序编译器，默认 <code>g++</code></li><li><code>CFLAGS</code> ：提供给 C 编译器的参数</li><li><code>CXXFLAGS</code> ：提供给 C++ 编译器的参数</li><li><code>CPPFLAGS</code> ：提供给 C 预处理器的参数</li><li><code>LDFLAGS</code> ：当编译器调用链接器时提供给编译器的额外参数</li></ul><p>下面这个例子无需明确告诉 Make 如何进行编译，就可以构建一个 C 程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>CC</span> <span class=o>=</span> gcc    <span class=c1># 隐式规则的默认编译器</span>
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>=</span> -g <span class=c1># 编译器参数，-g 启用调试信息</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 隐式规则 #1：blah   是通过 C 链接器隐式规则构建的
</span></span></span><span class=line><span class=cl><span class=c># 隐式规则 #2：blah.o 是通过 C 编译隐式规则构建的，因为 blah.c 存在
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>blah</span><span class=o>:</span> <span class=n>blah</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; blah.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f blah*
</span></span></code></pre></div><h3 id=静态模式规则>静态模式规则<a hidden class=anchor aria-hidden=true href=#静态模式规则>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>targets...</span><span class=o>:</span> <span class=n>target</span>-<span class=n>pattern</span>: <span class=n>prereq</span>-<span class=n>patterns</span> ...
</span></span><span class=line><span class=cl>    commands
</span></span></code></pre></div><p><code>target-pattern</code> 会匹配 <code>targets</code> 中的文件名（通过 % 通配符），如 <code>%.o</code> 匹配 <code>foo.o</code> ，匹配到的词干为 <code>foo</code> ，然后将 <code>foo</code> 替换进 <code>prereq-patterns</code> 的 <code>%</code> 中。</p><p>下面的例子是手动编写规则生成目标文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>objects</span> <span class=o>=</span> foo.o bar.o all.o
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这些目标文件通过隐式规则编译
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>foo.o</span><span class=o>:</span> <span class=n>foo</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl><span class=nf>bar.o</span><span class=o>:</span> <span class=n>bar</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl><span class=nf>all.o</span><span class=o>:</span> <span class=n>all</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; all.c
</span></span><span class=line><span class=cl><span class=c># %.c 会匹配 foo.c 和 bar.c ，没有则创建
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.c *.o all
</span></span></code></pre></div><p>下面的例子是通过静态模式规则生成目标文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>objects</span> <span class=o>=</span> foo.o bar.o all.o
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>objects</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 这个例子中，%.o 会匹配 targets 中的 foo.o bar.o all.o
</span></span></span><span class=line><span class=cl><span class=c># 取出匹配到的词干 foo bar all
</span></span></span><span class=line><span class=cl><span class=c># 将词干替换进 %.c 中的 % ，即 foo.c bar.c all.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(objects)</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;int main() { return 0; }&#34;</span> &gt; all.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.c *.o all
</span></span></code></pre></div><h3 id=静态模式规则和-filter-过滤器>静态模式规则和 filter 过滤器<a hidden class=anchor aria-hidden=true href=#静态模式规则和-filter-过滤器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>obj_files</span> <span class=o>=</span> foo.result bar.o lose.o
</span></span><span class=line><span class=cl><span class=nv>src_files</span> <span class=o>=</span> foo.raw bar.c lose.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>all</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>obj_files</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># filter 函数会匹配 obj_files 中的 bar.o lose.o
</span></span></span><span class=line><span class=cl><span class=c># bar.o lose.o 由静态模式规则替换成 bar.c lose.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(filter %.o,$(obj_files))</span><span class=o>:</span> %.<span class=n>o</span>: %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;target: </span><span class=nv>$@</span><span class=s2> prereq: </span>$<span class=s2>&lt;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># filter 函数会匹配 obj_files 中的 foo.result
</span></span></span><span class=line><span class=cl><span class=c># foo.result 由静态模式规则替换成 foo.raw
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(filter %.result,$(obj_files))</span><span class=o>:</span> %.<span class=n>result</span>: %.<span class=n>raw</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;target: </span><span class=nv>$@</span><span class=s2> prereq: </span>$<span class=s2>&lt;&#34;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.c %.raw</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f <span class=k>$(</span>src_files<span class=k>)</span>
</span></span></code></pre></div><h3 id=模式规则>模式规则<a hidden class=anchor aria-hidden=true href=#模式规则>#</a></h3><p>先看一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 这个模式规则将每个 .c 文件编译为 .o 文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.o </span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> -c <span class=k>$(</span>CFLAGS<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span></code></pre></div><p>规则目标中的 <code>%</code> 匹配任何非空字符，匹配的字符称为 <code>词干</code>，上述例子中 <code>%.o</code> 与 <code>%.c</code> 拥有相同的词干</p><p>再看另一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 定义一个没有先决条件的模式规则
</span></span></span><span class=line><span class=cl><span class=c># 当需要时会创建一个空的 .c 文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch <span class=nv>$@</span>
</span></span></code></pre></div><h3 id=双冒号规则>双冒号规则<a hidden class=anchor aria-hidden=true href=#双冒号规则>#</a></h3><p>双冒号允许为同一个目标定义多个规则。如果是单冒号，则会打印一条警告，并且只会运行第二组规则。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>blah</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah</span><span class=o>::</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah</span><span class=o>::</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;hello again&#34;</span>
</span></span></code></pre></div><h2 id=命令>命令<a hidden class=anchor aria-hidden=true href=#命令>#</a></h2><h3 id=命令回显静默>命令回显/静默<a hidden class=anchor aria-hidden=true href=#命令回显静默>#</a></h3><p>在命令前加 <code>@</code> ，在运行时这条命令不会被打印出来。<code>make -s</code> 有同样的效果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;This make line will not be printed&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;But this will&#34;</span>
</span></span></code></pre></div><h3 id=命令执行>命令执行<a hidden class=anchor aria-hidden=true href=#命令执行>#</a></h3><p>每个命令都在一个新的 shell 中运行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..
</span></span><span class=line><span class=cl>    <span class=c1># cd 命令不会影响下面这条命令，应为两条命令是在两个shell中运行的</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果你想要 cd 命令影响下一条命令，可以在同一行以 ; 间隔</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..<span class=p>;</span><span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 同上，这里使用 \ 换行</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> ..<span class=p>;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nb>echo</span> <span class=sb>`</span><span class=nb>pwd</span><span class=sb>`</span>
</span></span></code></pre></div><h3 id=默认-shell>默认 shell<a hidden class=anchor aria-hidden=true href=#默认-shell>#</a></h3><p>默认的 shell 是 <code>/bin/sh</code> ，你可以通过 <code>SHELL</code> 变量修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>SHELL</span><span class=o>=</span>/bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>cool</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Hello from bash&#34;</span>
</span></span></code></pre></div><h3 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h3><p>在运行 make 时添加 <code>-k</code> 参数（--keep-going）以在遇到错误时继续运行（错误信息会被打印）。</p><p>在运行 make 时添加 <code>-i</code> 参数 （--ignore-errors），执行过程中忽略规则命令执行的错误（错误信息不会被打印）。</p><p>在命令前添加 <code>-</code> 以忽略错误 ，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 这条错误信息不会被打印，make会继续执行下去</span>
</span></span><span class=line><span class=cl>    -false
</span></span><span class=line><span class=cl>    touch one
</span></span></code></pre></div><h3 id=中断-make>中断 make<a hidden class=anchor aria-hidden=true href=#中断-make>#</a></h3><p>使用 <code>ctrl+c</code> ，它会中断 make 并删除新生成的目标文件。</p><h3 id=递归-make>递归 make<a hidden class=anchor aria-hidden=true href=#递归-make>#</a></h3><p>在子目录执行 make，要使用 <code>$(MAKE)</code> 而不是 <code>make</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>subsystem</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> subdir <span class=o>&amp;&amp;</span> <span class=k>$(</span>MAKE<span class=k>)</span>
</span></span></code></pre></div><blockquote><p>参考此文：<a href=https://www.gnu.org/savannah-checkouts/gnu/make/manual/html_node/MAKE-Variable.html>How the MAKE Variable Works</a></p></blockquote><h3 id=export-全局变量>export 全局变量<a hidden class=anchor aria-hidden=true href=#export-全局变量>#</a></h3><p><code>export</code> 将变量声明为全局变量，这样子目录的 <code>make</code> 就可以引用该变量。<code>unexport</code> 取消全局：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>cooly</span> <span class=o>=</span> <span class=s2>&#34;The subdirectory can see me!&#34;</span>
</span></span><span class=line><span class=cl><span class=k>export</span> <span class=nv>cooly</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>cd</span> subdir <span class=o>&amp;&amp;</span> <span class=k>$(</span>MAKE<span class=k>)</span>
</span></span></code></pre></div><p>使用 <code>$$</code> 可以在 shell 中引用全局变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$$</span>one
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> <span class=nb>export</span> <span class=nv>one</span><span class=o>=</span><span class=s2>&#34;hello&#34;</span> <span class=o>&amp;&amp;</span> make
</span></span><span class=line><span class=cl><span class=go>echo $one
</span></span></span><span class=line><span class=cl><span class=go>hello
</span></span></span></code></pre></div><p>使用 <code>.EXPORT_ALL_VARIABLES</code> 将所有的变量都声明为全局的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.EXPORT_ALL_VARIABLES</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=nv>one</span> <span class=o>=</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>two</span> <span class=o>=</span> <span class=s2>&#34;world&#34;</span>
</span></span></code></pre></div><h3 id=覆盖命令行参数>覆盖命令行参数<a hidden class=anchor aria-hidden=true href=#覆盖命令行参数>#</a></h3><p>你可以使用 <code>override</code> 覆盖来自命令行的变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 覆盖命令行参数
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>override</span> <span class=nv>option_one</span> <span class=o>=</span> did_override
</span></span><span class=line><span class=cl><span class=c># 不会覆盖
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>option_two</span> <span class=o>=</span> not_override
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>option_one<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>option_two<span class=k>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make <span class=nv>option_one</span><span class=o>=</span>hi
</span></span><span class=line><span class=cl><span class=go>did_override
</span></span></span><span class=line><span class=cl><span class=go>not_override
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> make <span class=nv>option_two</span><span class=o>=</span>hi
</span></span><span class=line><span class=cl><span class=go>did_override
</span></span></span><span class=line><span class=cl><span class=go>hi
</span></span></span></code></pre></div><h3 id=define-命令列表>define 命令列表<a hidden class=anchor aria-hidden=true href=#define-命令列表>#</a></h3><p><code>define</code> 开头，<code>endef</code> 结尾：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=err>define</span> <span class=err>say</span>
</span></span><span class=line><span class=cl><span class=err>echo</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl><span class=err>echo</span> <span class=s2>&#34;word&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endef</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @<span class=k>$(</span>say<span class=k>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>hello
</span></span></span><span class=line><span class=cl><span class=go>word
</span></span></span></code></pre></div><h3 id=指定目标变量>指定目标变量<a hidden class=anchor aria-hidden=true href=#指定目标变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 给目标 all 指定 one 变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> = <span class=n>cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is defined: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 打印 cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is nothing: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 不会打印 cool</span>
</span></span></code></pre></div><h3 id=指定模式变量>指定模式变量<a hidden class=anchor aria-hidden=true href=#指定模式变量>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 给匹配 %.c 这个模式的规则指定 one 变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>%.c</span><span class=o>:</span> <span class=n>one</span> = <span class=n>cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>blah.c</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is defined: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 打印 cool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>other</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> one is nothing: <span class=k>$(</span>one<span class=k>)</span> <span class=c1># 不会打印 cool</span>
</span></span></code></pre></div><h2 id=条件判断>条件判断<a hidden class=anchor aria-hidden=true href=#条件判断>#</a></h2><table><thead><tr><th style=text-align:center>关键字</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:center>ifeq</td><td style=text-align:left>是否相等</td></tr><tr><td style=text-align:center>ifneq</td><td style=text-align:left>是否不相等</td></tr><tr><td style=text-align:center>ifdef</td><td style=text-align:left>是否定义</td></tr><tr><td style=text-align:center>ifndef</td><td style=text-align:left>是否未定义</td></tr></tbody></table><p>都以 <code>endif</code> 结尾</p><h3 id=ifeq-判断变量相等>ifeq 判断变量相等<a hidden class=anchor aria-hidden=true href=#ifeq-判断变量相等>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> ok
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>foo</span><span class=k>)</span><span class=err>,</span> <span class=err>ok)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo equals ok&#34;</span>
</span></span><span class=line><span class=cl><span class=err>else</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;nope&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=ifeq-判断变量为空>ifeq 判断变量为空<a hidden class=anchor aria-hidden=true href=#ifeq-判断变量为空>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>nullstring</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> <span class=k>$(</span>nullstring<span class=k>)</span> <span class=c1># 末尾有一个空格，单空格变量</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>strip</span> <span class=k>$(</span><span class=nv>foo</span><span class=k>))</span><span class=err>,)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo is empty after being stripped&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=err>ifeq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>nullstring</span><span class=k>)</span><span class=err>,)</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;nullstring doesn&#39;t even have spaces&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=ifdef-检查变量是否定义>ifdef 检查变量是否定义<a hidden class=anchor aria-hidden=true href=#ifdef-检查变量是否定义>#</a></h3><p>ifdef 不展开变量引用，它只查看是否定义了某些内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>bar</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>=</span> <span class=k>$(</span>bar<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=err>ifdef</span> <span class=err>foo</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;foo is defined&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span><span class=line><span class=cl><span class=err>ifdef</span> <span class=err>bar</span>
</span></span><span class=line><span class=cl>    <span class=err>echo</span> <span class=s2>&#34;but bar is not&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><h3 id=makeflags-命令行参数>$(MAKEFLAGS) 命令行参数<a hidden class=anchor aria-hidden=true href=#makeflags-命令行参数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=c># 搜索 -i 标志。MAKEFLAGS 只是一个单一字符的列表，每个参数一个字符。
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>ifneq</span> <span class=err>(</span><span class=k>$(</span><span class=nv>findstring</span> <span class=nv>i</span>, <span class=k>$(</span><span class=nv>MAKEFLAGS</span><span class=k>))</span><span class=err>,)</span>
</span></span><span class=line><span class=cl>    <span class=err>@echo</span> <span class=k>$(</span><span class=nv>MAKEFLAGS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=err>@echo</span> <span class=s2>&#34;i was passed to MAKEFLAGS&#34;</span>
</span></span><span class=line><span class=cl><span class=err>endif</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make -s -i
</span></span><span class=line><span class=cl><span class=go>is
</span></span></span><span class=line><span class=cl><span class=go>i was passed to MAKEFLAGS
</span></span></span></code></pre></div><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><blockquote><p>更多函数：<a href=https://www.gnu.org/software/make/manual/html_node/Functions.html>Functions for Transforming Text</a></p></blockquote><p>函数主要用于文本处理。使用 <code>$(fn, arguments)</code> 或 <code>${fn, arguments}</code> 调用函数。</p><h3 id=subst-字符串替换>subst 字符串替换<a hidden class=anchor aria-hidden=true href=#subst-字符串替换>#</a></h3><p>格式：<code>$(subst str,replacement,text)</code></p><p>使用 <code>str</code> 匹配 <code>text</code> 中的字符，再用 <code>replacement</code> 进行替换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 字符串替换，这里 totally 替换 not
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>bar</span> <span class=o>:=</span> <span class=si>${</span><span class=nv>subst</span><span class=p> not, totally, </span><span class=s2>&#34;I am not superman&#34;</span><span class=si>}</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><p>如果要替换空格或逗号，使用变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>comma</span> <span class=o>:=</span> ,
</span></span><span class=line><span class=cl><span class=nv>empty</span><span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>space</span> <span class=o>:=</span> <span class=k>$(</span>empty<span class=k>)</span> <span class=k>$(</span>empty<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a b c
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>subst <span class=k>$(</span>space<span class=k>)</span>,<span class=k>$(</span>comma<span class=k>)</span>,<span class=k>$(</span>foo<span class=k>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;a,b,c&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><p>不要在第 2、3 个参数前后包含空格，这将被视为字符串的一部分：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>comma</span> <span class=o>:=</span> ,
</span></span><span class=line><span class=cl><span class=nv>empty</span><span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>space</span> <span class=o>:=</span> <span class=k>$(</span>empty<span class=k>)</span> <span class=k>$(</span>empty<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a b c
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>subst <span class=k>$(</span>space<span class=k>)</span>, <span class=k>$(</span>comma<span class=k>)</span> , <span class=k>$(</span>foo<span class=k>))</span> <span class=c1># $(comma) 和 $(foo) 前后有一个空格</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;, a , b , c&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=patsubst-字符串替换>patsubst 字符串替换<a hidden class=anchor aria-hidden=true href=#patsubst-字符串替换>#</a></h3><p>格式：<code>$(patsubst pattern,replacement,text)</code></p><p>使用 <code>pattern</code> 匹配 <code>text</code> 中的字符，再用 <code>replacement</code> 进行替换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> a.o b.o l.a c.o
</span></span><span class=line><span class=cl><span class=nv>one</span> <span class=o>:=</span> <span class=k>$(</span>patsubst %.o,%.c,<span class=k>$(</span>foo<span class=k>))</span>
</span></span><span class=line><span class=cl><span class=c># 这是上面的简写
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>two</span> <span class=o>:=</span> <span class=k>$(</span>foo:%.o<span class=o>=</span>%.c<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 这是仅有后缀的简写，也等价于上述
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>three</span> <span class=o>:=</span> <span class=k>$(</span>foo:.o<span class=o>=</span>.c<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 输出都是 a.c b.c l.a c.c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>one<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>two<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$(</span>three<span class=k>)</span>
</span></span></code></pre></div><h3 id=foreach-函数>foreach 函数<a hidden class=anchor aria-hidden=true href=#foreach-函数>#</a></h3><p>格式：<code>$(foreach var,list,text)</code></p><p>它将一个单词列表（由空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，并为每个单词扩展文本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> who are you
</span></span><span class=line><span class=cl><span class=c># 对于 foo 中的每个“单词”，输出相同的单词并在后面加上感叹号
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(</span>foreach wrd,<span class=k>$(</span>foo<span class=k>)</span>,<span class=k>$(</span>wrd<span class=k>)</span>!<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出是 &#34;who! are! you!&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=if-函数>if 函数<a hidden class=anchor aria-hidden=true href=#if-函数>#</a></h3><p>格式：<code>$(if var,yes,no)</code></p><p><code>if</code> 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>this-is-not-empty</span> <span class=o>:=</span> hey
</span></span><span class=line><span class=cl><span class=nv>foo</span> <span class=o>:=</span> <span class=k>$(if</span> this-is-not-empty,yes,no<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>empty</span> <span class=o>:=</span>
</span></span><span class=line><span class=cl><span class=nv>bar</span> <span class=o>:=</span> <span class=k>$(if</span> <span class=k>$(</span>empty<span class=k>)</span>,yes,no<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 输出：yes
</span></span></span><span class=line><span class=cl><span class=c>#       no
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>foo<span class=k>)</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>bar<span class=k>)</span>
</span></span></code></pre></div><h3 id=call-函数>call 函数<a hidden class=anchor aria-hidden=true href=#call-函数>#</a></h3><p>格式：<code>$(call variable,param,param)</code></p><p>Make 支持创建基本函数，使用 <code>call</code> 调用用户创建的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># $(0) 是变量名，$(1) 、$(2) ... 等是参数。
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>sweet_new_fn</span> <span class=o>=</span> Variable Name: <span class=k>$(</span>0<span class=k>)</span> First: <span class=k>$(</span>1<span class=k>)</span> Second: <span class=k>$(</span>2<span class=k>)</span> Empty Variable: <span class=k>$(</span>3<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 输出 &#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&#34;</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>call sweet_new_fn, go, tigers<span class=k>)</span>
</span></span></code></pre></div><h3 id=shell-函数>shell 函数<a hidden class=anchor aria-hidden=true href=#shell-函数>#</a></h3><p>格式：<code>$(shell command)</code></p><p>调用 shell 执行 command，command 输出内容中的换行符会被替换为空格，不便阅读。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    @echo <span class=k>$(</span>shell ls -la<span class=k>)</span> 
</span></span></code></pre></div><h2 id=其他特性>其他特性<a hidden class=anchor aria-hidden=true href=#其他特性>#</a></h2><h3 id=include-包含外部-makefile>include 包含外部 makefile<a hidden class=anchor aria-hidden=true href=#include-包含外部-makefile>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=err>include</span> <span class=err>filename1</span> <span class=err>filename2</span> <span class=err>...</span>
</span></span></code></pre></div><h3 id=vpath-指令>vpath 指令<a hidden class=anchor aria-hidden=true href=#vpath-指令>#</a></h3><p>make 默认搜索当前目录来匹配依赖文件（不包含子目录），<code>vpath</code> 用于添加匹配文件的搜索路径</p><p>语法： <code>vpath &lt;pattern> &lt;directories></code></p><p><code>&lt;pattern></code> 会匹配 <code>&lt;directories></code> 中的文件名，多个目录使用 <code>空格</code> 或 <code>冒号</code> 分隔。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 添加 .c 文件搜索路径 dir1 dir2
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>vpath</span> <span class=err>%.c</span> <span class=err>dir1</span> <span class=err>dir2</span>
</span></span><span class=line><span class=cl><span class=nf>vpath %.c dir1</span><span class=o>:</span><span class=n>dir</span>2
</span></span></code></pre></div><h3 id=vpath-变量>VPATH 变量<a hidden class=anchor aria-hidden=true href=#vpath-变量>#</a></h3><p>作用同上，用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 添加所有文件的搜索路径 dir1 dir2
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>VPATH</span> <span class=o>:=</span> dir1 dir2
</span></span><span class=line><span class=cl><span class=nv>VPATH</span> <span class=o>:=</span> dir1:dir2
</span></span></code></pre></div><h3 id=phony-伪目标>.PHONY 伪目标<a hidden class=anchor aria-hidden=true href=#phony-伪目标>#</a></h3><p>伪目标只是一个标签，表示 make 不会生成该规则的目标文件。伪目标的取名不能和文件重名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f *.o
</span></span></code></pre></div><h3 id=delete_on_error>.DELETE_ON_ERROR<a hidden class=anchor aria-hidden=true href=#delete_on_error>#</a></h3><p>当规则执行失败，<code>.DELETE_ON_ERROR</code> 会删除规则已生成的所有目标文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>.DELETE_ON_ERROR</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=n>one</span> <span class=n>two</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>one</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch one
</span></span><span class=line><span class=cl>    <span class=nb>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>two</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    touch two
</span></span><span class=line><span class=cl>    <span class=nb>false</span>
</span></span></code></pre></div><h2 id=makefile-模板>makefile 模板<a hidden class=anchor aria-hidden=true href=#makefile-模板>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># 最终要生成的目标文件名
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>TARGET_EXEC</span> <span class=o>:=</span> final_program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译生成文件的目录
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>BUILD_DIR</span> <span class=o>:=</span> ./build
</span></span><span class=line><span class=cl><span class=c># 源文件所在的目录
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>SRC_DIRS</span> <span class=o>:=</span> ./src
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 找到所有需要编译的 C 和 C++ 文件
</span></span></span><span class=line><span class=cl><span class=c># 注意 * 表达式周围的单引号。否则 Make 会错误地扩展这些。
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>SRCS</span> <span class=o>:=</span> <span class=k>$(</span>shell find <span class=k>$(</span>SRC_DIRS<span class=k>)</span> -name <span class=s1>&#39;*.cpp&#39;</span> -or -name <span class=s1>&#39;*.c&#39;</span> -or -name <span class=s1>&#39;*.s&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 给每个 C/C++ 文件名加 .o 结尾
</span></span></span><span class=line><span class=cl><span class=c># 如 hello.cpp 转换为 ./build/hello.cpp.o
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>OBJS</span> <span class=o>:=</span> <span class=k>$(</span>SRCS:%<span class=o>=</span><span class=k>$(</span>BUILD_DIR<span class=k>)</span>/%.o<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># .o 结尾替换为 .d
</span></span></span><span class=line><span class=cl><span class=c># 如 ./build/hello.cpp.o 转换为 ./build/hello.cpp.d
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>DEPS</span> <span class=o>:=</span> <span class=k>$(</span>OBJS:.o<span class=o>=</span>.d<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># ./src 中的每个文件夹都需要传递给 GCC，以便它可以找到头文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>INC_DIRS</span> <span class=o>:=</span> <span class=k>$(</span>shell find <span class=k>$(</span>SRC_DIRS<span class=k>)</span> -type d<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c># 给 INC_DIRS 添加前缀 -I ，GCC指定头文件路径需要 -I，如 moduleA 会变成 -ImoduleA
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>INC_FLAGS</span> <span class=o>:=</span> <span class=k>$(</span>addprefix -I,<span class=k>$(</span>INC_DIRS<span class=k>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># -MMD 和 -MP 参数会生成每个 .c 文件所依赖的头文件关系
</span></span></span><span class=line><span class=cl><span class=c># 保存到 .d 结尾的文件中
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>CPPFLAGS</span> <span class=o>:=</span> <span class=k>$(</span>INC_FLAGS<span class=k>)</span> -MMD -MP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 最终的编译步骤
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/$(TARGET_EXEC)</span><span class=o>:</span> <span class=k>$(</span><span class=nv>OBJS</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>OBJS<span class=k>)</span> -o <span class=nv>$@</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译C源码
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/%.c.o</span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    mkdir -p <span class=k>$(</span>dir <span class=nv>$@</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 编译C++源码
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(BUILD_DIR)/%.cpp.o</span><span class=o>:</span> %.<span class=n>cpp</span>
</span></span><span class=line><span class=cl>    mkdir -p <span class=k>$(</span>dir <span class=nv>$@</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CXX<span class=k>)</span> <span class=k>$(</span>CPPFLAGS<span class=k>)</span> <span class=k>$(</span>CXXFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -r <span class=k>$(</span>BUILD_DIR<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 包含编译器生成的 .d 文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=err>-include</span> <span class=k>$(</span><span class=nv>DEPS</span><span class=k>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/makefile/>Makefile</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kingtuo123.com/>King's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=extend_footer align=center style="padding:5px 0 0"><a rel=nofollow href=mailto:kingtuo123@foxmail.com target=_blank>kingtuo123@foxmail.com</a></div><div class=extend_footer align=center style="padding:5px 0 0"><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><div class=extend_footer align=center style="padding:5px 0 10px"><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33032402001943" rel=noreferrer target=_blank>浙公网安备33032402001943</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>