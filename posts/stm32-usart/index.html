<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STM32 USART | Notes</title>
<meta name=keywords content="stm32"><meta name=description content="Note"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/stm32-usart/><link crossorigin=anonymous href=/assets/css/stylesheet.e3fd28a689eab557dc57ec445ca6884a24e47e2b11d97e7120aaf56a15d8c48b.css integrity="sha256-4/0oponqtVfcV+xEXKaISiTkfisR2X5xIKr1ahXYxIs=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="STM32 USART"><meta property="og:description" content="Note"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/stm32-usart/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="STM32 USART"><meta name=twitter:description content="Note"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"STM32 USART","item":"https://kingtuo123.com/posts/stm32-usart/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STM32 USART","name":"STM32 USART","description":"Note","keywords":["stm32"],"articleBody":"USARTx_SR 状态寄存器（ Status register ） CTS: CTS标志 (CTS flag) LBD: LIN断开检测标志 (LIN break detection flag) TXE: 发送数据寄存器空 (Transmit data register empty) TC: 发送完成 (Transmission complete) RXNE：读数据寄存器非空 (Read data register not empty) IDLE：监测到总线空闲 (IDLE line detected) ORE：过载错误 (Overrun error) NE: 噪声错误标志 (Noise error flag) FE: 帧错误 (Framing error) PE: 校验错误 (Parity error) USARTx_DR 数据寄存器（ Data register ） USARTx_CR1 控制寄存器 1 UE：USART使能 (USART enable) M：字长 (Word length) WAKE：唤醒的方法 (Wakeup method) PCE：检验控制使能 (Parity control enable) PS：校验选择 (Parity selection) PEIE：PE中断使能 (PE interrupt enable) TXEIE：发送缓冲区空中断使能 (TXE interrupt enable) TCIE：发送完成中断使能 (Transmission complete interrupt enable) RXNEIE：接收缓冲区非空中断使能 (RXNE interrupt enable) IDLEIE：IDLE中断使能 (IDLE interrupt enable) TE：发送使能 (Transmitter enable) RE：接收使能 (Receiver enable) RWU：接收唤醒 (Receiver wakeup) SBK：发送断开帧 (Send break) USARTx_CR2 控制寄存器 2 LINEN：LIN模式使能 (LIN mode enable) STOP：停止位 (STOP bits) CLKEN：时钟使能 (Clock enable) CPOL：时钟极性 (Clock polarity) CPHA： 时钟相位 (Clock phase) LBCL：最后一位时钟脉冲 (Last bit clock pulse) LBDIE：LIN断开符检测中断使能 (LIN break detection interrupt enable) LBDL：LIN断开符检测长度 (LIN break detection length) ADD[3:0]：本设备的USART节点地址 USARTx_CR3 控制寄存器 3 CTSIE：CTS中断使能 (CTS interrupt enable) CTSE：CTS使能 (CTS enable) RTSE：RTS使能 (RTS enable) DMAT：DMA使能发送 (DMA enable transmitter) DMAR: DMA使能接收 (DMA enable receiver) SCEN: 智能卡模式使能 (Smartcard mode enable) NACK：智能卡NACK使能 (Smartcard NACK enable) HDSEL：半双工选择 (Half-duplex selection) IRLP：红外低功耗 (IrDA low-power) IREN：红外模式使能 (IrDA mode enable) EIE：错误中断使能 (Error interrupt enable) USART_GTPR 保护时间和预分频寄存器（ Guard time and prescaler register ） GT[7:0]：保护时间值 (Guard time value) PSC[7:0]：预分频器值 (Prescaler value) USARTx_BRR 波特率寄存器（ Baud rate register ） DIV_Mantissa[11:0]： 定义 USARTDIV 的整数部分 DIV_Fraction[3:0]： 定义 USARTDIV 的小数部分 公式如下，以 fPLCK = 72MHZ，Baud Rate = 9600 为例：\nUSARTDIV：我是理解为 fPCLK 的分频系数 fPLCK ：为 USART 时钟 OVER8：读取 1 bit 所用的采样次数 0：采样 16 次 1：采样 8 次 OVER8 是 USART_BRR 的第 15 位，该位在参考手册中没有描述，但是在标准库 stm32f10x_usart.c 中有相关代码，如下：\n/* 篇幅有限，只截取 USART_Init 函数部分代码 */ /* USART OverSampling-8 Mask */ #define CR1_OVER8_Set ((u16)0x8000) /* USART OVER8 mode Enable Mask */ #define CR1_OVER8_Reset ((u16)0x7FFF) /* USART OVER8 mode Disable Mask */ /* Determine the integer part */ if ((USARTx-\u003eCR1 \u0026 CR1_OVER8_Set) != 0) { /* Integer part computing in case Oversampling mode is 8 Samples */ integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct-\u003eUSART_BaudRate))); } else /* if ((USARTx-\u003eCR1 \u0026 CR1_OVER8_Set) == 0) */ { /* Integer part computing in case Oversampling mode is 16 Samples */ integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct-\u003eUSART_BaudRate))); } OVER8 复位值是0，也就是 16 次采样，即 16 个时钟周期读取 1 bit。波特率单位 bps（bit per second），即每秒传输比特位个数。结合上面两点，公式也就不难理解。\n再看上述结果 468.75，将它转化为二进制即 000111010100.1100 ：\n整数部分：即 0x1D4 写入 DIV_Mantissa[11:0] 小数部分：即 0xC 写入 DIV_Fraction[3:0] 有的教程是将小数部分乘上16：0.75x16=12，其实就是小数部分左移 4 位，结果是一样的（个人觉得上面更好理解）。\n链接：在线进制转换\nCPU 的时钟频率越低，则某一特定波特率的误差也越低。可以达到的波特率上限可以由这组数据得到。 只有 USART1 使用 PCLK2 (最高72MHz)。其它 USART 使用 PCLK1 (最高36MHz)。 中断控制 USART 有多个中断请求事件\n中断事件 事件标志 寄存器 使能控制位 奇偶校验错误 PE CR1 位8 发送数据寄存器为空 TXE CR1 位7 发送完成 TC CR1 位6 准备好读取接收到的数据 / 检测到上溢出错误 RXNE / ORE CR1 位5 检测到空闲线路 IDLE CR1 位4 断路标志 LBD CR2 位6 CTS标志 CTS CR3 位10 多缓冲通信中的噪声标志、上溢出错误和帧错误 NF/ORE/FE CR3 位0 事件标志对应状态寄存器 USART_SR 中的位，当对应位为 1 时触发中断事件。\n例程 寄存器 void USART_Config(){ RCC-\u003eAPB2ENR |= (uint32_t)0x05; // 使能GPIOA/AFIO时钟 GPIOA-\u003eCRH |= (uint32_t)0x0B \u003c\u003c 4; // 配置PA9复用推挽输出，最高50MHZ GPIOA-\u003eCRH |= (uint32_t)0x04 \u003c\u003c 8; // 配置PA10浮空输入 RCC-\u003eAPB2ENR |= (uint32_t)0x01 \u003c\u003c 14; // 使能USART1时钟 USART1-\u003eCR1 |= (uint16_t)0x00 \u003c\u003c 12; // 一个起始位，8个数据位 USART1-\u003eCR2 |= (uint16_t)0x00 \u003c\u003c 12; // 一个停止位 USART1-\u003eCR3 |= (uint16_t)0x00 \u003c\u003c 8; // 禁用CTS，RTS硬件流控制 USART1-\u003eBRR = (uint16_t)0x1D4C; // 波特率9600 USART1-\u003eCR1 |= (uint16_t)0x0B; // 收/发使能 NVIC-\u003eISER[1] |= (uint32_t)0x01 \u003c\u003c (37-32); // 使能USART1中断，中断号是37 NVIC-\u003eIP[9] |= (uint32_t)0x40; // 配置优先级主1子1 USART1-\u003eCR1 |= (uint16_t)0x01 \u003c\u003c 5; // 使能接收中断 USART1-\u003eCR1 |= (uint16_t)0x01 \u003c\u003c 0; // 使能USART1 } void USART1_IRQHandler(void) { uint8_t ucTemp; if(USART1-\u003eSR \u0026 (uint16_t)0x20) { ucTemp = (uint8_t)(USARTx-\u003eDR \u0026 (uint16_t)0x01FF); // 接收数据 USARTx-\u003eDR = (uint16_t)ucTemp \u0026 (uint16_t)0x01FF; // 发送数据 }\t} 标准库 void USART_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; // 打开串口 GPIO 的时钟 DEBUG_USART_GPIO_APBxClkCmd(GPIOA, ENABLE); // 打开串口外设的时钟 DEBUG_USART_APBxClkCmd(RCC_APB2Periph_USART1, ENABLE); // 将 USART1 Tx 的 GPIO 配置为推挽复用模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026GPIO_InitStructure); // 将 USART1 Rx 的 GPIO 配置为浮空输入模式 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, \u0026GPIO_InitStructure); // 配置串口的工作参数 USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, \u0026USART_InitStructure); // 串口中断优先级配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(\u0026NVIC_InitStructure); // 使能串口接收中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 使能串口 USART_Cmd(USART1, ENABLE); } void USART1_IRQHandler(void) { uint8_t ucTemp; if(USART_GetITStatus(DEBUG_USARTx,USART_IT_RXNE)!=RESET) {\tucTemp = USART_ReceiveData(DEBUG_USARTx); USART_SendData(DEBUG_USARTx,ucTemp); }\t} ","wordCount":"664","inLanguage":"en","datePublished":"2022-08-04T00:00:00Z","dateModified":"2022-08-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/stm32-usart/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STM32 USART</h1><div class=post-meta>&lt;span title='2022-08-04 00:00:00 +0000 UTC'>August 4, 2022&lt;/span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#usartx_sr aria-label=USARTx_SR>USARTx_SR</a></li><li><a href=#usartx_dr aria-label=USARTx_DR>USARTx_DR</a></li><li><a href=#usartx_cr1 aria-label=USARTx_CR1>USARTx_CR1</a></li><li><a href=#usartx_cr2 aria-label=USARTx_CR2>USARTx_CR2</a></li><li><a href=#usartx_cr3 aria-label=USARTx_CR3>USARTx_CR3</a></li><li><a href=#usart_gtpr aria-label=USART_GTPR>USART_GTPR</a></li><li><a href=#usartx_brr aria-label=USARTx_BRR>USARTx_BRR</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e6%8e%a7%e5%88%b6 aria-label=中断控制>中断控制</a></li><li><a href=#%e4%be%8b%e7%a8%8b aria-label=例程>例程</a><ul><li><a href=#%e5%af%84%e5%ad%98%e5%99%a8 aria-label=寄存器>寄存器</a></li><li><a href=#%e6%a0%87%e5%87%86%e5%ba%93 aria-label=标准库>标准库</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=usartx_sr>USARTx_SR<a hidden class=anchor aria-hidden=true href=#usartx_sr>#</a></h2><ul><li>状态寄存器（ Status register ）</li></ul><div align=center><img src=1.png style=max-height:200px></img></div><ul><li>CTS: CTS标志 (CTS flag)</li><li>LBD: LIN断开检测标志 (LIN break detection flag)</li><li><strong>TXE: 发送数据寄存器空 (Transmit data register empty)</strong></li><li><strong>TC: 发送完成 (Transmission complete)</strong></li><li><strong>RXNE：读数据寄存器非空 (Read data register not empty)</strong></li><li>IDLE：监测到总线空闲 (IDLE line detected)</li><li>ORE：过载错误 (Overrun error)</li><li>NE: 噪声错误标志 (Noise error flag)</li><li>FE: 帧错误 (Framing error)</li><li><strong>PE: 校验错误 (Parity error)</strong></li></ul><h2 id=usartx_dr>USARTx_DR<a hidden class=anchor aria-hidden=true href=#usartx_dr>#</a></h2><ul><li>数据寄存器（ Data register ）</li></ul><div align=center><img src=5.png style=max-height:200px></img></div><h2 id=usartx_cr1>USARTx_CR1<a hidden class=anchor aria-hidden=true href=#usartx_cr1>#</a></h2><ul><li>控制寄存器 1</li></ul><div align=center><img src=6.png style=max-height:200px></img></div><ul><li><strong>UE：USART使能 (USART enable)</strong></li><li><strong>M：字长 (Word length)</strong></li><li>WAKE：唤醒的方法 (Wakeup method)</li><li><strong>PCE：检验控制使能 (Parity control enable)</strong></li><li><strong>PS：校验选择 (Parity selection)</strong></li><li><strong>PEIE：PE中断使能 (PE interrupt enable)</strong></li><li><strong>TXEIE：发送缓冲区空中断使能 (TXE interrupt enable)</strong></li><li><strong>TCIE：发送完成中断使能 (Transmission complete interrupt enable)</strong></li><li><strong>RXNEIE：接收缓冲区非空中断使能 (RXNE interrupt enable)</strong></li><li>IDLEIE：IDLE中断使能 (IDLE interrupt enable)</li><li><strong>TE：发送使能 (Transmitter enable)</strong></li><li><strong>RE：接收使能 (Receiver enable)</strong></li><li>RWU：接收唤醒 (Receiver wakeup)</li><li>SBK：发送断开帧 (Send break)</li></ul><h2 id=usartx_cr2>USARTx_CR2<a hidden class=anchor aria-hidden=true href=#usartx_cr2>#</a></h2><ul><li>控制寄存器 2</li></ul><div align=center><img src=7.png style=max-height:200px></img></div><ul><li>LINEN：LIN模式使能 (LIN mode enable)</li><li><strong>STOP：停止位 (STOP bits)</strong></li><li>CLKEN：时钟使能 (Clock enable)</li><li>CPOL：时钟极性 (Clock polarity)</li><li>CPHA： 时钟相位 (Clock phase)</li><li>LBCL：最后一位时钟脉冲 (Last bit clock pulse)</li><li>LBDIE：LIN断开符检测中断使能 (LIN break detection interrupt enable)</li><li>LBDL：LIN断开符检测长度 (LIN break detection length)</li><li>ADD[3:0]：本设备的USART节点地址</li></ul><h2 id=usartx_cr3>USARTx_CR3<a hidden class=anchor aria-hidden=true href=#usartx_cr3>#</a></h2><ul><li>控制寄存器 3</li></ul><div align=center><img src=8.png style=max-height:200px></img></div><ul><li>CTSIE：CTS中断使能 (CTS interrupt enable)</li><li>CTSE：CTS使能 (CTS enable)</li><li>RTSE：RTS使能 (RTS enable)</li><li><strong>DMAT：DMA使能发送 (DMA enable transmitter)</strong></li><li><strong>DMAR: DMA使能接收 (DMA enable receiver)</strong></li><li>SCEN: 智能卡模式使能 (Smartcard mode enable)</li><li>NACK：智能卡NACK使能 (Smartcard NACK enable)</li><li>HDSEL：半双工选择 (Half-duplex selection)</li><li>IRLP：红外低功耗 (IrDA low-power)</li><li>IREN：红外模式使能 (IrDA mode enable)</li><li>EIE：错误中断使能 (Error interrupt enable)</li></ul><h2 id=usart_gtpr>USART_GTPR<a hidden class=anchor aria-hidden=true href=#usart_gtpr>#</a></h2><ul><li>保护时间和预分频寄存器（ Guard time and prescaler register ）</li></ul><div align=center><img src=9.png style=max-height:200px></img></div><ul><li>GT[7:0]：保护时间值 (Guard time value)</li><li>PSC[7:0]：预分频器值 (Prescaler value)</li></ul><h2 id=usartx_brr>USARTx_BRR<a hidden class=anchor aria-hidden=true href=#usartx_brr>#</a></h2><ul><li>波特率寄存器（ Baud rate register ）</li></ul><div align=center><img src=3.png style=max-height:200px></img></div><ul><li><strong>DIV_Mantissa[11:0]：</strong> 定义 <code>USARTDIV</code> 的整数部分</li><li><strong>DIV_Fraction[3:0]：</strong> 定义 <code>USARTDIV</code> 的小数部分</li></ul><p>公式如下，以 <code>fPLCK</code> = 72MHZ，<code>Baud Rate</code> = 9600 为例：</p><div align=left><img src=m1.jpg style=max-height:120px></img></div><ul><li><code>USARTDIV</code>：我是理解为 fPCLK 的分频系数</li><li><code>fPLCK</code> ：为 <code>USART</code> 时钟</li><li><code>OVER8</code>：读取 1 bit 所用的采样次数<ul><li>0：采样 16 次</li><li>1：采样 8 次</li></ul></li></ul><p>OVER8 是 USART_BRR 的第 15 位，该位在参考手册中没有描述，但是在标准库 <code>stm32f10x_usart.c</code> 中有相关代码，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 篇幅有限，只截取 USART_Init 函数部分代码 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* USART OverSampling-8 Mask */</span>
</span></span><span class=line><span class=cl><span class=cp>#define CR1_OVER8_Set             ((u16)0x8000)  </span><span class=cm>/* USART OVER8 mode Enable Mask */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define CR1_OVER8_Reset           ((u16)0x7FFF)  </span><span class=cm>/* USART OVER8 mode Disable Mask */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Determine the integer part */</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>USARTx</span><span class=o>-&gt;</span><span class=n>CR1</span> <span class=o>&amp;</span> <span class=n>CR1_OVER8_Set</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Integer part computing in case Oversampling mode is 8 Samples */</span>
</span></span><span class=line><span class=cl>    <span class=n>integerdivider</span> <span class=o>=</span> <span class=p>((</span><span class=mi>25</span> <span class=o>*</span> <span class=n>apbclock</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=p>(</span><span class=n>USART_InitStruct</span><span class=o>-&gt;</span><span class=n>USART_BaudRate</span><span class=p>)));</span>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=cm>/* if ((USARTx-&gt;CR1 &amp; CR1_OVER8_Set) == 0) */</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Integer part computing in case Oversampling mode is 16 Samples */</span>
</span></span><span class=line><span class=cl>    <span class=n>integerdivider</span> <span class=o>=</span> <span class=p>((</span><span class=mi>25</span> <span class=o>*</span> <span class=n>apbclock</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=mi>4</span> <span class=o>*</span> <span class=p>(</span><span class=n>USART_InitStruct</span><span class=o>-&gt;</span><span class=n>USART_BaudRate</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>OVER8</code> 复位值是0，也就是 16 次采样，即 16 个时钟周期读取 1 bit。波特率单位 bps（bit per second），即每秒传输比特位个数。结合上面两点，公式也就不难理解。</p><p>再看上述结果 468.75，将它转化为二进制即 <code>000111010100.1100</code> ：</p><ul><li>整数部分：即 <code>0x1D4</code> 写入 DIV_Mantissa[11:0]</li><li>小数部分：即 <code>0xC</code> 写入 DIV_Fraction[3:0]</li></ul><p>有的教程是将小数部分乘上16：<code>0.75x16=12</code>，其实就是小数部分左移 4 位，结果是一样的（个人觉得上面更好理解）。</p><blockquote><p>链接：<a href=https://www.rapidtables.org/zh-CN/convert/number/decimal-to-binary.html>在线进制转换</a></p></blockquote><div align=center><img src=2.png style=max-height:400px></img></div><blockquote><ol><li>CPU 的时钟频率越低，则某一特定波特率的误差也越低。可以达到的波特率上限可以由这组数据得到。</li><li>只有 USART1 使用 PCLK2 (最高72MHz)。其它 USART 使用 PCLK1 (最高36MHz)。</li></ol></blockquote><h2 id=中断控制>中断控制<a hidden class=anchor aria-hidden=true href=#中断控制>#</a></h2><p>USART 有多个中断请求事件</p><table><thead><tr><th style=text-align:left>中断事件</th><th style=text-align:left>事件标志</th><th style=text-align:left>寄存器</th><th style=text-align:left>使能控制位</th></tr></thead><tbody><tr><td style=text-align:left>奇偶校验错误</td><td style=text-align:left>PE</td><td style=text-align:left>CR1</td><td style=text-align:left>位8</td></tr><tr><td style=text-align:left>发送数据寄存器为空</td><td style=text-align:left>TXE</td><td style=text-align:left>CR1</td><td style=text-align:left>位7</td></tr><tr><td style=text-align:left>发送完成</td><td style=text-align:left>TC</td><td style=text-align:left>CR1</td><td style=text-align:left>位6</td></tr><tr><td style=text-align:left>准备好读取接收到的数据 / 检测到上溢出错误</td><td style=text-align:left>RXNE / ORE</td><td style=text-align:left>CR1</td><td style=text-align:left>位5</td></tr><tr><td style=text-align:left>检测到空闲线路</td><td style=text-align:left>IDLE</td><td style=text-align:left>CR1</td><td style=text-align:left>位4</td></tr><tr><td style=text-align:left>断路标志</td><td style=text-align:left>LBD</td><td style=text-align:left>CR2</td><td style=text-align:left>位6</td></tr><tr><td style=text-align:left>CTS标志</td><td style=text-align:left>CTS</td><td style=text-align:left>CR3</td><td style=text-align:left>位10</td></tr><tr><td style=text-align:left>多缓冲通信中的噪声标志、上溢出错误和帧错误</td><td style=text-align:left>NF/ORE/FE</td><td style=text-align:left>CR3</td><td style=text-align:left>位0</td></tr></tbody></table><p>事件标志对应状态寄存器 USART_SR 中的位，当对应位为 1 时触发中断事件。</p><h2 id=例程>例程<a hidden class=anchor aria-hidden=true href=#例程>#</a></h2><h3 id=寄存器>寄存器<a hidden class=anchor aria-hidden=true href=#寄存器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>USART_Config</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span> <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x05</span><span class=p>;</span>      <span class=c1>// 使能GPIOA/AFIO时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GPIOA</span><span class=o>-&gt;</span><span class=n>CRH</span>   <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x0B</span> <span class=o>&lt;&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 配置PA9复用推挽输出，最高50MHZ
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GPIOA</span><span class=o>-&gt;</span><span class=n>CRH</span>   <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x04</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=c1>// 配置PA10浮空输入
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span> <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x01</span> <span class=o>&lt;&lt;</span> <span class=mi>14</span><span class=p>;</span> <span class=c1>// 使能USART1时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR1</span>  <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x00</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>;</span> <span class=c1>// 一个起始位，8个数据位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR2</span>  <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x00</span> <span class=o>&lt;&lt;</span> <span class=mi>12</span><span class=p>;</span> <span class=c1>// 一个停止位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR3</span>  <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x00</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>;</span>  <span class=c1>// 禁用CTS，RTS硬件流控制
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>BRR</span>   <span class=o>=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x1D4C</span><span class=p>;</span>     <span class=c1>// 波特率9600
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR1</span>  <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x0B</span><span class=p>;</span>       <span class=c1>// 收/发使能
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>NVIC</span><span class=o>-&gt;</span><span class=n>ISER</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x01</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>37</span><span class=o>-</span><span class=mi>32</span><span class=p>);</span> <span class=c1>// 使能USART1中断，中断号是37
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NVIC</span><span class=o>-&gt;</span><span class=n>IP</span><span class=p>[</span><span class=mi>9</span><span class=p>]</span>   <span class=o>|=</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=mh>0x40</span><span class=p>;</span>      <span class=c1>// 配置优先级主1子1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR1</span>   <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x01</span> <span class=o>&lt;&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// 使能接收中断 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART1</span><span class=o>-&gt;</span><span class=n>CR1</span>   <span class=o>|=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x01</span> <span class=o>&lt;&lt;</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 使能USART1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>USART1_IRQHandler</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>ucTemp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>USART1</span><span class=o>-&gt;</span><span class=n>SR</span> <span class=o>&amp;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ucTemp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=p>)(</span><span class=n>USARTx</span><span class=o>-&gt;</span><span class=n>DR</span> <span class=o>&amp;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x01FF</span><span class=p>);</span> <span class=c1>// 接收数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>USARTx</span><span class=o>-&gt;</span><span class=n>DR</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=n>ucTemp</span> <span class=o>&amp;</span> <span class=p>(</span><span class=kt>uint16_t</span><span class=p>)</span><span class=mh>0x01FF</span><span class=p>;</span>  <span class=c1>// 发送数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>	 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=标准库>标准库<a hidden class=anchor aria-hidden=true href=#标准库>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>USART_Config</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>GPIO_InitTypeDef</span> <span class=n>GPIO_InitStructure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitTypeDef</span> <span class=n>USART_InitStructure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NVIC_InitTypeDef</span> <span class=n>NVIC_InitStructure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 打开串口 GPIO 的时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>DEBUG_USART_GPIO_APBxClkCmd</span><span class=p>(</span><span class=n>GPIOA</span><span class=p>,</span> <span class=n>ENABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 打开串口外设的时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>DEBUG_USART_APBxClkCmd</span><span class=p>(</span><span class=n>RCC_APB2Periph_USART1</span><span class=p>,</span> <span class=n>ENABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 将 USART1 Tx 的 GPIO 配置为推挽复用模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Pin</span> <span class=o>=</span> <span class=n>GPIO_Pin_9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Mode</span> <span class=o>=</span> <span class=n>GPIO_Mode_AF_PP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Speed</span> <span class=o>=</span> <span class=n>GPIO_Speed_50MHz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>GPIO_Init</span><span class=p>(</span><span class=n>GPIOA</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>GPIO_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 将 USART1 Rx 的 GPIO 配置为浮空输入模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Pin</span> <span class=o>=</span> <span class=n>GPIO_Pin_10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GPIO_InitStructure</span><span class=p>.</span><span class=n>GPIO_Mode</span> <span class=o>=</span> <span class=n>GPIO_Mode_IN_FLOATING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>GPIO_Init</span><span class=p>(</span><span class=n>GPIOA</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>GPIO_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 配置串口的工作参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_BaudRate</span> <span class=o>=</span> <span class=mi>9600</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_WordLength</span> <span class=o>=</span> <span class=n>USART_WordLength_8b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_StopBits</span> <span class=o>=</span> <span class=n>USART_StopBits_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_Parity</span> <span class=o>=</span> <span class=n>USART_Parity_No</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_HardwareFlowControl</span> <span class=o>=</span> <span class=n>USART_HardwareFlowControl_None</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>USART_InitStructure</span><span class=p>.</span><span class=n>USART_Mode</span> <span class=o>=</span> <span class=n>USART_Mode_Rx</span> <span class=o>|</span> <span class=n>USART_Mode_Tx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>USART_Init</span><span class=p>(</span><span class=n>USART1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>USART_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 串口中断优先级配置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>NVIC_PriorityGroupConfig</span><span class=p>(</span><span class=n>NVIC_PriorityGroup_2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannel</span> <span class=o>=</span> <span class=n>USART1_IRQn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelPreemptionPriority</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelSubPriority</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>NVIC_InitStructure</span><span class=p>.</span><span class=n>NVIC_IRQChannelCmd</span> <span class=o>=</span> <span class=n>ENABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>NVIC_Init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>NVIC_InitStructure</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 使能串口接收中断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>USART_ITConfig</span><span class=p>(</span><span class=n>USART1</span><span class=p>,</span> <span class=n>USART_IT_RXNE</span><span class=p>,</span> <span class=n>ENABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 使能串口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>USART_Cmd</span><span class=p>(</span><span class=n>USART1</span><span class=p>,</span> <span class=n>ENABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>USART1_IRQHandler</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>ucTemp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=nf>USART_GetITStatus</span><span class=p>(</span><span class=n>DEBUG_USARTx</span><span class=p>,</span><span class=n>USART_IT_RXNE</span><span class=p>)</span><span class=o>!=</span><span class=n>RESET</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>		
</span></span><span class=line><span class=cl>        <span class=n>ucTemp</span> <span class=o>=</span> <span class=nf>USART_ReceiveData</span><span class=p>(</span><span class=n>DEBUG_USARTx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>USART_SendData</span><span class=p>(</span><span class=n>DEBUG_USARTx</span><span class=p>,</span><span class=n>ucTemp</span><span class=p>);</span>    
</span></span><span class=line><span class=cl>	<span class=p>}</span>	 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/stm32/>stm32</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>