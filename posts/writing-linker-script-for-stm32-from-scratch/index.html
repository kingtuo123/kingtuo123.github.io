<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从零编写 STM32 链接脚本 | Notes</title><meta name=keywords content="stm32"><meta name=description content="参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 硬件平台 STM32F103ZET6 野火霸道开发板 V2
准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境
预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x0800 0000，SRAM 起始地址是 0x2000 0000
参考手册 Boot configuration 一节有这样一段话：
上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从地址 0x0000 0004 处开始执行代码
当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 内存映射。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址 0x08000000 或 0x00000000 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/><link crossorigin=anonymous href=/assets/css/stylesheet.8ebc77252a80376d5405e5c3d390978fde43b90ca4e28883547f645460b220e4.css integrity="sha256-jrx3JSqAN21UBeXD05CXj95DuQyk4oiDVH9kVGCyIOQ=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="从零编写 STM32 链接脚本"><meta property="og:description" content="参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 硬件平台 STM32F103ZET6 野火霸道开发板 V2
准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境
预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x0800 0000，SRAM 起始地址是 0x2000 0000
参考手册 Boot configuration 一节有这样一段话：
上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从地址 0x0000 0004 处开始执行代码
当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 内存映射。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址 0x08000000 或 0x00000000 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="从零编写 STM32 链接脚本"><meta name=twitter:description content="参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 硬件平台 STM32F103ZET6 野火霸道开发板 V2
准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境
预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x0800 0000，SRAM 起始地址是 0x2000 0000
参考手册 Boot configuration 一节有这样一段话：
上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从地址 0x0000 0004 处开始执行代码
当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 内存映射。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址 0x08000000 或 0x00000000 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"从零编写 STM32 链接脚本","item":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零编写 STM32 链接脚本","name":"从零编写 STM32 链接脚本","description":"参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 硬件平台 STM32F103ZET6 野火霸道开发板 V2\n准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境\n预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x0800 0000，SRAM 起始地址是 0x2000 0000\n参考手册 Boot configuration 一节有这样一段话：\n上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从地址 0x0000 0004 处开始执行代码\n当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 内存映射。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址 0x08000000 或 0x00000000 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。","keywords":["stm32"],"articleBody":" 参考文章： Writing linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 硬件平台 STM32F103ZET6 野火霸道开发板 V2\n准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境\n预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 内存映射 FLASH 起始地址是 0x0800 0000，SRAM 起始地址是 0x2000 0000\n参考手册 Boot configuration 一节有这样一段话：\n上电后，CPU 从地址 0x0000 0000 获取栈顶地址，然后从地址 0x0000 0004 处开始执行代码\n当 CPU 从地址 0x00000000 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 内存映射。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 0x08000000 映射到 0x00000000；然后就可以从其原始地址 0x08000000 或 0x00000000 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。\n大多数情况下，在芯片启动时需要设置堆栈指针，不同架构的平台方法也不同。步骤很简单：找到存储堆栈地址的位置，将该地址设置为栈顶地址。逻辑上来说，栈空间是从上往下增长的，所以它需要足够的空间（指定大小）。\n0x0000 0000 中的值会被加载到 SP 寄存器，0x0000 0004 中的值会被加载到 PC 寄存器\n开始编写 最简单的链接脚本 链接文件由一个称为 SECTIONS 的块组成。在此块中，你定义的段将被分配到二进制文件中。\n最重要的段是： .test - 包含你的代码 .data - 包含已初始化的全局/静态变量 .bss - 包含未初始化的全局/静态变量 我们的第一个脚本，将只使用 .text 。没有数据，没有变量，只有纯代码。我们创建一个 script.ld 文件，写入下面的内容：\nSECTIONS { .text : { *(.text) } } 上面的脚本告诉链接器： 创建一个 .text 段（冒号左边的部分） 获取目标文件中所有的 .text 段（花括号中的部分） 把第 2 步获取的段放到第 1 步创建的段中 我们定义了代码部分，但没有指定它放在哪里。根据之前讲述的内容，它应该被放到地址 0x08000000：\nSECTIONS { . = 0x08000000; .text : { *(.text) } } 链接脚本中的点 . 是位置计数器。它从 0x0 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 .text 段之后读取位置计数器的值，它的值将是 0x08000000 加上你添加的段的大小。\n好了，我们的代码有了一个正确的位置，接下来只要知道入口程序地址以及堆栈地址：\nENTRY(main); SECTIONS { . = 0x08000000; .text : { // BYTE，SHORT，LONG，QUAD 命令分别存储 1，2，4，8 字节 LONG(0x20010000); LONG(main | 1); *(.text) } } 当 STM32 启动时，它会从 FLASH 读取两个地址（共 8 字节）。第一个是栈顶地址，第二个是入口程序地址。\nENTRY(main) 告诉链接器应该使用哪个符号作为程序的入口点。这也可以防止包含 main 函数的 .text 部分被链接器作为垃圾丢弃。\nLONG(0x20010000) 告诉链接器将 0x20010000 这四个字节放入输出的二进制文件中。为什么是这四个字节？因为 SRAM 地址从 0x20000000 开始，大小有 64KB（0x10000）。 0x20000000 + 0x10000 = 0x20010000 就是栈顶的地址。\nLONG(main | 1) 将 main 函数的地址输出到二进制文件中。如你所见，main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 切换到 thumb 模式，而不是表示 ARM 模式的偶数地址。\n好了，我们有了一个链接器脚本，再创建 main.c 来点亮开发板上的红色 LED ：\n#include \"registers.h\" // 由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余 int main(void) { // 开启 GPIOB 时钟 RCC-\u003eAPB2ENR |= (1 \u003c\u003c LED_CLK); // 配置引脚推挽输出 LED_GPIO-\u003eCRL |= (3 \u003c\u003c (LED_PIN * 4)); // 引脚输出低电平 LED_GPIO-\u003eBRR = (1 \u003c\u003c LED_PIN); while (1); } 创建头文件 registers.h ：\n#ifndef __REGISTERS_H #define __REGISTERS_H #include typedef struct { uint32_t CR; uint32_t CFGR; uint32_t CIR; uint32_t APB2RSTR; uint32_t APB1RSTR; uint32_t AHBENR; uint32_t APB2ENR; uint32_t APB1ENR; uint32_t BDCR; uint32_t CSR; } RCC_Reg; #define RCC ((RCC_Reg*) 0x40021000) typedef struct { uint32_t CRL; uint32_t CRH; uint32_t IDR; uint32_t ODR; uint32_t BSRR; uint32_t BRR; uint32_t LCKR; } GPIOB_Reg; #define GPIOB ((GPIOB_Reg*) 0x40010C00) #define LED_CLK 3 #define LED_GPIO GPIOB #define LED_PIN 5 #endif 创建 makefile ：\nTARGET := led BUILD_DIR := ./Build C_SRC := main.c C_OBJ := main.o CP_FLAGS := -mcpu=cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP LD_FLAGS := -mcpu=cortex-m3 -specs=nano.specs -T script.ld -Wl,--gc-sections .PHONY: all all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin @echo \"Done\" %.hex: %.elf arm-none-eabi-objcopy -O ihex $\u003c $@ %.bin: %.elf arm-none-eabi-objcopy -O binary -S $\u003c $@ %.elf: $(BUILD_DIR)/$(C_OBJ) arm-none-eabi-gcc $(LD_FLAGS) $\u003c -o $@ $(BUILD_DIR)/%.o: %.c arm-none-eabi-gcc -c $(CP_FLAGS) $\u003c -o $@ $(BUILD_DIR): mkdir -p $@ clean: rm $(BUILD_DIR) -rf install: st-flash write $(BUILD_DIR)/$(TARGET).bin 0x08000000 -include $(BUILD_DIR)/*.d 现在你的目录下有这几个文件：\n$ ls main.c makefile registers.h script.ld 编译代码：\n$ make mkdir -p Build arm-none-eabi-gcc -c -mcpu=cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP main.c -o Build/main.o arm-none-eabi-gcc -mcpu=cortex-m3 -specs=nano.specs -T script.ld -Wl,--gc-sections Build/main.o -o Build/led.elf arm-none-eabi-objcopy -O ihex Build/led.elf Build/led.hex arm-none-eabi-objcopy -O binary -S Build/led.elf Build/led.bin Done $ ls Build/ led.bin led.elf led.hex main.d main.o 查看 led.bin 文件：\n$ hexdump Build/led.bin 0000000 0000 2001 0011 0800 b5f8 bf00 b5f8 bf00 0000010 4a06 6993 f043 0308 6193 4b05 681a f442 0000020 1240 601a 2220 615a e7fe bf00 1000 4002 0000030 0c00 4001 前面 8 个字节 0000 2001 0011 0800，我们将数据从小端转换为大端就是：2001 0000 ，0800 0011\n第一个就是我们在链接脚本中设置的栈顶地址 0x20010000\n第二个很可能就是 main 函数的地址 0x08000011\n再执行一个命令：\n$ arm-none-eabi-objdump -D Build/led.elf 08000010 : 8000010: 4a06 ldr r2, [pc, #24] @ (800002c ) 8000012: 6993 ldr r3, [r2, #24] main 函数的实际地址在 0x08000010 处，记得我们之前对它进行或运算吗，main 函数的实际地址并未改变，只是调用方式不同。\nMEMORY 在链接脚本中，我们可以定义一个名为 MEMORY 的块（只能存在一个）。在这个块中，我们可以定义常用的内存区域，FLASH 和 SRAM：\nMEMORY { /* 名称 读写属性 起始地址 大小 */ FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 128K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 20K } ENTRY(main); SECTIONS { .text : { LONG(0x20010000); LONG(main | 1); *(.text) } \u003e FLASH .data : { *(.data) } \u003e SRAM } 上面做了一些改动：\n增加了 MEMORY 块 删除了位置计数器 告诉链接器把 .text 放到 FLASH 中去： \u003e FLASH 增加了 .data 段，可以存放变量 告诉链接器把 .data 放到 SRAM 中去： \u003e SRAM 现在，我们再 main.c 中添加一个全局变量：int a = 0xDEADBEEF，看看它会被放在哪里:\n#include \"registers.h\" int a = 0xDEADBEEF; int main(void) { a = 0; RCC-\u003eAPB2ENR |= (1 \u003c\u003c LED_CLK); LED_GPIO-\u003eCRL |= (3 \u003c\u003c (LED_PIN * 4)); LED_GPIO-\u003eBRR = (1 \u003c\u003c LED_PIN); while (1); } $ arm-none-eabi-objdump -D Build/led.elf Disassembly of section .data.a: 20000000 : 20000000: deadbeef cdple 14, 10, cr11, cr13, cr15, {7} 可以看到地址是 20000000，全局变量成功被放置在 SRAM 中。\n最后再来看一下 bin 文件：\n$ hexdump Build/led.bin 0000000 0000 2001 0011 0800 b5f8 bf00 b5f8 bf00 0000010 2200 4b09 601a f102 4280 f502 3204 6993 0000020 f043 0308 6193 4b05 681a f042 0203 601a 0000030 2201 615a e7fe bf00 0000 2000 0c00 4001 0000040 beef dead 0000044 结束，未完\n","wordCount":"738","inLanguage":"en","datePublished":"2022-06-01T00:00:00Z","dateModified":"2022-06-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>从零编写 STM32 链接脚本</h1><div class=post-meta><span title='2022-06-01 00:00:00 +0000 UTC'>June 1, 2022</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%a1%ac%e4%bb%b6%e5%b9%b3%e5%8f%b0 aria-label=硬件平台>硬件平台</a></li><li><a href=#%e5%87%86%e5%a4%87%e5%b7%a5%e5%85%b7 aria-label=准备工具>准备工具</a></li><li><a href=#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86 aria-label=预备知识>预备知识</a><ul><li><a href=#stm32-%e5%90%af%e5%8a%a8%e6%a8%a1%e5%bc%8f aria-label="STM32 启动模式">STM32 启动模式</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84 aria-label=内存映射>内存映射</a></li></ul></li><li><a href=#%e5%bc%80%e5%a7%8b%e7%bc%96%e5%86%99 aria-label=开始编写>开始编写</a><ul><li><a href=#%e6%9c%80%e7%ae%80%e5%8d%95%e7%9a%84%e9%93%be%e6%8e%a5%e8%84%9a%e6%9c%ac aria-label=最简单的链接脚本>最简单的链接脚本</a></li><li><a href=#memory aria-label=MEMORY>MEMORY</a></li></ul></li></ul></div></details></div><div class=post-content><ul><li>参考文章：<ul><li><a href=https://itachi.pl/hardware/writing_linker_script_for_stm32_from_scratch>Writing linker script for STM32 from scratch</a></li><li><a href=https://www.cnblogs.com/jianhua1992/p/16852784.html>链接脚本(Linker Scripts)语法和规则解析</a></li><li><a href=https://blog.csdn.net/weixin_39177986/article/details/108455827>LD链接脚本解析</a></li></ul></li></ul><h2 id=硬件平台>硬件平台<a hidden class=anchor aria-hidden=true href=#硬件平台>#</a></h2><p>STM32F103ZET6 野火霸道开发板 V2</p><h2 id=准备工具>准备工具<a hidden class=anchor aria-hidden=true href=#准备工具>#</a></h2><p>ARM GCC 工具链，参考此文安装：<a href=../linux-stm32-development/>Linux 下搭建 STM32 开发环境</a></p><h2 id=预备知识>预备知识<a hidden class=anchor aria-hidden=true href=#预备知识>#</a></h2><h3 id=stm32-启动模式>STM32 启动模式<a hidden class=anchor aria-hidden=true href=#stm32-启动模式>#</a></h3><table><thead><tr><th>BOOT0</th><th>BOOT1</th><th>启动方式</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>内部flash，用户程序</td></tr><tr><td>1</td><td>0</td><td>系统存储器，BootLoader</td></tr><tr><td>0</td><td>1</td><td>内部SRAM，程序调试</td></tr></tbody></table><h3 id=内存映射>内存映射<a hidden class=anchor aria-hidden=true href=#内存映射>#</a></h3><div align=left><img src=1.png style=max-height:350px></img></div><p>FLASH 起始地址是 <code>0x0800 0000</code>，SRAM 起始地址是 <code>0x2000 0000</code></p><p>参考手册 <code>Boot configuration</code> 一节有这样一段话：</p><div align=left><img src=2.png style=max-height:80px></img></div><p>上电后，CPU 从地址 <code>0x0000 0000</code> 获取栈顶地址，然后从地址 <code>0x0000 0004</code> 处开始执行代码</p><div align=left><img src=3.png style=max-height:130px></img></div><p>当 CPU 从地址 <code>0x00000000</code> 读取数据，它实际上可能会访问不同的存储器，具体取决于所选的启动模式。这称为 <code>内存映射</code>。默认情况下，STM32 从 FLASH 启动，所以它将内存区域 <code>0x08000000</code> 映射到 <code>0x00000000</code>；然后就可以从其原始地址 <code>0x08000000</code> 或 <code>0x00000000</code> 访问 FLASH。这允许 CPU 直接从 FLASH 开始读取指令。</p><p>大多数情况下，在芯片启动时需要设置堆栈指针，不同架构的平台方法也不同。步骤很简单：找到存储堆栈地址的位置，将该地址设置为栈顶地址。逻辑上来说，栈空间是从上往下增长的，所以它需要足够的空间（指定大小）。</p><blockquote><p><code>0x0000 0000</code> 中的值会被加载到 SP 寄存器，<code>0x0000 0004</code> 中的值会被加载到 PC 寄存器</p></blockquote><h2 id=开始编写>开始编写<a hidden class=anchor aria-hidden=true href=#开始编写>#</a></h2><h3 id=最简单的链接脚本>最简单的链接脚本<a hidden class=anchor aria-hidden=true href=#最简单的链接脚本>#</a></h3><p>链接文件由一个称为 <code>SECTIONS</code> 的块组成。在此块中，你定义的段将被分配到二进制文件中。</p><ul><li>最重要的段是：<ul><li><code>.test</code> - 包含你的代码</li><li><code>.data</code> - 包含已初始化的全局/静态变量</li><li><code>.bss</code> - 包含未初始化的全局/静态变量</li></ul></li></ul><p>我们的第一个脚本，将只使用 <code>.text</code> 。没有数据，没有变量，只有纯代码。我们创建一个 <code>script.ld</code> 文件，写入下面的内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> <span class=p>{</span> <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>上面的脚本告诉链接器：<ol><li>创建一个 <code>.text</code> 段（冒号左边的部分）</li><li>获取目标文件中所有的 <code>.text</code> 段（花括号中的部分）</li><li>把第 2 步获取的段放到第 1 步创建的段中</li></ol></li></ul><p>我们定义了代码部分，但没有指定它放在哪里。根据之前讲述的内容，它应该被放到地址 <code>0x08000000</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> <span class=p>{</span> <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>链接脚本中的点 <code>.</code> 是位置计数器。它从 <code>0x0</code> 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 <code>.text</code> 段之后读取位置计数器的值，它的值将是 <code>0x08000000</code> 加上你添加的段的大小。</p><p>好了，我们的代码有了一个正确的位置，接下来只要知道入口程序地址以及堆栈地址：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>ENTRY</span><span class=p>(</span><span class=n>main</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>   <span class=c1>// BYTE，SHORT，LONG，QUAD 命令分别存储 1，2，4，8 字节
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>LONG</span><span class=p>(</span><span class=mh>0x20010000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=n>main</span> <span class=o>|</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当 STM32 启动时，它会从 FLASH 读取两个地址（共 8 字节）。第一个是栈顶地址，第二个是入口程序地址。</p><ul><li><p><code>ENTRY(main)</code> 告诉链接器应该使用哪个符号作为程序的入口点。这也可以防止包含 <code>main</code> 函数的 <code>.text</code> 部分被链接器作为垃圾丢弃。</p></li><li><p><code>LONG(0x20010000)</code> 告诉链接器将 <code>0x20010000</code> 这四个字节放入输出的二进制文件中。为什么是这四个字节？因为 SRAM 地址从 <code>0x20000000</code> 开始，大小有 64KB（0x10000）。 <code>0x20000000 + 0x10000 = 0x20010000</code> 就是栈顶的地址。</p></li><li><p><code>LONG(main | 1)</code> 将 main 函数的地址输出到二进制文件中。如你所见，main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 切换到 thumb 模式，而不是表示 ARM 模式的偶数地址。</p></li></ul><p>好了，我们有了一个链接器脚本，再创建 <code>main.c</code> 来点亮开发板上的红色 LED ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;registers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 开启 GPIOB 时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span>  <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_CLK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 配置引脚推挽输出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>CRL</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>LED_PIN</span> <span class=o>*</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 引脚输出低电平
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>创建头文件 <code>registers.h</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef __REGISTERS_H
</span></span></span><span class=line><span class=cl><span class=cp>#define __REGISTERS_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CFGR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CIR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB2RSTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB1RSTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>AHBENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB2ENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB1ENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BDCR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CSR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>RCC_Reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define RCC ((RCC_Reg*) 0x40021000)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CRL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CRH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>IDR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>ODR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BSRR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BRR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>LCKR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>GPIOB_Reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define GPIOB ((GPIOB_Reg*) 0x40010C00)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define LED_CLK     3
</span></span></span><span class=line><span class=cl><span class=cp>#define LED_GPIO    GPIOB
</span></span></span><span class=line><span class=cl><span class=cp>#define LED_PIN     5
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>创建 <code>makefile</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>TARGET</span>    <span class=o>:=</span> led
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>BUILD_DIR</span> <span class=o>:=</span> ./Build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>C_SRC</span> <span class=o>:=</span> main.c
</span></span><span class=line><span class=cl><span class=nv>C_OBJ</span> <span class=o>:=</span> main.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>CP_FLAGS</span> <span class=o>:=</span> -mcpu<span class=o>=</span>cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP
</span></span><span class=line><span class=cl><span class=nv>LD_FLAGS</span> <span class=o>:=</span> -mcpu<span class=o>=</span>cortex-m3 -specs<span class=o>=</span>nano.specs -T script.ld  -Wl,--gc-sections
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>all</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>elf</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>hex</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>bin</span>
</span></span><span class=line><span class=cl>        @echo <span class=s2>&#34;Done&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.hex</span><span class=o>:</span> %.<span class=n>elf</span>
</span></span><span class=line><span class=cl>        arm-none-eabi-objcopy -O ihex $&lt; <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.bin</span><span class=o>:</span> %.<span class=n>elf</span>
</span></span><span class=line><span class=cl>        arm-none-eabi-objcopy -O binary -S $&lt; <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.elf</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>C_OBJ</span><span class=k>)</span>
</span></span><span class=line><span class=cl>        arm-none-eabi-gcc <span class=k>$(</span>LD_FLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(BUILD_DIR)/%.o</span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>        arm-none-eabi-gcc -c <span class=k>$(</span>CP_FLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(BUILD_DIR)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        mkdir -p <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        rm <span class=k>$(</span>BUILD_DIR<span class=k>)</span> -rf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>install</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        st-flash write <span class=k>$(</span>BUILD_DIR<span class=k>)</span>/<span class=k>$(</span>TARGET<span class=k>)</span>.bin 0x08000000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>-include</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span><span class=err>/*.d</span>
</span></span></code></pre></div><p>现在你的目录下有这几个文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> ls
</span></span><span class=line><span class=cl><span class=go>main.c  makefile  registers.h  script.ld
</span></span></span></code></pre></div><p>编译代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=go>mkdir -p Build
</span></span></span><span class=line><span class=cl><span class=go>arm-none-eabi-gcc -c -mcpu=cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP main.c -o Build/main.o
</span></span></span><span class=line><span class=cl><span class=go>arm-none-eabi-gcc -mcpu=cortex-m3 -specs=nano.specs -T script.ld  -Wl,--gc-sections Build/main.o -o Build/led.elf
</span></span></span><span class=line><span class=cl><span class=go>arm-none-eabi-objcopy -O ihex Build/led.elf Build/led.hex
</span></span></span><span class=line><span class=cl><span class=go>arm-none-eabi-objcopy -O binary -S Build/led.elf Build/led.bin
</span></span></span><span class=line><span class=cl><span class=go>Done
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> ls Build/
</span></span><span class=line><span class=cl><span class=go>led.bin  led.elf  led.hex  main.d  main.o 
</span></span></span></code></pre></div><p>查看 <code>led.bin</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> hexdump Build/led.bin
</span></span><span class=line><span class=cl><span class=go>0000000 0000 2001 0011 0800 b5f8 bf00 b5f8 bf00
</span></span></span><span class=line><span class=cl><span class=go>0000010 4a06 6993 f043 0308 6193 4b05 681a f442
</span></span></span><span class=line><span class=cl><span class=go>0000020 1240 601a 2220 615a e7fe bf00 1000 4002
</span></span></span><span class=line><span class=cl><span class=go>0000030 0c00 4001
</span></span></span></code></pre></div><p>前面 8 个字节 <code>0000 2001 0011 0800</code>，我们将数据从小端转换为大端就是：<code>2001 0000</code> ，<code>0800 0011</code></p><p>第一个就是我们在链接脚本中设置的栈顶地址 <code>0x20010000</code></p><p>第二个很可能就是 main 函数的地址 <code>0x08000011</code></p><p>再执行一个命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> arm-none-eabi-objdump -D Build/led.elf
</span></span><span class=line><span class=cl><span class=go>08000010 &lt;main&gt;:
</span></span></span><span class=line><span class=cl><span class=go> 8000010:       4a06            ldr     r2, [pc, #24]   @ (800002c &lt;main+0x1c&gt;)
</span></span></span><span class=line><span class=cl><span class=go> 8000012:       6993            ldr     r3, [r2, #24]
</span></span></span></code></pre></div><p>main 函数的实际地址在 <code>0x08000010</code> 处，记得我们之前对它进行或运算吗，main 函数的实际地址并未改变，只是调用方式不同。</p><h3 id=memory>MEMORY<a hidden class=anchor aria-hidden=true href=#memory>#</a></h3><p>在链接脚本中，我们可以定义一个名为 MEMORY 的块（只能存在一个）。在这个块中，我们可以定义常用的内存区域，FLASH 和 SRAM：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>MEMORY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=cm>/* 名称   读写属性  起始地址               大小 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>FLASH</span>   <span class=p>(</span><span class=n>RX</span><span class=p>)</span> <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>128</span><span class=n>K</span>
</span></span><span class=line><span class=cl>    <span class=nf>SRAM</span>    <span class=p>(</span><span class=n>RW</span><span class=p>)</span> <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x20000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>20</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ENTRY</span><span class=p>(</span><span class=n>main</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=mh>0x20010000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=n>main</span> <span class=o>|</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span> <span class=n>FLASH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>data</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span> <span class=n>SRAM</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面做了一些改动：</p><ul><li>增加了 MEMORY 块</li><li>删除了位置计数器</li><li>告诉链接器把 <code>.text</code> 放到 FLASH 中去： <code>> FLASH</code></li><li>增加了 <code>.data</code> 段，可以存放变量</li><li>告诉链接器把 <code>.data</code> 放到 SRAM 中去： <code>> SRAM</code></li></ul><p>现在，我们再 main.c 中添加一个全局变量：<code>int a = 0xDEADBEEF</code>，看看它会被放在哪里:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;registers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0xDEADBEEF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span>  <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_CLK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>CRL</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>LED_PIN</span> <span class=o>*</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> arm-none-eabi-objdump -D Build/led.elf
</span></span><span class=line><span class=cl><span class=go>Disassembly of section .data.a:
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>20000000 &lt;a&gt;:
</span></span></span><span class=line><span class=cl><span class=go>20000000:       deadbeef        cdple   14, 10, cr11, cr13, cr15, {7}
</span></span></span></code></pre></div><p>可以看到地址是 <code>20000000</code>，全局变量成功被放置在 SRAM 中。</p><p>最后再来看一下 bin 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> hexdump Build/led.bin 
</span></span><span class=line><span class=cl><span class=go>0000000 0000 2001 0011 0800 b5f8 bf00 b5f8 bf00
</span></span></span><span class=line><span class=cl><span class=go>0000010 2200 4b09 601a f102 4280 f502 3204 6993
</span></span></span><span class=line><span class=cl><span class=go>0000020 f043 0308 6193 4b05 681a f042 0203 601a
</span></span></span><span class=line><span class=cl><span class=go>0000030 2201 615a e7fe bf00 0000 2000 0c00 4001
</span></span></span><span class=line><span class=cl><span class=go>0000040 beef dead                              
</span></span></span><span class=line><span class=cl><span class=go>0000044
</span></span></span></code></pre></div><p><strong>结束，未完</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/stm32/>stm32</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>