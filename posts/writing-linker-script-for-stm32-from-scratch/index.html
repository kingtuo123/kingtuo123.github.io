<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从零编写 STM32 链接脚本 | King's Blog</title>
<meta name=keywords content="stm32"><meta name=description content="writing linker script for stm32 from scratch"><meta name=author content><link rel=canonical href=https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/><link crossorigin=anonymous href=/assets/css/stylesheet.3fb4ecf6a2a81497f9b20e665e86d11433da1313db1d8c2d46c26dd61e1a1d3a.css integrity="sha256-P7Ts9qKoFJf5sg5mXobRFDPaExPbHYwtRsJt1h4aHTo=" rel="preload stylesheet" as=style><link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="从零编写 STM32 链接脚本"><meta property="og:description" content="writing linker script for stm32 from scratch"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="从零编写 STM32 链接脚本"><meta name=twitter:description content="writing linker script for stm32 from scratch"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"从零编写 STM32 链接脚本","item":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零编写 STM32 链接脚本","name":"从零编写 STM32 链接脚本","description":"writing linker script for stm32 from scratch","keywords":["stm32"],"articleBody":"参考文章\nWriting linker script for STM32 from scratch 链接脚本(Linker Scripts)语法和规则解析 LD链接脚本解析 链接脚本中 AT\u003e 的作用 LD 链接器 How to get the load address of .data section C代码中如何使用链接脚本中定义的变量 From Zero to main(): Bare metal C From Zero to main(): Demystifying Firmware Linker Scripts STM32的启动 硬件平台 STM32F103ZET6 野火霸道开发板 V2\n准备工具 ARM GCC 工具链，参考此文安装：Linux 下搭建 STM32 开发环境\n预备知识 STM32 启动模式 BOOT0 BOOT1 启动方式 0 X 内部flash，用户程序 1 0 系统存储器，BootLoader 0 1 内部SRAM，程序调试 存储映射 FLASH 起始地址是 0x08000000，SRAM 起始地址是 0x20000000\n参考手册 Boot configuration 一节有这样一段话：\n上电后，CPU 从地址 0x00000000 获取栈顶地址，然后从地址 0x00000004 处开始执行代码\n从 FLASH 启动时，CPU 将地址 0x00000000 映射到 0x08000000，然后 CPU 就可以从 0x00000000 读取 FLASH 上的数据，当然 0x08000000 依然是可以被 CPU 访问的。\n0x00000000 中的值会被加载到 SP 寄存器，0x00000004 中的值会被加载到 PC 寄存器\n开始编写 最简单的链接脚本 链接文件由一个称为 SECTIONS 的块组成。在此块中，你定义的段将被按顺序分配到二进制文件中。\n比较重要的段有：\n.text 包含你的代码 .rodata 包含 const 定义的常量数据 .data 包含已初始化的全局/静态变量 .bss 包含未初始化的全局/静态变量 第一个脚本，将只使用 .text 。没有数据，没有变量，只有纯代码。\n创建一个 script.ld 文件，写入下面的内容：\nSECTIONS { .text : { /* 星号是通配符 */ *(.text) *(.text*) } } 上面的脚本告诉链接器：\n创建一个 .text 段（冒号左边的部分） 获取目标文件中所有的 .text 段（花括号中的部分） 把第 2 步获取的段放到第 1 步创建的段中 虽然定义了代码部分，但没有指定它放在哪里。根据之前讲述的内容，它应该被放到地址 0x08000000：\nSECTIONS { . = 0x08000000; .text : { *(.text) *(.text*) } } 点 . 是位置计数器。它从 0x0 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 .text 段之后读取位置计数器的值，它的值将是 0x08000000 加上你添加的段的大小。\n接下来添加栈顶地址及入口程序地址：\nENTRY(main); SECTIONS { . = 0x08000000; .text : { /* BYTE，SHORT，LONG，QUAD 命令分别存储 1，2，4，8 字节 */ LONG(0x20010000); LONG(main | 1); *(.text) *(.text*) } } 当 STM32 启动时，它会从 FLASH 读取两个地址（共 8 字节）。第一个是栈顶地址，第二个是入口程序地址。\nENTRY(main) 告诉链接器使用 mian 作为程序的入口点。这也可以防止包含 main 函数的 .text 部分被链接器作为垃圾“优化”（因为 main 函数没有被其它函数调用）。\nLONG(0x20010000) 告诉链接器将 0x20010000 这四个字节放入输出的二进制文件中。为什么是这四个字节？因为 SRAM 地址从 0x20000000 开始，大小有 64KB（0x10000）。 0x20000000 + 0x10000 = 0x20010000 就是栈顶的地址。\nLONG(main | 1) 将 main 函数的地址输出到二进制文件中。main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 使用 thumb 指令集。\n疑问：SRAM 的范围是 0x20000000 - 0x2000FFFF，初始栈顶地址却是 0x20010000\n因为 CM3 使用的是向下生长的满栈，栈顶初始值必须是内存的末地址加 1\n满栈进栈是先移动指针再存数据\n接下来创建 main.c 来点亮开发板上的红色 LED ：\n#include \"registers.h\" // 由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余 int main(void) { // 开启 GPIOB 时钟 RCC-\u003eAPB2ENR |= (1 \u003c\u003c LED_CLK); // 配置 PB5 引脚推挽输出 LED_GPIO-\u003eCRL |= (3 \u003c\u003c (LED_PIN * 4)); // 引脚输出低电平 LED_GPIO-\u003eBRR = (1 \u003c\u003c LED_PIN); while (1); } 创建头文件 registers.h ：\n#ifndef __REGISTERS_H #define __REGISTERS_H #include typedef struct { uint32_t CR; uint32_t CFGR; uint32_t CIR; uint32_t APB2RSTR; uint32_t APB1RSTR; uint32_t AHBENR; uint32_t APB2ENR; uint32_t APB1ENR; uint32_t BDCR; uint32_t CSR; } RCC_Reg; #define RCC ((RCC_Reg*) 0x40021000) typedef struct { uint32_t CRL; uint32_t CRH; uint32_t IDR; uint32_t ODR; uint32_t BSRR; uint32_t BRR; uint32_t LCKR; } GPIOB_Reg; #define GPIOB ((GPIOB_Reg*) 0x40010C00) #define LED_CLK 3 #define LED_GPIO GPIOB #define LED_PIN 5 #endif 创建 makefile ：\nTARGET := led BUILD_DIR := ./Build C_SRC := main.c C_OBJ := main.o CP_FLAGS := -mcpu=cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP LD_FLAGS := -mcpu=cortex-m3 -specs=nano.specs -T script.ld -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--gc-sections .PHONY: all all: $(BUILD_DIR) $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin @echo \"Done\" %.elf: $(BUILD_DIR)/$(C_OBJ) arm-none-eabi-gcc $(LD_FLAGS) $\u003c -o $@ $(BUILD_DIR)/%.o: %.c arm-none-eabi-gcc -c $(CP_FLAGS) $\u003c -o $@ %.hex: %.elf arm-none-eabi-objcopy -O ihex $\u003c $@ %.bin: %.elf arm-none-eabi-objcopy -O binary -S $\u003c $@ $(BUILD_DIR): mkdir -p $@ clean: rm $(BUILD_DIR) -rf install: st-flash write $(BUILD_DIR)/$(TARGET).bin 0x08000000 -include $(BUILD_DIR)/*.d 现在目录下有这几个文件：\n$ ls main.c makefile registers.h script.ld 编译代码：\n$ make $ ls Build/ led.bin led.elf led.hex main.d main.o 查看 led.bin 文件：\n$ hexdump Build/led.bin 0000000 0000 2001 0009 0800 4a06 6993 f043 0308 0000010 6193 4b05 681a f442 1240 601a 2220 615a 0000020 e7fe bf00 1000 4002 0c00 4001 b5f8 bf00 0000030 b5f8 bf00 前面 8 个字节 0000 2001 0009 0800 数据从小端转换为大端就是：2001 0000 ，0800 0009\n第一个就是在链接脚本中设置的栈顶地址 0x20010000\n第二个很可能是 main 函数的地址 0x08000009，最后一位表示 thumb 指令集，所以实际应该是 0x08000008\n查看一下：\n$ arm-none-eabi-objdump -D Build/led.elf 08000008 : 8000008: 4a06 ldr r2, [pc, #24] @ (8000024 ) 8000012: 4b05 ldr r3, [pc, #20] @ (8000028 ) 最后下载程序，成功点亮 led，使用 stlink 烧录器和 st-flash 命令烧录（见 makefile）：\n$ make install 添加 .data MEMORY { /* 名称 (读/写/执行权限) 起始地址 大小 */ SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K } ENTRY(main); SECTIONS { .text : { LONG(0x20010000); LONG(main | 1); *(.text) *(.text*) } \u003eFLASH .data : { *(.data) *(.data*) /* AT\u003e 指令用于指定这个段的加载内存地址 */ } \u003eSRAM AT\u003e FLASH } 相较之前做了这些改动：\n增加了 MEMORY 块，定义了两个区域 FLASH 和 SRAM 增加了 .data 段，可以存放已初始化的全局/静态变量 删除了位置计数器 \u003eFLASH 表示将 .text 段放到 FLASH 中 \u003eSRAM AT\u003e FLASH 表示 .data 段的 VMA 在 SRAM 中，LMA 在 FLASH 中 VMA（虚拟内存地址）：程序运行时的地址，即堆栈上的地址。\nLMA（加载内存地址）：程序数据存储的地址，比如已初始化的全局变量的值在 FLASH 中存储的地址就是 LMA ，当这个值被加载到 SRAM 中栈上的地址就是 VMA 。\n简单来说：LMA 是在 ROM 中的地址，VMA 是在 RAM 中的地址。\n.text 没有使用 AT\u003e 指定 LMA，所以它的 LMA = VMA\n修改一下 main.c 并添加一个全局变量：int a = 0xAAAABBBB，\n#include \"registers.h\" int a = 0xAAAABBBB; int main(void) { RCC-\u003eAPB2ENR |= (1 \u003c\u003c LED_CLK); LED_GPIO-\u003eCRL |= (3 \u003c\u003c (LED_PIN * 4)); LED_GPIO-\u003eBSRR = (1 \u003c\u003c LED_PIN); if(a == 0xAAAABBBB){ // 点亮 LED LED_GPIO-\u003eBRR = (1 \u003c\u003c LED_PIN); } while (1); } 看看 a 会被放在哪里：\n$ arm-none-eabi-objdump -D Build/led.elf Disassembly of section .data.a: 20000000 : 20000000: aaaabbbb bge 1eaaeef4 $ arm-none-eabi-objdump -h Build/led.elf Build/led.elf: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000008 08000000 08000000 00001000 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE ... 4 .data.a 00000004 20000000 08000048 00002000 2**2 CONTENTS, ALLOC, LOAD, DATA ... 可以看到 a 的 VMA = 20000000，LMA = 08000048\n也就是说 a 存储在 FLASH 的 0x08000048 地址处\n此时写入程序，发现 led 不点亮，因为 a 的值不会自己从 0x08000048 跑到 0x20000000 地址处， 所以还需要编写代码完成这个操作。\n初始化 .data 初始化 .data 段，就是把 .data 中的数据搬运到栈中，我们需要知道 .data 的地址和栈的地址\n先修改一下链接脚本：\nMEMORY { SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 64K FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K } ENTRY(Reset_Handler); SECTIONS { .text : { LONG(0x20010000); /* 修改了入口函数 */ LONG(Reset_Handler | 1); *(.text) *(.text*) } \u003eFLASH /* 获取 .data 在 FLASH 上起始位置的加载内存地址 LMA */ _sidata = LOADADDR(.data); .data : { /* 获取 .data 在栈上的起始位置的虚拟内存地址 VMA*/ _sdata = .; *(.data) *(.data*) /* 获取 .data 在栈上的结束位置的虚拟内存地址 VMA */ _edata = .; } \u003eSRAM AT\u003e FLASH } 现在通过变量 _sidata，_sdata，_edata 就能获取 .data 的 LMA 和 VMA，接下来需要在 main 函数运行之前把数据搬运过去，我们把数据搬运的工作交给 Reset_Handler 这个函数。\n修改 main.c 如下：\n#include \"registers.h\" extern int _sidata, _sdata, _edata; int a = 0xAAAABBBB; int main(void) { RCC-\u003eAPB2ENR |= (1 \u003c\u003c LED_CLK); LED_GPIO-\u003eCRL |= (3 \u003c\u003c (LED_PIN * 4)); LED_GPIO-\u003eBSRR = (1 \u003c\u003c LED_PIN); if(a == 0xAAAABBBB){ // 点亮 LED LED_GPIO-\u003eBRR = (1 \u003c\u003c LED_PIN); } while (1); } void Reset_Handler(void){ // LMA int* init_data = \u0026_sidata; // VMA int* stack_ptr = \u0026_sdata; while(stack_ptr \u003c \u0026_edata){ // 搬运数据 *stack_ptr++ = *init_data++; } main(); } 通过 Reset_Handler 函数初始化 .data 后，再调用 main 主函数。\nOK，成功点亮 LED ！\n类似的，初始化 .bss 更简单，只需要将 .bss 在栈上的区域赋值为 0 即可。\nST 标准库启动文件 gcc_ride7/startup_stm32f10x_hd.s arm/startup_stm32f10x_hd.s 对于 gcc 编译器，堆栈初始化在 Reset_Handler 中进行，最后会调用 mian 函数：\nReset_Handler: /* Copy the data segment initializers from flash to SRAM */ movs r1, #0 b LoopCopyDataInit ... LoopFillZerobss: ldr r3, = _ebss cmp r2, r3 bcc FillZerobss /* Call the clock system intitialization function.*/ bl SystemInit /* Call the application's entry point.*/ bl main bx lr 对于 ARM CC（Keil 自带的编译器 AC5）Reset_Handler 是调用 C 库提供的 __mian 函数初始化堆栈，__main 再调用用户的 main 函数：\n; Reset handler Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT __main IMPORT SystemInit ; 调用 SystemInit 配置系统时钟 LDR R0, =SystemInit BLX R0 ; 调用 __main LDR R0, =__main BX R0 ENDP ","wordCount":"1106","inLanguage":"en","datePublished":"2023-08-12T00:00:00Z","dateModified":"2023-08-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/writing-linker-script-for-stm32-from-scratch/"},"publisher":{"@type":"Organization","name":"King's Blog","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox=".5 1 15 15" fill="none" stroke="currentcolor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round"><rect height="3.5" width="12.5" y="2.75" x="1.75"/><path d="m6.75 9.25h2.5m-6.5-2.5v7.5h10.5v-7.5"/></svg></span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox=".5 .5 23 23" fill="none" stroke="currentcolor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg></span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="1 0 15 15" fill="none" stroke="currentcolor" stroke-width="1.1" stroke-linecap="round" stroke-linejoin="round" transform="matrix(-1,0,0,1,0,0)"><polygon points="7.25 14.25,1.75 8.75,8.75 1.75,14.25 1.75,14.25 7.25"/><circle cx="11" cy="5" r=".5" fill="#000"/></svg></span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/>&nbsp;
<span class=menu-logo><svg class="logo-svg" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-4.4857-4.4935M19 10.5c0 4.6944-3.8056 8.5-8.5 8.5C5.80558 19 2 15.1944 2 10.5 2 5.80558 5.80558 2 10.5 2 15.1944 2 19 5.80558 19 10.5z"/></svg></span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">从零编写 STM32 链接脚本</h1><div class=post-meta><span title='2023-08-12 00:00:00 +0000 UTC'>August 12, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%a1%ac%e4%bb%b6%e5%b9%b3%e5%8f%b0 aria-label=硬件平台>硬件平台</a></li><li><a href=#%e5%87%86%e5%a4%87%e5%b7%a5%e5%85%b7 aria-label=准备工具>准备工具</a></li><li><a href=#%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86 aria-label=预备知识>预备知识</a><ul><li><a href=#stm32-%e5%90%af%e5%8a%a8%e6%a8%a1%e5%bc%8f aria-label="STM32 启动模式">STM32 启动模式</a></li><li><a href=#%e5%ad%98%e5%82%a8%e6%98%a0%e5%b0%84 aria-label=存储映射>存储映射</a></li></ul></li><li><a href=#%e5%bc%80%e5%a7%8b%e7%bc%96%e5%86%99 aria-label=开始编写>开始编写</a><ul><li><a href=#%e6%9c%80%e7%ae%80%e5%8d%95%e7%9a%84%e9%93%be%e6%8e%a5%e8%84%9a%e6%9c%ac aria-label=最简单的链接脚本>最简单的链接脚本</a></li><li><a href=#%e6%b7%bb%e5%8a%a0-data aria-label="添加 .data">添加 .data</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96-data aria-label="初始化 .data">初始化 .data</a></li></ul></li><li><a href=#st-%e6%a0%87%e5%87%86%e5%ba%93%e5%90%af%e5%8a%a8%e6%96%87%e4%bb%b6 aria-label="ST 标准库启动文件">ST 标准库启动文件</a></li></ul></div></details></div><div class=post-content><p>参考文章</p><ul><li><a href=https://itachi.pl/hardware/writing_linker_script_for_stm32_from_scratch>Writing linker script for STM32 from scratch</a></li><li><a href=https://www.cnblogs.com/jianhua1992/p/16852784.html>链接脚本(Linker Scripts)语法和规则解析</a></li><li><a href=https://blog.csdn.net/weixin_39177986/article/details/108455827>LD链接脚本解析</a></li><li><a href=https://www.cnblogs.com/LogicBai/p/16982841.html>链接脚本中 AT> 的作用</a></li><li><strong><a href=https://sourceware.org/binutils/docs/ld/index.html>LD 链接器</a></strong></li><li><a href=https://stackoverflow.com/questions/68670510/avr-gnu-linker-script-how-to-get-the-load-address-of-data-section>How to get the load address of .data section</a></li><li><a href=https://cloud.tencent.com/developer/article/1709022>C代码中如何使用链接脚本中定义的变量</a></li><li><a href=https://interrupt.memfault.com/blog/zero-to-main-1>From Zero to main(): Bare metal C</a></li><li><a href=https://interrupt.memfault.com/blog/how-to-write-linker-scripts-for-firmware>From Zero to main(): Demystifying Firmware Linker Scripts</a></li><li><a href=https://www.cnblogs.com/The-explosion/p/13652387.html>STM32的启动</a></li></ul><h2 id=硬件平台>硬件平台<a hidden class=anchor aria-hidden=true href=#硬件平台>#</a></h2><p>STM32F103ZET6 野火霸道开发板 V2</p><h2 id=准备工具>准备工具<a hidden class=anchor aria-hidden=true href=#准备工具>#</a></h2><p>ARM GCC 工具链，参考此文安装：<a href=../linux-stm32-development/>Linux 下搭建 STM32 开发环境</a></p><h2 id=预备知识>预备知识<a hidden class=anchor aria-hidden=true href=#预备知识>#</a></h2><h3 id=stm32-启动模式>STM32 启动模式<a hidden class=anchor aria-hidden=true href=#stm32-启动模式>#</a></h3><table><thead><tr><th>BOOT0</th><th>BOOT1</th><th>启动方式</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>内部flash，用户程序</td></tr><tr><td>1</td><td>0</td><td>系统存储器，BootLoader</td></tr><tr><td>0</td><td>1</td><td>内部SRAM，程序调试</td></tr></tbody></table><h3 id=存储映射>存储映射<a hidden class=anchor aria-hidden=true href=#存储映射>#</a></h3><div align=left><img src=1.png style=max-height:350px></img></div><p>FLASH 起始地址是 <code>0x08000000</code>，SRAM 起始地址是 <code>0x20000000</code></p><p>参考手册 <code>Boot configuration</code> 一节有这样一段话：</p><div align=left><img src=2.png style=max-height:80px></img></div><p>上电后，CPU 从地址 <code>0x00000000</code> 获取栈顶地址，然后从地址 <code>0x00000004</code> 处开始执行代码</p><div align=left><img src=3.png style=max-height:130px></img></div><p>从 FLASH 启动时，CPU 将地址 <code>0x00000000</code> 映射到 <code>0x08000000</code>，然后 CPU 就可以从 <code>0x00000000</code> 读取 FLASH 上的数据，当然 <code>0x08000000</code> 依然是可以被 CPU 访问的。</p><blockquote><p><code>0x00000000</code> 中的值会被加载到 SP 寄存器，<code>0x00000004</code> 中的值会被加载到 PC 寄存器</p></blockquote><h2 id=开始编写>开始编写<a hidden class=anchor aria-hidden=true href=#开始编写>#</a></h2><h3 id=最简单的链接脚本>最简单的链接脚本<a hidden class=anchor aria-hidden=true href=#最简单的链接脚本>#</a></h3><p>链接文件由一个称为 <code>SECTIONS</code> 的块组成。在此块中，你定义的段将被按顺序分配到二进制文件中。</p><p>比较重要的段有：</p><table><tbody><tr><td>.text</td><td>包含你的代码</td></tr><tr><td>.rodata</td><td>包含 const 定义的常量数据</td></tr><tr><td>.data</td><td>包含已初始化的全局/静态变量</td></tr><tr><td>.bss</td><td>包含未初始化的全局/静态变量</td></tr></tbody></table><p>第一个脚本，将只使用 <code>.text</code> 。没有数据，没有变量，只有纯代码。</p><p>创建一个 <code>script.ld</code> 文件，写入下面的内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=cm>/* 星号是通配符 */</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面的脚本告诉链接器：</p><ol><li>创建一个 <code>.text</code> 段（冒号左边的部分）</li><li>获取目标文件中所有的 <code>.text</code> 段（花括号中的部分）</li><li>把第 2 步获取的段放到第 1 步创建的段中</li></ol><p>虽然定义了代码部分，但没有指定它放在哪里。根据之前讲述的内容，它应该被放到地址 <code>0x08000000</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>点 <code>.</code> 是位置计数器。它从 <code>0x0</code> 开始，可以直接修改，如上所示。也可以通过添加段、常量等间接修改。因此，如果你在 <code>.text</code> 段之后读取位置计数器的值，它的值将是 <code>0x08000000</code> 加上你添加的段的大小。</p><p>接下来添加栈顶地址及入口程序地址：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>ENTRY</span><span class=p>(</span><span class=n>main</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>   <span class=cm>/* BYTE，SHORT，LONG，QUAD 命令分别存储 1，2，4，8 字节 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=mh>0x20010000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=n>main</span> <span class=o>|</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当 STM32 启动时，它会从 FLASH 读取两个地址（共 8 字节）。第一个是栈顶地址，第二个是入口程序地址。</p><ul><li><p><code>ENTRY(main)</code> 告诉链接器使用 mian 作为程序的入口点。这也可以防止包含 main 函数的 <code>.text</code> 部分被链接器作为垃圾“优化”（因为 main 函数没有被其它函数调用）。</p></li><li><p><code>LONG(0x20010000)</code> 告诉链接器将 <code>0x20010000</code> 这四个字节放入输出的二进制文件中。为什么是这四个字节？因为 SRAM 地址从 <code>0x20000000</code> 开始，大小有 64KB（0x10000）。 <code>0x20000000 + 0x10000 = 0x20010000</code> 就是栈顶的地址。</p></li><li><p><code>LONG(main | 1)</code> 将 main 函数的地址输出到二进制文件中。main 与 1 做了或运算生成一个奇数值。在 ARM 体系结构中，函数地址是奇数（最后一位是1）告诉 CPU 使用 thumb 指令集。</p></li></ul><blockquote><p>疑问：SRAM 的范围是 <code>0x20000000</code> - <code>0x2000FFFF</code>，初始栈顶地址却是 <code>0x20010000</code></p><p>因为 CM3 使用的是向下生长的满栈，栈顶初始值必须是内存的末地址加 1</p><p>满栈进栈是先移动指针再存数据</p></blockquote><p>接下来创建 <code>main.c</code> 来点亮开发板上的红色 LED ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;registers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 由于没有配置时钟源，STM32 将使用内部 8 MHz RC 振荡器，这对于这个简单的项目来说绰绰有余
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 开启 GPIOB 时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span>  <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_CLK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 配置 PB5 引脚推挽输出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>CRL</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>LED_PIN</span> <span class=o>*</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 引脚输出低电平
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>创建头文件 <code>registers.h</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef __REGISTERS_H
</span></span></span><span class=line><span class=cl><span class=cp>#define __REGISTERS_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CFGR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CIR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB2RSTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB1RSTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>AHBENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB2ENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>APB1ENR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BDCR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CSR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>RCC_Reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define RCC ((RCC_Reg*) 0x40021000)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CRL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>CRH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>IDR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>ODR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BSRR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>BRR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>LCKR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>GPIOB_Reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define GPIOB ((GPIOB_Reg*) 0x40010C00)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define LED_CLK     3
</span></span></span><span class=line><span class=cl><span class=cp>#define LED_GPIO    GPIOB
</span></span></span><span class=line><span class=cl><span class=cp>#define LED_PIN     5
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>创建 <code>makefile</code> ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>TARGET</span>    <span class=o>:=</span> led
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>BUILD_DIR</span> <span class=o>:=</span> ./Build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>C_SRC</span> <span class=o>:=</span> main.c
</span></span><span class=line><span class=cl><span class=nv>C_OBJ</span> <span class=o>:=</span> main.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>CP_FLAGS</span> <span class=o>:=</span> -mcpu<span class=o>=</span>cortex-m3 -mthumb -Os -Wall -fdata-sections -ffunction-sections -MMD -MP
</span></span><span class=line><span class=cl><span class=nv>LD_FLAGS</span> <span class=o>:=</span> -mcpu<span class=o>=</span>cortex-m3 -specs<span class=o>=</span>nano.specs -T script.ld  -Wl,-Map<span class=o>=</span><span class=k>$(</span>BUILD_DIR<span class=k>)</span>/<span class=k>$(</span>TARGET<span class=k>)</span>.map,--gc-sections
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>all</span>
</span></span><span class=line><span class=cl><span class=nf>all</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>elf</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>hex</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>TARGET</span><span class=k>)</span>.<span class=n>bin</span>
</span></span><span class=line><span class=cl>    @echo <span class=s2>&#34;Done&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.elf</span><span class=o>:</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span>/<span class=k>$(</span><span class=nv>C_OBJ</span><span class=k>)</span>
</span></span><span class=line><span class=cl>    arm-none-eabi-gcc <span class=k>$(</span>LD_FLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(BUILD_DIR)/%.o</span><span class=o>:</span> %.<span class=n>c</span>
</span></span><span class=line><span class=cl>    arm-none-eabi-gcc -c <span class=k>$(</span>CP_FLAGS<span class=k>)</span> $&lt; -o <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.hex</span><span class=o>:</span> %.<span class=n>elf</span>
</span></span><span class=line><span class=cl>    arm-none-eabi-objcopy -O ihex $&lt; <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>%.bin</span><span class=o>:</span> %.<span class=n>elf</span>
</span></span><span class=line><span class=cl>    arm-none-eabi-objcopy -O binary -S $&lt; <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>$(BUILD_DIR)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    mkdir -p <span class=nv>$@</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm <span class=k>$(</span>BUILD_DIR<span class=k>)</span> -rf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>install</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    st-flash write <span class=k>$(</span>BUILD_DIR<span class=k>)</span>/<span class=k>$(</span>TARGET<span class=k>)</span>.bin 0x08000000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>-include</span> <span class=k>$(</span><span class=nv>BUILD_DIR</span><span class=k>)</span><span class=err>/*.d</span>
</span></span></code></pre></div><p>现在目录下有这几个文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> ls
</span></span><span class=line><span class=cl><span class=go>main.c  makefile  registers.h  script.ld
</span></span></span></code></pre></div><p>编译代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> make
</span></span><span class=line><span class=cl><span class=gp>$</span> ls Build/
</span></span><span class=line><span class=cl><span class=go>led.bin  led.elf  led.hex  main.d  main.o 
</span></span></span></code></pre></div><p>查看 <code>led.bin</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> hexdump Build/led.bin
</span></span><span class=line><span class=cl><span class=go>0000000 0000 2001 0009 0800 4a06 6993 f043 0308
</span></span></span><span class=line><span class=cl><span class=go>0000010 6193 4b05 681a f442 1240 601a 2220 615a
</span></span></span><span class=line><span class=cl><span class=go>0000020 e7fe bf00 1000 4002 0c00 4001 b5f8 bf00
</span></span></span><span class=line><span class=cl><span class=go>0000030 b5f8 bf00
</span></span></span></code></pre></div><p>前面 8 个字节 <code>0000 2001 0009 0800</code> 数据从小端转换为大端就是：<code>2001 0000</code> ，<code>0800 0009</code></p><p>第一个就是在链接脚本中设置的栈顶地址 <code>0x20010000</code></p><p>第二个很可能是 main 函数的地址 <code>0x08000009</code>，最后一位表示 thumb 指令集，所以实际应该是 <code>0x08000008</code></p><p>查看一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> arm-none-eabi-objdump -D Build/led.elf
</span></span><span class=line><span class=cl><span class=go>08000008 &lt;main&gt;:
</span></span></span><span class=line><span class=cl><span class=go> 8000008:       4a06            ldr     r2, [pc, #24]   @ (8000024 &lt;main+0x1c&gt;)
</span></span></span><span class=line><span class=cl><span class=go> 8000012:       4b05            ldr     r3, [pc, #20]   @ (8000028 &lt;main+0x20&gt;)
</span></span></span></code></pre></div><p>最后下载程序，成功点亮 led，使用 stlink 烧录器和 st-flash 命令烧录（见 makefile）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ make install
</span></span></code></pre></div><h3 id=添加-data>添加 .data<a hidden class=anchor aria-hidden=true href=#添加-data>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>MEMORY</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=cm>/* 名称 (读/写/执行权限)         起始地址     大小        */</span>
</span></span><span class=line><span class=cl>    <span class=nf>SRAM</span> <span class=p>(</span><span class=n>xrw</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x20000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>64</span><span class=n>K</span>
</span></span><span class=line><span class=cl>    <span class=nf>FLASH</span> <span class=p>(</span><span class=n>rx</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>512</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ENTRY</span><span class=p>(</span><span class=n>main</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=mh>0x20010000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=n>main</span> <span class=o>|</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span><span class=n>FLASH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>data</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* AT&gt; 指令用于指定这个段的加载内存地址 */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span><span class=n>SRAM</span> <span class=n>AT</span><span class=o>&gt;</span> <span class=n>FLASH</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>相较之前做了这些改动：</p><ul><li>增加了 MEMORY 块，定义了两个区域 FLASH 和 SRAM</li><li>增加了 <code>.data</code> 段，可以存放已初始化的全局/静态变量</li><li>删除了位置计数器</li><li><code>>FLASH</code> 表示将 <code>.text</code> 段放到 FLASH 中</li><li><code>>SRAM AT> FLASH</code> 表示 <code>.data</code> 段的 VMA 在 SRAM 中，LMA 在 FLASH 中</li></ul><blockquote><p>VMA（虚拟内存地址）：程序运行时的地址，即堆栈上的地址。</p><p>LMA（加载内存地址）：程序数据存储的地址，比如已初始化的全局变量的值在 FLASH 中存储的地址就是 LMA ，当这个值被加载到 SRAM 中栈上的地址就是 VMA 。</p><p>简单来说：LMA 是在 ROM 中的地址，VMA 是在 RAM 中的地址。</p><p><code>.text</code> 没有使用 <code>AT></code> 指定 LMA，所以它的 LMA = VMA</p></blockquote><p>修改一下 <code>main.c</code> 并添加一个全局变量：<code>int a = 0xAAAABBBB</code>，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;registers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0xAAAABBBB</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span>  <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_CLK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>CRL</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>LED_PIN</span> <span class=o>*</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BSRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=mh>0xAAAABBBB</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 点亮 LED
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>看看 <code>a</code> 会被放在哪里：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> arm-none-eabi-objdump -D Build/led.elf
</span></span><span class=line><span class=cl><span class=go>Disassembly of section .data.a:
</span></span></span><span class=line><span class=cl><span class=go>20000000 &lt;a&gt;:
</span></span></span><span class="line hl"><span class=cl><span class=go>20000000:       aaaabbbb        bge     1eaaeef4 &lt;main+0x16aaeee4&gt;
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> arm-none-eabi-objdump -h Build/led.elf
</span></span><span class=line><span class=cl><span class=go>Build/led.elf:     file format elf32-littlearm
</span></span></span><span class=line><span class=cl><span class=go>Sections:
</span></span></span><span class=line><span class=cl><span class=go>Idx Name          Size      VMA       LMA       File off  Algn
</span></span></span><span class=line><span class=cl><span class=go>  0 .text         00000008  08000000  08000000  00001000  2**0
</span></span></span><span class=line><span class=cl><span class=go>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span></span><span class=line><span class=cl><span class=go>...
</span></span></span><span class="line hl"><span class=cl><span class=go>  4 .data.a       00000004  20000000  08000048  00002000  2**2
</span></span></span><span class=line><span class=cl><span class=go>                  CONTENTS, ALLOC, LOAD, DATA
</span></span></span><span class=line><span class=cl><span class=go>...
</span></span></span></code></pre></div><p>可以看到 <code>a</code> 的 VMA = <code>20000000</code>，LMA = <code>08000048</code></p><p>也就是说 <code>a</code> 存储在 FLASH 的 <code>0x08000048</code> 地址处</p><p>此时写入程序，发现 led 不点亮，因为 <code>a</code> 的值不会自己从 <code>0x08000048</code> 跑到 <code>0x20000000</code> 地址处， 所以还需要编写代码完成这个操作。</p><h3 id=初始化-data>初始化 .data<a hidden class=anchor aria-hidden=true href=#初始化-data>#</a></h3><p>初始化 <code>.data</code> 段，就是把 <code>.data</code> 中的数据搬运到栈中，我们需要知道 <code>.data</code> 的地址和栈的地址</p><p>先修改一下链接脚本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>MEMORY</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nf>SRAM</span> <span class=p>(</span><span class=n>xrw</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x20000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>64</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=nf>FLASH</span> <span class=p>(</span><span class=n>rx</span><span class=p>)</span>      <span class=o>:</span> <span class=n>ORIGIN</span> <span class=o>=</span> <span class=mh>0x08000000</span><span class=p>,</span> <span class=n>LENGTH</span> <span class=o>=</span> <span class=mi>512</span><span class=n>K</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ENTRY</span><span class=p>(</span><span class=n>Reset_Handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SECTIONS</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>text</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=mh>0x20010000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 修改了入口函数 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>LONG</span><span class=p>(</span><span class=n>Reset_Handler</span> <span class=o>|</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>text</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span><span class=n>FLASH</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 获取 .data 在 FLASH 上起始位置的加载内存地址 LMA */</span>
</span></span><span class=line><span class=cl>    <span class=n>_sidata</span>   <span class=o>=</span> <span class=nf>LOADADDR</span><span class=p>(.</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nl>data</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 获取 .data 在栈上的起始位置的虚拟内存地址 VMA*/</span>
</span></span><span class=line><span class=cl>        <span class=n>_sdata</span> <span class=o>=</span> <span class=p>.;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(.</span><span class=n>data</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 获取 .data 在栈上的结束位置的虚拟内存地址 VMA */</span>
</span></span><span class=line><span class=cl>        <span class=n>_edata</span> <span class=o>=</span> <span class=p>.;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=o>&gt;</span><span class=n>SRAM</span> <span class=n>AT</span><span class=o>&gt;</span> <span class=n>FLASH</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>现在通过变量 <code>_sidata</code>，<code>_sdata</code>，<code>_edata</code> 就能获取 <code>.data</code> 的 LMA 和 VMA，接下来需要在 main 函数运行之前把数据搬运过去，我们把数据搬运的工作交给 <code>Reset_Handler</code> 这个函数。</p><p>修改 <code>main.c</code> 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;registers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>_sidata</span><span class=p>,</span> <span class=n>_sdata</span><span class=p>,</span> <span class=n>_edata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mh>0xAAAABBBB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RCC</span><span class=o>-&gt;</span><span class=n>APB2ENR</span>  <span class=o>|=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_CLK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>CRL</span> <span class=o>|=</span> <span class=p>(</span><span class=mi>3</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>LED_PIN</span> <span class=o>*</span> <span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BSRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=mh>0xAAAABBBB</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 点亮 LED
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LED_GPIO</span><span class=o>-&gt;</span><span class=n>BRR</span>  <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>LED_PIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Reset_Handler</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// LMA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span><span class=o>*</span> <span class=n>init_data</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_sidata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// VMA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span><span class=o>*</span> <span class=n>stack_ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_sdata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>stack_ptr</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>_edata</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 搬运数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>*</span><span class=n>stack_ptr</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=n>init_data</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>main</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过 <code>Reset_Handler</code> 函数初始化 <code>.data</code> 后，再调用 <code>main</code> 主函数。</p><p>OK，成功点亮 LED ！</p><blockquote><p>类似的，初始化 <code>.bss</code> 更简单，只需要将 <code>.bss</code> 在栈上的区域赋值为 0 即可。</p></blockquote><h2 id=st-标准库启动文件>ST 标准库启动文件<a hidden class=anchor aria-hidden=true href=#st-标准库启动文件>#</a></h2><ul><li><code>gcc_ride7/startup_stm32f10x_hd.s</code></li><li><code>arm/startup_stm32f10x_hd.s</code></li></ul><p>对于 <code>gcc</code> 编译器，堆栈初始化在 <code>Reset_Handler</code> 中进行，最后会调用 <code>mian</code> 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>Reset_Handler</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=cm>/* Copy the data segment initializers from flash to SRAM */</span>
</span></span><span class=line><span class=cl>  <span class=n>movs</span>  <span class=n>r1</span><span class=p>,</span> <span class=err>#</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=n>b</span>  <span class=n>LoopCopyDataInit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>LoopFillZerobss</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=n>ldr</span>  <span class=n>r3</span><span class=p>,</span> <span class=o>=</span> <span class=n>_ebss</span>
</span></span><span class=line><span class=cl>  <span class=n>cmp</span>  <span class=n>r2</span><span class=p>,</span> <span class=n>r3</span>
</span></span><span class=line><span class=cl>  <span class=n>bcc</span>  <span class=n>FillZerobss</span>
</span></span><span class=line><span class=cl><span class=cm>/* Call the clock system intitialization function.*/</span>
</span></span><span class=line><span class=cl>  <span class=n>bl</span>  <span class=n>SystemInit</span>
</span></span><span class=line><span class=cl><span class=cm>/* Call the application&#39;s entry point.*/</span>
</span></span><span class=line><span class=cl>  <span class=n>bl</span>  <span class=n>main</span>
</span></span><span class=line><span class=cl>  <span class=n>bx</span>  <span class=n>lr</span>
</span></span></code></pre></div><p>对于 <code>ARM CC</code>（Keil 自带的编译器 AC5）<code>Reset_Handler</code> 是调用 C 库提供的 <code>__mian</code> 函数初始化堆栈，<code>__main</code> 再调用用户的 <code>main</code> 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c1>; Reset handler
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>Reset_Handler</span>   <span class=no>PROC</span>
</span></span><span class=line><span class=cl>                <span class=nf>EXPORT</span>  <span class=no>Reset_Handler</span>             <span class=p>[</span><span class=no>WEAK</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=nf>IMPORT</span>  <span class=no>__main</span>
</span></span><span class=line><span class=cl>                <span class=nf>IMPORT</span>  <span class=no>SystemInit</span>
</span></span><span class=line><span class=cl>                <span class=c1>; 调用 SystemInit 配置系统时钟
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>LDR</span>     <span class=no>R0</span><span class=p>,</span> <span class=err>=</span><span class=no>SystemInit</span>
</span></span><span class=line><span class=cl>                <span class=nf>BLX</span>     <span class=no>R0</span>
</span></span><span class=line><span class=cl>                <span class=c1>; 调用 __main
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>LDR</span>     <span class=no>R0</span><span class=p>,</span> <span class=err>=</span><span class=no>__main</span>
</span></span><span class=line><span class=cl>                <span class=nf>BX</span>      <span class=no>R0</span>
</span></span><span class=line><span class=cl>                <span class=nf>ENDP</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/stm32/>Stm32</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kingtuo123.com/>King's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=extend_footer align=center style="padding:5px 0 0"><a rel=nofollow href=mailto:kingtuo123@foxmail.com target=_blank>kingtuo123@foxmail.com</a></div><div class=extend_footer align=center style="padding:5px 0 0"><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><div class=extend_footer align=center style="padding:5px 0 10px"><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33032402001943" rel=noreferrer target=_blank>浙公网安备33032402001943</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>