<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Demystifying Firmware Linker Scripts | Notes</title><meta name=keywords content="Embedded"><meta name=description content="揭秘链接器脚本"><meta name=author content="kingtuo123"><link rel=canonical href=https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kingtuo123.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kingtuo123.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kingtuo123.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kingtuo123.com/apple-touch-icon.png><link rel=mask-icon href=https://kingtuo123.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Demystifying Firmware Linker Scripts"><meta property="og:description" content="揭秘链接器脚本"><meta property="og:type" content="article"><meta property="og:url" content="https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Demystifying Firmware Linker Scripts"><meta name=twitter:description content="揭秘链接器脚本"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kingtuo123.com/posts/"},{"@type":"ListItem","position":2,"name":"Demystifying Firmware Linker Scripts","item":"https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Demystifying Firmware Linker Scripts","name":"Demystifying Firmware Linker Scripts","description":"揭秘链接器脚本","keywords":["Embedded"],"articleBody":" 翻译自 Demystifying Firmware Linker Scripts，水平有限仅供参考。\n上一篇文章 ，我们谈到了在调用我们的主函数之前，在 MCU 上引导 C 环境。我们认为理所当然的一件事是函数和数据都被存储在二进制文件中的正确位置。今天，我们将通过学习内存区域和链接器脚本来深入了解这是如何发生的。\n你可能还记得以下自动发生的事情：\n我们使用了 \u0026_ebss 、\u0026_sdata 等变量，知道了每个部分在 flash 中的位置，并定义一些变量在 RAM 中的位置。 MCU 在地址 0x00000004 找到了指向我们的 ResetHandler 的指针地址。 你会发现一些 MCU 有不同的内存映射，一些启动脚本以不同的方式命名这些变量，而一些程序有或多或少的段。 由于它们不是标准化的，因此需要在我们工程的某个地方指定这些内容。在工程使用类似 Unix-ld 工具链接的情况下，我们就需要链接器脚本。\n链接简介 链接是编译程序的最后一个阶段。它需要许多已编译的目标文件并将它们合并到一个程序中，并填写地址，以便一切都在正确的位置。\n下面的例子中，让我们来看看 main 函数发生了什么，先用编译器生成目标文件：\n$ arm-none-eabi-gcc -c -o build/objs/a/b/c/minimal.o minimal.c 把符号 dump 出来：\n$ arm-none-eabi-nm build/objs/a/b/c/minimal.o ... 00000000 T main ... 正如预期的那样，它还没有地址。然后，我们将链接所有内容：\n$ arm-none-eabi-gcc build/objs/a/b/c/minimal.o -o build/minimal.elf 我们再把 elf 文件的符号 dump 出来：\n$ arm-none-eabi-nm build/minimal.elf ... 00000294 T main ... 链接器已经完成了它的工作，我们的主函数已经被分配了一个地址。\n链接器的作用通常不止于此。例如，它可以生成调试信息、垃圾收集未使用的代码部分或运行整个程序优化（也称为链接时间优化或 LTO）。 有关链接器的更多信息，请参阅 Stack Overflow 上的一个很棒的帖子。\n链接器脚本解析 链接描述文件包含四个内容：\nMemory layout：什么内存在哪里可用 Section definitions：程序的哪个部分应该放在哪里 Options：用于指定架构、入口点等的命令。如果需要的话 Symbols：在链接时注入程序的变量 Memory Layout 为了分配程序空间，链接器需要知道有多少内存可用，以及该内存所在的地址。这就是链接描述文件中的 MEMORY 定义的用途。\nMEMORY 的语法在 binutils 文档中定义，如下所示：\nMEMORY { name [(attr)] : ORIGIN = origin, LENGTH = len ... } name 是用于这个区域的名称，名称没有意义，可任意命名。 attr 是可选属性，例如这个区域是可读（r），可写（w），可执行（x）。flash 一般是（rx），ram 是（rwx）。将区域标记为不可写并不会使其写保护，这些属性旨在描述内存的属性，而不是设置它。 origin 是内存区域的起始地址。 len 是内存区域的大小，以字节为单位。 SAMD21G18 芯片的内存映射表如下：\n内存 起始地址 大小 内部 Flash 0x00000000 256 Kbytes 内部 SRAM 0x20000000 32 Kbytes 写成 MEMORY 定义，如下：\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } Section Definitions code 和 data 都被打包进 sections，它在内存中是一块连续的地址。没有硬性规定应该有多少 sections 或存放哪些 symbols。以下两种情况通常会把 symbols 放到同一 section 中：\n它们应该在同一个内存区域 它们需要一起初始化 在上一篇文章中，我们了解了两种批量初始化的符号：\n必须从 flash 复制的初始化静态变量 必须归零的未初始化静态变量 我们的链接器脚本涉及到的另外两样东西：\n代码和常量数据，可以存在于只读存储器（例如flash） RAM 的保留部分，如栈或堆 按照惯例，我们将这些部分命名如下：\n.text 代码和常量 .bss 未初始化的数据 .stack 栈 .data 已初始化的数据 elf spec 有完整的变量列表。你可以给它们起别的名字，即使固件能正常运行但不能保证某些工具在使用到这个固件时不会出现奇怪的错误。唯一不能用作命名的是 /DISCARD/ ，这是一个保留的关键字。\n首先，让我们看看如果我们不在链接描述文件中定义任何这些部分，我们的符号会发生什么。\nMEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } SECTIONS { /* empty! */ } 使用 objdump 查看生成的 elf 文件，我们看到以下内容：\n$ arm-none-eabi-objdump -h build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: no symbols 没有符号！虽然链接器能在几乎没有信息的情况下链接，但它至少需要知道入口点应该是什么，或者在 text section 中放置什么符号。\n.text Section 让我们从添加 .text section 开始。我们想让这个 section 在 ROM 中。下面是语法：\nSECTIONS { .text : { } \u003e rom } 上面定义了一个名为 .text 的 section，并将其添加到 ROM。然后我们需要告诉连链接器需要在 section 中添加什么。\n为了找出我们目标文件中有哪些 section。我们再 objdump 一次：\n$ arm-none-eabi-objdump -h build/objs/a/b/c/minimal.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000000 00000000 00000000 00000034 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000000 00000000 00000000 00000034 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000034 2**0 ALLOC 3 .bss.cpu_irq_critical_section_counter 00000004 00000000 00000000 00000034 2**2 ALLOC 4 .bss.cpu_irq_prev_interrupt_state 00000001 00000000 00000000 00000034 2**0 ALLOC 5 .text.system_pinmux_get_group_from_gpio_pin 0000005c 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 6 .text.port_get_group_from_gpio_pin 00000020 00000000 00000000 00000090 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 7 .text.port_get_config_defaults 00000022 00000000 00000000 000000b0 2**1 CONTENTS, ALLOC, LOAD, READONLY, CODE 8 .text.port_pin_set_output_level 0000004e 00000000 00000000 000000d2 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 9 .text.port_pin_toggle_output_level 00000038 00000000 00000000 00000120 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.set_output 00000040 00000000 00000000 00000158 2**1 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.main 0000002c 00000000 00000000 00000198 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 我们看到每一个符号都有一个 section。这是因为我们在编译时指定了 -ffucntion-sections 和 -fdata-sections 标志。如果我们没有包含这些标志，编译器可以将多个函数包含进一个 section 中去。\n在我们的链接器脚本中要将所有函数都放到 .text 中，我们可以按以下语法：\n() filename 是包含我们所需符号的输入文件的名称，section 就是该文件中包含的 section 的名称。如果我们想要取一个文件中所有的 .text section，我们可以使用 * 通配符：\n.text : { KEEP(*(.vector*)) *(.text*) } \u003e rom 这里注意 .vector section，它是入口函数 Reset_Handler 所在的 section，我们需要把它放在最前面。\nKEEP( ) 函数告诉链接器不要把 .vector section 当作垃圾回收。因为 Reset_Handler 是入口函数，我们没有在程序的任何地方调用它，链接器会把没有被调用的函数当作垃圾处理以减少最后生成文件的体积。\n编译后，我们 dump 下 elf 文件，可以看到如下：\n$ arm-none-eabi-objdump -t build/minimal.elf build/minimal.elf: file format elf32-littlearm SYMBOL TABLE: 00000000 l d .text 00000000 .text ... 00000000 l df *ABS* 00000000 minimal.c 00000000 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 0000005c l F .text 00000020 port_get_group_from_gpio_pin 0000007c l F .text 00000022 port_get_config_defaults 0000009e l F .text 0000004e port_pin_set_output_level 000000ec l F .text 00000038 port_pin_toggle_output_level 00000124 l F .text 00000040 set_output 00000000 l df *ABS* 00000000 port.c 00000190 l F .text 00000028 system_pinmux_get_config_defaults 00000000 l df *ABS* 00000000 pinmux.c 00000208 l F .text 0000005c system_pinmux_get_group_from_gpio_pin 00000264 l F .text 00000110 _system_pinmux_config 00000164 g F .text 0000002c main 000001b8 g F .text 0000004e port_pin_set_config 00000374 g F .text 00000040 system_pinmux_pin_set_config ... .bss Section .bss 段存放的是未初始化的变量，如下：\nSECTION { ... .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u003e ram } 注意 *(COMMON) ，这是一个特殊的段名，用来表示未初始化的全局变量。例如 int foo 就会在这个段中，static int foo 则不会。如果它们具有相同的名称，这允许链接器将多个定义合并到一个符号中。\n这里还使用了 NOLOAD 属性标记该段不可加载，这样当程序运行时它就不会被加载到内存中。\n在符号表中，未初始化的局部静态变量，初始化为0的全局变量及局部静态变量都wei会被表示在bss段。但是未初始化的全局变量会表示为COMMON，也相当于在bss段，但COMMON有特殊含义。未初始化的局部静态变量由于是仅编译单元内可见，不需要导出符号。所以不用置为COMMON，直接标识为bss段。\n.stack Section .stack 同样不用加载到内存中，由于堆栈不包含符号，我们需要显示的指示其大小为其保留空间。我们还必须按照 ARM 过程调用标准 AAPCS 在8字节边界上对齐堆栈。\n为了实现这些目标，我们使用一个特殊的变量 .，也称为“位置计数器”。位置计数器表示当前所在位置的地址。随着段的添加，位置计数器也会相应增加。你可以通过向前设置位置计数器来强制对齐或间隙。\nSTACK_SIZE = 0x2000; /* 8 kB */ SECTION { ... .stack (NOLOAD) : { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u003e ram ... } .data Section .data 部分包含在启动时具有初始值的静态变量。您会记得我们之前的文章中，由于断电时 RAM 不会保持不变，因此需要从 flash 加载这些部分。在启动时，Reset_Handler 在调用 main 函数之前将数据从 flash 复制到 RAM。\n为了实现这一点，我们的链接脚本中的每个部分都有两个地址，加载地址 (LMA) 和虚拟地址 (VMA)。LMA 是在ROM 中的地址，VMA 是在 RAM 中的地址。我们生成的 bin 烧录文件，它的数据顺序就是我们在链接脚本中定义的这些 sections 的顺序，bin 文件烧录到 flash 中后的顺序也是一样的，当程序运行时，我们需要把数据从 flash 拷贝到栈中，栈所在的地址就是 VMA，flash 中的地址就是 LMA。\n使用 AT 指定加载地址：\n.data : { *(.data*); } \u003e ram AT \u003e rom /* \"\u003e ram\" is the VMA, \"\u003e rom\" is the LMA */ 还可以显式指定一个地址，如下：\n.data 0x2000 : AT(0x4000) { . = ALIGN(4); _sdata = .; *(.data*); . = ALIGN(4); _edata = .; } 通常情况下从 Flash 执行的程序，text 段 VMA 和 LMA 是一样的。data 段的VMA会放在 RAM 中，LMA 会放在 flash 中，所以 data 段的 VMA 和 LMA 通常不一样。\n完整的链接器脚本 MEMORY { rom (rx) : ORIGIN = 0x00000000, LENGTH = 0x00040000 ram (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000 } STACK_SIZE = 0x2000; /* Section Definitions */ SECTIONS { .text : { KEEP(*(.vectors .vectors.*)) *(.text*) *(.rodata*) } \u003e rom /* .bss section which is used for uninitialized data */ .bss (NOLOAD) : { *(.bss*) *(COMMON) } \u003e ram .data : { *(.data*); } \u003e ram AT \u003erom /* stack section */ .stack (NOLOAD): { . = ALIGN(8); . = . + STACK_SIZE; . = ALIGN(8); } \u003e ram _end = . ; } 你可以在这里找到链接器脚本的详细语法 ld manual。\n变量 在上一篇文章中，我们依靠变量获取每个 section 的地址。\n为了能在程序中调用这些变量，链接器会生成符号并将他们添加进程序中。你可以在 linker documentation 找到相关的语法。类似C语言的变量定义：symbol = expression\n本例中，我们需要：\n_etext ： .text 段结束地址 _sdata ： .data 段起始地址 _edata ： .data 段结束地址 _sbss ： .bss 段起始地址 _ebss ： .bss 段结束地址 我们可以在每个 section 的开头和结尾使用位置计数器 . 定义变量：\n.text : { KEEP(*(.vectors .vectors.*)) *(.text.*) *(.rodata.*) _etext = .; } \u003e rom .bss (NOLOAD) : { _sbss = . ; *(.bss .bss.*) *(COMMON) _ebss = . ; } \u003e ram .data : { _sdata = .; *(.data*); _edata = .; } \u003e ram AT \u003erom 在程序中必须使用对这些变量的引用，而不是变量本身。例如，以下代码为我们提供了一个指向 .data 段起始位置的指针：\nuint8_t *data_byte = \u0026_sdata; 你可以在这里了解更多细节 binutils docs 。\n","wordCount":"951","inLanguage":"en","datePublished":"2022-05-30T00:00:00Z","dateModified":"2022-05-30T00:00:00Z","author":{"@type":"Person","name":"kingtuo123"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kingtuo123.com/posts/demystifying-firmware-linker-scripts/"},"publisher":{"@type":"Organization","name":"Notes","logo":{"@type":"ImageObject","url":"https://kingtuo123.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kingtuo123.com/ accesskey=h title="Notes (Alt + H)">Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kingtuo123.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://kingtuo123.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://kingtuo123.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://kingtuo123.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Demystifying Firmware Linker Scripts</h1><div class=post-description>揭秘链接器脚本</div><div class=post-meta><span title='2022-05-30 00:00:00 +0000 UTC'>May 30, 2022</span>&nbsp;·&nbsp;kingtuo123</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%93%be%e6%8e%a5%e7%ae%80%e4%bb%8b aria-label=链接简介>链接简介</a></li><li><a href=#%e9%93%be%e6%8e%a5%e5%99%a8%e8%84%9a%e6%9c%ac%e8%a7%a3%e6%9e%90 aria-label=链接器脚本解析>链接器脚本解析</a><ul><li><a href=#memory-layout aria-label="Memory Layout">Memory Layout</a></li></ul></li><li><a href=#section-definitions aria-label="Section Definitions">Section Definitions</a><ul><li><a href=#text-section aria-label=".text Section">.text Section</a></li><li><a href=#bss-section aria-label=".bss Section">.bss Section</a></li><li><a href=#stack-section aria-label=".stack Section">.stack Section</a></li><li><a href=#data-section aria-label=".data Section">.data Section</a></li></ul></li><li><a href=#%e5%ae%8c%e6%95%b4%e7%9a%84%e9%93%be%e6%8e%a5%e5%99%a8%e8%84%9a%e6%9c%ac aria-label=完整的链接器脚本>完整的链接器脚本</a></li><li><a href=#%e5%8f%98%e9%87%8f aria-label=变量>变量</a></li></ul></div></details></div><div class=post-content><blockquote><p>翻译自 <a href=https://interrupt.memfault.com/blog/how-to-write-linker-scripts-for-firmware>Demystifying Firmware Linker Scripts</a>，水平有限仅供参考。</p></blockquote><p><a href=https://kingtuo123.com/posts/bare-metal-c/>上一篇文章</a> ，我们谈到了在调用我们的主函数之前，在 MCU 上引导 C 环境。我们认为理所当然的一件事是函数和数据都被存储在二进制文件中的正确位置。今天，我们将通过学习内存区域和链接器脚本来深入了解这是如何发生的。</p><p>你可能还记得以下自动发生的事情：</p><ul><li>我们使用了 <code>&_ebss</code> 、<code>&_sdata</code> 等变量，知道了每个部分在 flash 中的位置，并定义一些变量在 RAM 中的位置。</li><li>MCU 在地址 <code>0x00000004</code> 找到了指向我们的 <code>ResetHandler</code> 的指针地址。</li></ul><p>你会发现一些 MCU 有不同的内存映射，一些启动脚本以不同的方式命名这些变量，而一些程序有或多或少的段。 由于它们不是标准化的，因此需要在我们工程的某个地方指定这些内容。在工程使用类似 Unix-ld 工具链接的情况下，我们就需要链接器脚本。</p><h2 id=链接简介>链接简介<a hidden class=anchor aria-hidden=true href=#链接简介>#</a></h2><p>链接是编译程序的最后一个阶段。它需要许多已编译的目标文件并将它们合并到一个程序中，并填写地址，以便一切都在正确的位置。</p><p>下面的例子中，让我们来看看 main 函数发生了什么，先用编译器生成目标文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-gcc -c -o build/objs/a/b/c/minimal.o minimal.c &lt;CFLAGS&gt;
</span></span></code></pre></div><p>把符号 dump 出来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-nm build/objs/a/b/c/minimal.o
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>00000000 T main
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>正如预期的那样，它还没有地址。然后，我们将链接所有内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-gcc &lt;LDFLAGS&gt; build/objs/a/b/c/minimal.o &lt;other object files&gt; -o build/minimal.elf
</span></span></code></pre></div><p>我们再把 elf 文件的符号 dump 出来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-nm build/minimal.elf
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>00000294 T main
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>链接器已经完成了它的工作，我们的主函数已经被分配了一个地址。</p><p>链接器的作用通常不止于此。例如，它可以生成调试信息、垃圾收集未使用的代码部分或运行整个程序优化（也称为链接时间优化或 LTO）。 有关链接器的更多信息，请参阅 <a href=https://stackoverflow.com/questions/3322911/what-do-linkers-do>Stack Overflow</a> 上的一个很棒的帖子。</p><h2 id=链接器脚本解析>链接器脚本解析<a hidden class=anchor aria-hidden=true href=#链接器脚本解析>#</a></h2><p>链接描述文件包含四个内容：</p><ul><li>Memory layout：什么内存在哪里可用</li><li>Section definitions：程序的哪个部分应该放在哪里</li><li>Options：用于指定架构、入口点等的命令。如果需要的话</li><li>Symbols：在链接时注入程序的变量</li></ul><h3 id=memory-layout>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout>#</a></h3><p>为了分配程序空间，链接器需要知道有多少内存可用，以及该内存所在的地址。这就是链接描述文件中的 MEMORY 定义的用途。</p><p>MEMORY 的语法在 <a href=https://sourceware.org/binutils/docs/ld/MEMORY.html#MEMORY>binutils</a> 文档中定义，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>MEMORY
</span></span><span class=line><span class=cl>  {
</span></span><span class=line><span class=cl>    name [(attr)] : ORIGIN = origin, LENGTH = len
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>  }
</span></span></code></pre></div><ul><li>name 是用于这个区域的名称，名称没有意义，可任意命名。</li><li>attr 是可选属性，例如这个区域是可读（r），可写（w），可执行（x）。flash 一般是（rx），ram 是（rwx）。将区域标记为不可写并不会使其写保护，这些属性旨在描述内存的属性，而不是设置它。</li><li>origin 是内存区域的起始地址。</li><li>len 是内存区域的大小，以字节为单位。</li></ul><p>SAMD21G18 芯片的内存映射表如下：</p><table><thead><tr><th style=text-align:left>内存</th><th style=text-align:left>起始地址</th><th style=text-align:left>大小</th></tr></thead><tbody><tr><td style=text-align:left>内部 Flash</td><td style=text-align:left>0x00000000</td><td style=text-align:left>256 Kbytes</td></tr><tr><td style=text-align:left>内部 SRAM</td><td style=text-align:left>0x20000000</td><td style=text-align:left>32 Kbytes</td></tr></tbody></table><p>写成 MEMORY 定义，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>MEMORY
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
</span></span><span class=line><span class=cl>  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h2 id=section-definitions>Section Definitions<a hidden class=anchor aria-hidden=true href=#section-definitions>#</a></h2><p>code 和 data 都被打包进 sections，它在内存中是一块连续的地址。没有硬性规定应该有多少 sections 或存放哪些 symbols。以下两种情况通常会把 symbols 放到同一 section 中：</p><ol><li>它们应该在同一个内存区域</li><li>它们需要一起初始化</li></ol><p>在上一篇文章中，我们了解了两种批量初始化的符号：</p><ol><li>必须从 flash 复制的初始化静态变量</li><li>必须归零的未初始化静态变量</li></ol><p>我们的链接器脚本涉及到的另外两样东西：</p><ol><li>代码和常量数据，可以存在于只读存储器（例如flash）</li><li>RAM 的保留部分，如栈或堆</li></ol><p>按照惯例，我们将这些部分命名如下：</p><ol><li><code>.text</code> 代码和常量</li><li><code>.bss</code> 未初始化的数据</li><li><code>.stack</code> 栈</li><li><code>.data</code> 已初始化的数据</li></ol><p><a href=http://refspecs.linuxbase.org/elf/elf.pdf>elf spec</a> 有完整的变量列表。你可以给它们起别的名字，即使固件能正常运行但不能保证某些工具在使用到这个固件时不会出现奇怪的错误。唯一不能用作命名的是 <code>/DISCARD/</code> ，这是一个保留的关键字。</p><p>首先，让我们看看如果我们不在链接描述文件中定义任何这些部分，我们的符号会发生什么。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>MEMORY
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
</span></span><span class=line><span class=cl>  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SECTIONS
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    /* empty! */
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>使用 objdump 查看生成的 elf 文件，我们看到以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-objdump -h build/minimal.elf
</span></span><span class=line><span class=cl>build/minimal.elf:     file format elf32-littlearm
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SYMBOL TABLE:
</span></span><span class=line><span class=cl>no symbols
</span></span></code></pre></div><p>没有符号！虽然链接器能在几乎没有信息的情况下链接，但它至少需要知道入口点应该是什么，或者在 text section 中放置什么符号。</p><h3 id=text-section>.text Section<a hidden class=anchor aria-hidden=true href=#text-section>#</a></h3><p>让我们从添加 <code>.text</code> section 开始。我们想让这个 section 在 ROM 中。下面是语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SECTIONS
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    .text :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    } &gt; rom
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>上面定义了一个名为 <code>.text</code> 的 section，并将其添加到 ROM。然后我们需要告诉连链接器需要在 section 中添加什么。</p><p>为了找出我们目标文件中有哪些 section。我们再 objdump 一次：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-objdump -h
</span></span><span class=line><span class=cl>build/objs/a/b/c/minimal.o:     file format elf32-littlearm
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Sections:
</span></span><span class=line><span class=cl>Idx Name          Size      VMA       LMA       File off  Algn
</span></span><span class=line><span class=cl>  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span class=line><span class=cl>  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA
</span></span><span class=line><span class=cl>  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC
</span></span><span class=line><span class=cl>  3 .bss.cpu_irq_critical_section_counter 00000004  00000000  00000000  00000034  2**2                  ALLOC
</span></span><span class=line><span class=cl>  4 .bss.cpu_irq_prev_interrupt_state 00000001  00000000  00000000  00000034  2**0                  ALLOC
</span></span><span class=line><span class=cl>  5 .text.system_pinmux_get_group_from_gpio_pin 0000005c  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span class=line><span class=cl>  6 .text.port_get_group_from_gpio_pin 00000020  00000000  00000000  00000090  2**1                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span><span class=line><span class=cl>  7 .text.port_get_config_defaults 00000022  00000000  00000000  000000b0  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span class=line><span class=cl>  8 .text.port_pin_set_output_level 0000004e  00000000  00000000  000000d2  2**1                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span><span class=line><span class=cl>  9 .text.port_pin_toggle_output_level 00000038  00000000  00000000  00000120  2**1                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span><span class=line><span class=cl> 10 .text.set_output 00000040  00000000  00000000  00000158  2**1                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span><span class=line><span class=cl> 11 .text.main    0000002c  00000000  00000000  00000198  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span></code></pre></div><p>我们看到每一个符号都有一个 section。这是因为我们在编译时指定了 <code>-ffucntion-sections</code> 和 <code>-fdata-sections</code> 标志。如果我们没有包含这些标志，编译器可以将多个函数包含进一个 section 中去。</p><p>在我们的链接器脚本中要将所有函数都放到 <code>.text</code> 中，我们可以按以下语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;filename&gt;(&lt;section&gt;)
</span></span></code></pre></div><p><code>filename</code> 是包含我们所需符号的输入文件的名称，<code>section</code> 就是该文件中包含的 section 的名称。如果我们想要取一个文件中所有的 <code>.text</code> section，我们可以使用 <code>*</code> 通配符：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>.text :
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    KEEP(*(.vector*))
</span></span><span class=line><span class=cl>    *(.text*)
</span></span><span class=line><span class=cl>} &gt; rom
</span></span></code></pre></div><p>这里注意 <code>.vector</code> section，它是入口函数 <code>Reset_Handler</code> 所在的 section，我们需要把它放在最前面。</p><blockquote><p>KEEP( ) 函数告诉链接器不要把 .vector section 当作垃圾回收。因为 Reset_Handler 是入口函数，我们没有在程序的任何地方调用它，链接器会把没有被调用的函数当作垃圾处理以减少最后生成文件的体积。</p></blockquote><p>编译后，我们 dump 下 elf 文件，可以看到如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ arm-none-eabi-objdump -t build/minimal.elf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>build/minimal.elf:     file format elf32-littlearm
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SYMBOL TABLE:
</span></span><span class=line><span class=cl>00000000 l    d  .text  00000000 .text
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>00000000 l    df *ABS*  00000000 minimal.c
</span></span><span class=line><span class=cl>00000000 l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
</span></span><span class=line><span class=cl>0000005c l     F .text  00000020 port_get_group_from_gpio_pin
</span></span><span class=line><span class=cl>0000007c l     F .text  00000022 port_get_config_defaults
</span></span><span class=line><span class=cl>0000009e l     F .text  0000004e port_pin_set_output_level
</span></span><span class=line><span class=cl>000000ec l     F .text  00000038 port_pin_toggle_output_level
</span></span><span class=line><span class=cl>00000124 l     F .text  00000040 set_output
</span></span><span class=line><span class=cl>00000000 l    df *ABS*  00000000 port.c
</span></span><span class=line><span class=cl>00000190 l     F .text  00000028 system_pinmux_get_config_defaults
</span></span><span class=line><span class=cl>00000000 l    df *ABS*  00000000 pinmux.c
</span></span><span class=line><span class=cl>00000208 l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
</span></span><span class=line><span class=cl>00000264 l     F .text  00000110 _system_pinmux_config
</span></span><span class=line><span class=cl>00000164 g     F .text  0000002c main
</span></span><span class=line><span class=cl>000001b8 g     F .text  0000004e port_pin_set_config
</span></span><span class=line><span class=cl>00000374 g     F .text  00000040 system_pinmux_pin_set_config
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><h3 id=bss-section>.bss Section<a hidden class=anchor aria-hidden=true href=#bss-section>#</a></h3><p><code>.bss</code> 段存放的是未初始化的变量，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SECTION {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    .bss (NOLOAD) :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        *(.bss*)
</span></span><span class=line><span class=cl>        *(COMMON)
</span></span><span class=line><span class=cl>    } &gt; ram
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>注意 <code>*(COMMON)</code> ，这是一个特殊的段名，用来表示未初始化的全局变量。例如 <code>int foo</code> 就会在这个段中，<code>static int foo</code> 则不会。如果它们具有相同的名称，这允许链接器将多个定义合并到一个符号中。</p><p>这里还使用了 <code>NOLOAD</code> 属性标记该段不可加载，这样当程序运行时它就不会被加载到内存中。</p><blockquote><p>在符号表中，未初始化的局部静态变量，初始化为0的全局变量及局部静态变量都wei会被表示在bss段。但是未初始化的全局变量会表示为COMMON，也相当于在bss段，但COMMON有特殊含义。未初始化的局部静态变量由于是仅编译单元内可见，不需要导出符号。所以不用置为COMMON，直接标识为bss段。</p></blockquote><h3 id=stack-section>.stack Section<a hidden class=anchor aria-hidden=true href=#stack-section>#</a></h3><p><code>.stack</code> 同样不用加载到内存中，由于堆栈不包含符号，我们需要显示的指示其大小为其保留空间。我们还必须按照 ARM 过程调用标准 <a href=https://static.docs.arm.com/ddi0403/ec/DDI0403E_c_armv7m_arm.pdf>AAPCS</a> 在8字节边界上对齐堆栈。</p><p>为了实现这些目标，我们使用一个特殊的变量 <code>.</code>，也称为“位置计数器”。位置计数器表示当前所在位置的地址。随着段的添加，位置计数器也会相应增加。你可以通过向前设置位置计数器来强制对齐或间隙。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>STACK_SIZE = 0x2000; /* 8 kB */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SECTION {
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    .stack (NOLOAD) :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        . = ALIGN(8);
</span></span><span class=line><span class=cl>        . = . + STACK_SIZE;
</span></span><span class=line><span class=cl>        . = ALIGN(8);
</span></span><span class=line><span class=cl>    } &gt; ram
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=data-section>.data Section<a hidden class=anchor aria-hidden=true href=#data-section>#</a></h3><p>.data 部分包含在启动时具有初始值的静态变量。您会记得我们之前的文章中，由于断电时 RAM 不会保持不变，因此需要从 flash 加载这些部分。在启动时，Reset_Handler 在调用 main 函数之前将数据从 flash 复制到 RAM。</p><p>为了实现这一点，我们的链接脚本中的每个部分都有两个地址，加载地址 (LMA) 和虚拟地址 (VMA)。LMA 是在ROM 中的地址，VMA 是在 RAM 中的地址。我们生成的 bin 烧录文件，它的数据顺序就是我们在链接脚本中定义的这些 sections 的顺序，bin 文件烧录到 flash 中后的顺序也是一样的，当程序运行时，我们需要把数据从 flash 拷贝到栈中，栈所在的地址就是 VMA，flash 中的地址就是 LMA。</p><p>使用 <code>AT</code> 指定加载地址：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>.data :
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    *(.data*);
</span></span><span class=line><span class=cl>} &gt; ram AT &gt; rom  /* &#34;&gt; ram&#34; is the VMA, &#34;&gt; rom&#34; is the LMA */
</span></span></code></pre></div><p>还可以显式指定一个地址，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>.data 0x2000 : AT(0x4000)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    . = ALIGN(4);
</span></span><span class=line><span class=cl>    _sdata = .;
</span></span><span class=line><span class=cl>    *(.data*);
</span></span><span class=line><span class=cl>    . = ALIGN(4);
</span></span><span class=line><span class=cl>    _edata = .;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><blockquote><p>通常情况下从 Flash 执行的程序，text 段 VMA 和 LMA 是一样的。data 段的VMA会放在 RAM 中，LMA 会放在 flash 中，所以 data 段的 VMA 和 LMA 通常不一样。</p></blockquote><h2 id=完整的链接器脚本>完整的链接器脚本<a hidden class=anchor aria-hidden=true href=#完整的链接器脚本>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>MEMORY
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  rom      (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
</span></span><span class=line><span class=cl>  ram      (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00008000
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>STACK_SIZE = 0x2000;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Section Definitions */
</span></span><span class=line><span class=cl>SECTIONS
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    .text :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        KEEP(*(.vectors .vectors.*))
</span></span><span class=line><span class=cl>        *(.text*)
</span></span><span class=line><span class=cl>        *(.rodata*)
</span></span><span class=line><span class=cl>    } &gt; rom
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* .bss section which is used for uninitialized data */
</span></span><span class=line><span class=cl>    .bss (NOLOAD) :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        *(.bss*)
</span></span><span class=line><span class=cl>        *(COMMON)
</span></span><span class=line><span class=cl>    } &gt; ram
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    .data :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        *(.data*);
</span></span><span class=line><span class=cl>    } &gt; ram AT &gt;rom
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* stack section */
</span></span><span class=line><span class=cl>    .stack (NOLOAD):
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        . = ALIGN(8);
</span></span><span class=line><span class=cl>        . = . + STACK_SIZE;
</span></span><span class=line><span class=cl>        . = ALIGN(8);
</span></span><span class=line><span class=cl>    } &gt; ram
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    _end = . ;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>你可以在这里找到链接器脚本的详细语法 <a href=https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS>ld manual</a>。</p><h2 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h2><p>在上一篇文章中，我们依靠变量获取每个 section 的地址。</p><p>为了能在程序中调用这些变量，链接器会生成符号并将他们添加进程序中。你可以在 <a href=https://sourceware.org/binutils/docs/ld/Simple-Assignments.html#Simple-Assignments>linker documentation</a> 找到相关的语法。类似C语言的变量定义：<code>symbol = expression</code></p><p>本例中，我们需要：</p><ol><li><code>_etext</code> ： <code>.text</code> 段结束地址</li><li><code>_sdata</code> ： <code>.data</code> 段起始地址</li><li><code>_edata</code> ： <code>.data</code> 段结束地址</li><li><code>_sbss</code> ： <code>.bss</code> 段起始地址</li><li><code>_ebss</code> ： <code>.bss</code> 段结束地址</li></ol><p>我们可以在每个 section 的开头和结尾使用位置计数器 <code>.</code> 定义变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>.text :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        KEEP(*(.vectors .vectors.*))
</span></span><span class=line><span class=cl>        *(.text.*)
</span></span><span class=line><span class=cl>        *(.rodata.*)
</span></span><span class=line><span class=cl>        _etext = .;
</span></span><span class=line><span class=cl>    } &gt; rom
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    .bss (NOLOAD) :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        _sbss = . ;
</span></span><span class=line><span class=cl>        *(.bss .bss.*)
</span></span><span class=line><span class=cl>        *(COMMON)
</span></span><span class=line><span class=cl>        _ebss = . ;
</span></span><span class=line><span class=cl>    } &gt; ram
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    .data :
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        _sdata = .;
</span></span><span class=line><span class=cl>        *(.data*);
</span></span><span class=line><span class=cl>        _edata = .;
</span></span><span class=line><span class=cl>    } &gt; ram AT &gt;rom
</span></span></code></pre></div><p>在程序中必须使用对这些变量的引用，而不是变量本身。例如，以下代码为我们提供了一个指向 .data 段起始位置的指针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>uint8_t</span> <span class=o>*</span><span class=n>data_byte</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>_sdata</span><span class=p>;</span>
</span></span></code></pre></div><p>你可以在这里了解更多细节 <a href=https://sourceware.org/binutils/docs/ld/Source-Code-Reference.html>binutils docs</a> 。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kingtuo123.com/tags/embedded/>Embedded</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://kingtuo123.com/>Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><div class=footer align=center style=margin-top:-30px><a href=https://beian.miit.gov.cn/ target=_blank>浙ICP备19041170号</a></div><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>